#!/usr/bin/env python

######################################################.
# 	        Testing CURATE with pytest 	             #
######################################################.

import os
import glob
import pytest
import shutil
import subprocess
import pandas as pd

# saves the working directory
path_tests = os.getcwd() + "/tests"
path_curate = os.getcwd() + "/CURATE"

# CURATE tests
@pytest.mark.parametrize(
    "test_job",
    [
        (
            "categorical"
        ),  # categorical with numbers test
        (
            "nan_fix"
        ),  # test that empty values are replaced by 0s
        (
            "corr_filter_x"
        ),  # test to disable the correlation filter of X
        (
            "corr_filter_y"
        ),  # test to disable the correlation filter of y
        (
            "filter_thres"
        ),  # test to check the thresholds of the correlation filters
        (
            "filter_thres_yaml"
        ),  # test to check the thresholds of the correlation filters with a yaml file  
        (
            "csv_separator"
        ),  # test to check the separator of the CSV file
        (
            "missing_input"
        ),  # test that if the --names, --y or --csv_name options are empty, a prompt pops up and asks for them
        (
            "rfecv"
        ),  # test for the RFECV feature, default
        (
            "standard"
        ),  # standard test  

    ],
)
def test_CURATE(test_job):

    # leave the folders as they were initially to run a different batch of tests
    if os.path.exists(f"{path_curate}"):
        shutil.rmtree(f"{path_curate}")
        # remove DAT and CSV files generated by CURATE
        dat_files = glob.glob("*.dat")
        for dat_file in dat_files:
            if "CURATE" in dat_file:
                os.remove(dat_file)

    # runs the program with the different tests
    cmd_robert = [
        "python",
        "-m",
        "robert",
        "--curate",
        "--discard", "['xtest']"
    ]

    if test_job != 'missing_input':
        if test_job == 'rfecv':
            csv_name = 'A_randos.csv'
        else:
            csv_name = 'Robert_example.csv'

        cmd_robert = cmd_robert + ['--y','Target_values',
                                   "--csv_name", f"{path_tests}/{csv_name}",
                                   "--names","Name"]

    if test_job == "standard":
        subprocess.run(cmd_robert)

        # check that the DAT file is created inside the CURATE folder
        assert not os.path.exists("CURATE_data.dat")
        outfile = open(f"{path_curate}/CURATE_data.dat", "r")
        outlines = outfile.readlines()
        outfile.close()
        assert "ROBERT v" in outlines[0]

        # check that descriptors are removed correctly
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        # 1. Duplicate entries are removed
        assert len(db_final['Name']) == 37
        # 2. Correlated variables with X and noise (low R2 with y) are removed
        discard_vars = ['x1','x3','x5', 'x6']
        for var in discard_vars:
            assert var not in db_final.columns
        # 3. Ignored variables and y are kept
        assert 'Name' in db_final.columns
        assert 'Target_values' in db_final.columns
        # 4. Discarded variables are removed
        assert 'xtest' not in db_final.columns
        # 5. The rest of the variables are kept
        final_vars = ['x2','x7','x8','x9','x10','x11','ynoise']
        for var in final_vars:
            assert var in db_final.columns

        # check that categorical variables are converted with one-hot encoding
        categ_vars = ['Csub-H','Csub-Csub','H-O']
        for var in categ_vars:
            assert var in db_final.columns
        assert 'x4' not in db_final.columns
        for val in db_final['Csub-H']:
            assert val in [0,1]

        # check that the CURATE options are stored
        db_save = pd.read_csv(f"{path_curate}/CURATE_options.csv")
        assert db_save['y'][0] == "Target_values"
        assert db_save['ignore'][0] == "['Name']"
        assert 'Robert_example_CURATE.csv' in db_save['csv_name'][0]

        #check that the Pearson heatplot is created
        assert os.path.exists(f'{path_curate}/Pearson_heatmap.png')

        # Check if the descriptors were reduced correctly (less than 1/3 of the data points)
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        n_descps = len(db_final.columns) - 2  # subtracting 'Name' and 'Target_values'
        datapoints = len(db_final)
        assert n_descps < (datapoints / 3)

    elif test_job == "categorical":
        cmd_robert = cmd_robert + ['--categorical', 'numbers']
        subprocess.run(cmd_robert)

        # check if variable x4 was changed
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        assert 'x4' in db_final.columns
        assert 3 in db_final['x4']

    elif test_job == "nan_fix":
        cmd_robert = [
            "python",
            "-m",
            "robert",
            "--curate",
            "--csv_name", f"{path_tests}/Robert_example_NaNs.csv",
            '--y', 'Target_values',
            "--names", "Name",
            "--discard", "['xtest']"
        ]
        subprocess.run(cmd_robert)

        # check that all the missing values were filled
        db_final = pd.read_csv(f"{path_curate}/Robert_example_NaNs_CURATE.csv")
        # 1. Duplicate entries are removed
        assert isinstance(db_final['x2'][4], (int, float))
        assert isinstance(db_final['x2'][0], (int, float))

    elif test_job == 'corr_filter_x':
        cmd_robert = [
            "python",
            "-m",
            "robert",
            "--curate",
            "--csv_name", f"{path_tests}/Robert_example.csv",
            '--y', 'Target_values',
            "--names", 'Name',
            "--discard", "['xtest']",
            "--corr_filter_x", "False"
        ]
        subprocess.run(cmd_robert)
        
        # check that descriptors aren't removed 
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        discard_vars = ['x1','x3','x5','x6','Csub-O']
        for var in discard_vars:
            assert var in db_final.columns

    elif test_job == 'corr_filter_y':
        cmd_robert = [
            "python",
            "-m",
            "robert",
            "--curate",
            "--csv_name", f"{path_tests}/Robert_example.csv",
            '--y', 'Target_values',
            "--names", 'Name',
            "--discard", "['xtest']",
            "--corr_filter_y", "True"
        ]
        subprocess.run(cmd_robert)
        
        # check that descriptors aren't removed 
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        assert 'ynoise' not in db_final.columns

    elif test_job in ['filter_thres','filter_thres_yaml']:
        if test_job == 'filter_thres':
            cmd_robert = [
                "python",
                "-m",
                "robert",
                "--curate",
                "--csv_name", f"{path_tests}/Robert_example.csv",
                '--y', 'Target_values',
                "--name", "Name",
                "--discard", "['xtest']",
                "--thres_x", "0.999",
                "--corr_filter_y", "True",
                "--thres_y", "0.000001"
            ]
        elif test_job == 'filter_thres_yaml':
            cmd_robert = [
                "python",
                "-m",
                "robert",
                "--varfile", f"{path_tests}/params.yaml",
                "--csv_name", f"{path_tests}/Robert_example.csv",
            ]
        subprocess.run(cmd_robert)
        
        # check that descriptors aren't removed
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        # check x threshold
        assert 'x1' in db_final.columns
        # check y threshold
        assert 'ynoise' in db_final.columns

    elif test_job == 'csv_separator':

        # restore original files
        if os.path.exists(f"{path_tests}/Robert_example_separator_original.csv"):
            if os.path.exists(f"{path_tests}/Robert_example_separator.csv"):
                os.remove(f"{path_tests}/Robert_example_separator.csv")
                shutil.move(f"{path_tests}/Robert_example_separator_original.csv",f"{path_tests}/Robert_example_separator.csv")

        # Test to check if the separator of the CSV file is correctly read
        cmd_robert = [
            "python",
            "-m",
            "robert",
            "--curate",
            "--csv_name", f"{path_tests}/Robert_example_separator.csv",
            '--y', 'Target_values',
            "--names", "Name",
            "--discard", "['xtest']"
        ]
        subprocess.run(cmd_robert)

        # check that the DAT file has a warning about the separator
        assert not os.path.exists("CURATE_data.dat")
        outfile = open(f"{path_curate}/CURATE_data.dat", "r")
        outlines = outfile.readlines()
        outfile.close()
        input_found = False
        for line in outlines:
            if "x  WARNING! The original database was not a valid CSV (i.e., formatting issues from Microsoft Excel?)." in line:
                input_found = True
        assert input_found

        # check that the CSV file has the correct separator
        csv_file = pd.read_csv(f"{path_tests}/Robert_example_separator_original.csv", sep=";")
        csv_file_new = pd.read_csv(f"{path_tests}/Robert_example_separator.csv", sep=",")
        assert csv_file.equals(csv_file_new)

        # restore original files
        os.remove(f"{path_tests}/Robert_example_separator.csv")
        shutil.move(f"{path_tests}/Robert_example_separator_original.csv",f"{path_tests}/Robert_example_separator.csv")
    
    elif test_job == 'missing_input':
        # since we're inputting values for input() prompts, we use command lines and provide
        # the answers with external files using "< FILENAME_WITH_ANSWERS" in the command line

        missing_options = ['csv_name', 'y', 'names']
        for missing_option in missing_options:
            if missing_option == 'csv_name':
                cmd_missing = cmd_robert + ['--y','Target_values',
                                            "--names","Name"]
            elif missing_option == 'y':
                cmd_missing = cmd_robert + ["--csv_name", f"{path_tests}/Robert_example.csv",
                                            "--names","Name"]
            elif missing_option == 'names':
                cmd_missing = cmd_robert + ['--y','Target_values',
                                            "--csv_name", f"{path_tests}/Robert_example.csv"]

            cmd_missing = f'{" ".join(cmd_missing)} < {path_tests}/{missing_option}.txt'
            os.system(cmd_missing)
            outfile = open(f"{path_curate}/CURATE_data.dat", "r")
            outlines = outfile.readlines()
            outfile.close()
            input_found,curate_valid = False,False
            for line in outlines:
                if missing_option == 'csv_name':
                    if "-  csv_name option set to tests/Robert_example.csv by the user" in line:
                        input_found = True
                elif missing_option == 'y':
                    if "-  y option set to Target_values by the user" in line:
                        input_found = True
                elif missing_option == 'names':
                    if "-  names option set to Name by the user" in line:
                        input_found = True
                if 'o  The Pearson heatmap was stored in CURATE/Pearson_heatmap.png' in line:
                    curate_valid = True
            assert input_found
            assert curate_valid

    elif test_job == "rfecv":
        subprocess.run(cmd_robert)

        # check if variables are discarded right with RFECV
        db_final = pd.read_csv(f"{path_curate}/{csv_name.split('.csv')[0]}_CURATE.csv")
        assert 'rando4' not in db_final.columns

        accepted_vars = ['E_HOMO','V_Bur','dist', 'rando1', 'rando2', 'rando3']
        for var in accepted_vars:
            assert var in db_final.columns

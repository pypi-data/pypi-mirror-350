"""
Handle RTL generation
"""
# Necessary imports, path setup, and global variables
import argparse
import os
import re
from itertools import product
from pathlib import Path

import prettytable
from rapidfuzz import fuzz

from .arguments import update_used_args
from .format import format_rtl, get_pretty_name

PRESERVING_REGEXES = [
    # These regexes preserve the parameter tag that identifies the parameter
    re.compile(r"//[^\n]*#{\((?P<parameter_name>\w*)\)}\s*(?P<replace>.*?)\s*//[^\n]*#{/\((?P=parameter_name)\)}", re.MULTILINE | re.DOTALL),
    re.compile(r"/\*[^\n]*#{\((?P<parameter_name>\w*)\)}[^\n]*\*/\s*(?P<replace>.*?)\s*/\*[^\n]*#{/\((?P=parameter_name)\)}[^\n]*\*/"),
]

DESTROYING_REGEXES = [
    # These regexes destroy the parameter tag that identifies the parameter
    re.compile(r"(?P<replace>#{\((?P<parameter_name>\w+?)\)})"),
]

#####################################################################################################
# Base methods needed for all RTL generators                                                        #
#####################################################################################################
def make_substitution(template: str, context: str, replace_str: str, replace_with: str) -> str:
    """
    Make a substitution in the context string.
    """
    assert template
    if not context or not replace_str or not replace_with:
        return template
    
    replaced = context.replace(replace_str, replace_with, 1)
    return template.replace(context, replaced, 1)


def fill_in_template(template: str, args: argparse.Namespace | None, scope: dict) -> str:
    """
    Fill in the template with the arguments and variables.

    Matches using the regex "#{((\w+?))}".

    Looks for the key in the arguments, variables, and global functions, in that order.
    """
    if 'args' not in scope:
        scope['args'] = args

    if 'used_args' not in scope:
        scope['used_args'] = set()

    filled_in = template[:]
    for match_regex, preserving in list(product(PRESERVING_REGEXES, (True,))) + list(product(DESTROYING_REGEXES, (False,))):
        for key_match in match_regex.finditer(template):
            context = key_match.group()
            parameter_name = key_match.group("parameter_name")
            replace_str = key_match.group("replace")

            if parameter_name in scope['used_args'] and not preserving:
                continue
            
            update_used_args(scope, [parameter_name])
            if parameter_name in scope:
                # Key is a variable or function in this file
                if callable(scope[parameter_name]):
                    scope.update(locals())
                    replace_with = scope[parameter_name](scope)
                else:
                    replace_with = str(scope[parameter_name])
            else:
                # This will raise an error if the key is not a defined variable or a function in the global scope
                try:
                    if callable(globals()[parameter_name]):
                        scope.update(locals())
                        replace_with = globals()[parameter_name](scope)
                    else:
                        replace_with = str(globals()[parameter_name])
                except KeyError:
                    raise KeyError(f"No way to fill template key: {parameter_name}")
            
            # replaced = context.replace(replace_str, replace_with, 1)
            # filled_in = filled_in.replace(context, replaced, 1)
            filled_in = make_substitution(filled_in, context, replace_str, replace_with)

    return format_rtl(filled_in)


def param_table(scope: dict) -> str:
    """
    Include the used arguments table
    """
    table_ctx = scope.get("context")
    table_replace_str = scope.get("replace_str")
    scope['table_ctx'] = table_ctx
    scope['table_replace_str'] = table_replace_str

    return ""


def init_msg(template: str) -> str:
    """
    Generate the info text for the top of the generated RTL
    """
    init_msg = """
//! This file generated by [rtl-generator](https://github.com/burnettlab/rtl-generator.git), written by Brandon Hippe
//!
//! ## Generator Arguments
// #{(param_table)}
    """.strip()

    newline_count = init_msg.count('\n')
    c, ix = 0, 0
    while c < newline_count:
        check = template.index("\n", ix)
        if check == -1:
            break
        ix = check + 1
        c += 1
    
    if check > 0:
        check = template[:ix]
    else:
        check = template[:]

    if fuzz.ratio(init_msg, check) > 80:
        template = template.replace(check, "")
    else:
        init_msg += """
// PARAMETER TABLE GOES HERE
// #{/(param_table)}
        """

    return f"{init_msg.strip()}\n{template}"


def included_modules(scope: dict) -> str:
    """
    Get the list of included modules
    """
    cwd = Path(os.getcwd())
    subdirs = map(lambda p: Path(*Path(p[1]).parts[-2:]), filter(lambda a: a[0].endswith("output") and Path(a[1]).parent.parent == cwd, vars(scope['args']).items()))
    return "\n".join(map(lambda p: f"`include \"{str(p)}\"", subdirs))


def rtl_generator(rtl_name: str, args: argparse.Namespace, scope: dict) -> str:
    """
    Generate RTL code
    """
    print("\n" + "-" * os.get_terminal_size().columns)
    print(f"Generating RTL for module: {get_pretty_name(rtl_name)}")
    
    with open(getattr(args, f"{rtl_name}_input"), "r", encoding='UTF-8') as f:
        template = init_msg(f.read())

    used_args = set()
    scope['used_args'] = used_args
    generated = fill_in_template(template, args, scope)

    print("\nArguments:")
    arg_table = prettytable.PrettyTable()
    arg_table.field_names = ["Argument", "Value"]
    for arg, value in sorted(map(lambda a: (a, vars(args)[a]), filter(args.__contains__, used_args))):
        arg_table.add_row([arg, value])

    arg_table.set_style(prettytable.MARKDOWN)

    if table_ctx := scope.get('table_ctx', None):
        table_replace_str = scope.get('table_replace_str')
        table_str = '\n'.join(map(lambda l: f"//!{l}", [""] + arg_table.get_string().splitlines() + [""]))
        generated = make_substitution(generated, table_ctx, table_replace_str, table_str)

    arg_table.add_row([f"{rtl_name}_output", getattr(args, f"{rtl_name}_output")])
    arg_table.set_style(prettytable.DOUBLE_BORDER)
    print(arg_table.get_string())
    print(f"\nFinished generating RTL for module: {get_pretty_name(rtl_name)}")

    return generated

# coding: utf-8

"""
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, Generator, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr
from typing_extensions import Annotated

from defectdojo_api_generated.api_client import ApiClient, RequestSerialized
from defectdojo_api_generated.api_response import ApiResponse
from defectdojo_api_generated.helpers import IteratorResult, get_all_pages
from defectdojo_api_generated.models.accepted_risk_request import AcceptedRiskRequest
from defectdojo_api_generated.models.add_new_note_option_request import AddNewNoteOptionRequest
from defectdojo_api_generated.models.file import File
from defectdojo_api_generated.models.note import Note
from defectdojo_api_generated.models.paginated_delete_preview_list import PaginatedDeletePreviewList
from defectdojo_api_generated.models.paginated_test_list import PaginatedTestList
from defectdojo_api_generated.models.patched_test_request import PatchedTestRequest
from defectdojo_api_generated.models.raw_file import RawFile
from defectdojo_api_generated.models.report_generate import ReportGenerate
from defectdojo_api_generated.models.report_generate_option_request import ReportGenerateOptionRequest
from defectdojo_api_generated.models.risk_acceptance import RiskAcceptance
from defectdojo_api_generated.models.test import Test
from defectdojo_api_generated.models.test_create import TestCreate
from defectdojo_api_generated.models.test_create_request import TestCreateRequest
from defectdojo_api_generated.models.test_request import TestRequest
from defectdojo_api_generated.models.test_to_files import TestToFiles
from defectdojo_api_generated.models.test_to_notes import TestToNotes
from defectdojo_api_generated.rest import RESTResponseType

if TYPE_CHECKING:
    """placeholder for IteratorResult types if any"""
    from defectdojo_api_generated.models import DeletePreview, Test


class TestsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    def tests_accept_risks_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        accepted_risk_request: List[AcceptedRiskRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RiskAcceptance]:
        """tests_accept_risks_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_accept_risks_create_serialize(
            id=id,
            accepted_risk_request=accepted_risk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'List[RiskAcceptance]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_accept_risks_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        accepted_risk_request: List[AcceptedRiskRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RiskAcceptance]]:
        """tests_accept_risks_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_accept_risks_create_serialize(
            id=id,
            accepted_risk_request=accepted_risk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'List[RiskAcceptance]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_accept_risks_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        accepted_risk_request: List[AcceptedRiskRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_accept_risks_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_accept_risks_create_serialize(
            id=id,
            accepted_risk_request=accepted_risk_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'List[RiskAcceptance]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_accept_risks_create_serialize(
        self,
        id,
        accepted_risk_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'AcceptedRiskRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if accepted_risk_request is not None:
            _body_params = accepted_risk_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/tests/{id}/accept_risks/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_create(
        self,
        test_create_request: TestCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestCreate:
        """tests_create


        :param test_create_request: (required)
        :type test_create_request: TestCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_create_serialize(
            test_create_request=test_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'TestCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_create_with_http_info(
        self,
        test_create_request: TestCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestCreate]:
        """tests_create


        :param test_create_request: (required)
        :type test_create_request: TestCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_create_serialize(
            test_create_request=test_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'TestCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_create_without_preload_content(
        self,
        test_create_request: TestCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_create


        :param test_create_request: (required)
        :type test_create_request: TestCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_create_serialize(
            test_create_request=test_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'TestCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_create_serialize(
        self,
        test_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if test_create_request is not None:
            _body_params = test_create_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/tests/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_delete_preview_list(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedDeletePreviewList:
        """tests_delete_preview_list


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_delete_preview_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedDeletePreviewList]:
        """tests_delete_preview_list


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_delete_preview_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_delete_preview_list


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_delete_preview_list_serialize(
        self,
        id,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            _query_params.append(('limit', limit))

        if offset is not None:
            _query_params.append(('offset', offset))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/{id}/delete_preview/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_delete_preview_list_iterator(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[DeletePreview, PaginatedDeletePreviewList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, TestsApi.tests_delete_preview_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def tests_destroy(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """tests_destroy


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_destroy_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """tests_destroy


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_destroy_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_destroy


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_destroy_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/tests/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_files_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """tests_files_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_files_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """tests_files_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_files_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_files_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_files_create_serialize(
        self,
        id,
        title,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if title is not None:
            _form_params.append(('title', title))
        if file is not None:
            _files['file'] = file
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(['multipart/form-data'])
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/tests/{id}/files/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_files_download_retrieve(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RawFile:
        """tests_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_files_download_retrieve_with_http_info(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RawFile]:
        """tests_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_files_download_retrieve_without_preload_content(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_files_download_retrieve_serialize(
        self,
        file_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['file_id'] = file_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/{id}/files/download/{file_id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_files_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestToFiles:
        """tests_files_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_files_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestToFiles]:
        """tests_files_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_files_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_files_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_files_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/{id}/files/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_generate_report_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReportGenerate:
        """tests_generate_report_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_generate_report_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReportGenerate]:
        """tests_generate_report_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_generate_report_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_generate_report_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_generate_report_create_serialize(
        self,
        id,
        report_generate_option_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if report_generate_option_request is not None:
            _body_params = report_generate_option_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/tests/{id}/generate_report/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_list(
        self,
        actual_time: Optional[StrictStr] = None,
        api_scan_configuration: Optional[StrictInt] = None,
        branch_tag: Optional[StrictStr] = None,
        build_id: Optional[StrictStr] = None,
        commit_hash: Optional[StrictStr] = None,
        engagement: Optional[StrictInt] = None,
        engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        not_engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        notes: Optional[List[StrictInt]] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        percent_complete: Optional[StrictInt] = None,
        scan_type: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        target_end: Optional[datetime] = None,
        target_start: Optional[datetime] = None,
        test_type: Optional[StrictInt] = None,
        title: Optional[StrictStr] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedTestList:
        """tests_list


        :param actual_time:
        :type actual_time: str
        :param api_scan_configuration:
        :type api_scan_configuration: int
        :param branch_tag:
        :type branch_tag: str
        :param build_id:
        :type build_id: str
        :param commit_hash:
        :type commit_hash: str
        :param engagement:
        :type engagement: int
        :param engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type engagement__product__tags: List[str]
        :param engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type engagement__product__tags__and: List[str]
        :param engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type engagement__tags: List[str]
        :param engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type engagement__tags__and: List[str]
        :param has_tags: Has tags
        :type has_tags: bool
        :param id:
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param not_engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_engagement__product__tags: List[str]
        :param not_engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_engagement__tags: List[str]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param notes:
        :type notes: List[int]
        :param o: Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param percent_complete:
        :type percent_complete: int
        :param scan_type:
        :type scan_type: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param target_end:
        :type target_end: datetime
        :param target_start:
        :type target_start: datetime
        :param test_type:
        :type test_type: int
        :param title:
        :type title: str
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_list_serialize(
            actual_time=actual_time,
            api_scan_configuration=api_scan_configuration,
            branch_tag=branch_tag,
            build_id=build_id,
            commit_hash=commit_hash,
            engagement=engagement,
            engagement__product__tags=engagement__product__tags,
            engagement__product__tags__and=engagement__product__tags__and,
            engagement__tags=engagement__tags,
            engagement__tags__and=engagement__tags__and,
            has_tags=has_tags,
            id=id,
            limit=limit,
            not_engagement__product__tags=not_engagement__product__tags,
            not_engagement__tags=not_engagement__tags,
            not_tag=not_tag,
            not_tags=not_tags,
            notes=notes,
            o=o,
            offset=offset,
            percent_complete=percent_complete,
            scan_type=scan_type,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            target_end=target_end,
            target_start=target_start,
            test_type=test_type,
            title=title,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedTestList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_list_with_http_info(
        self,
        actual_time: Optional[StrictStr] = None,
        api_scan_configuration: Optional[StrictInt] = None,
        branch_tag: Optional[StrictStr] = None,
        build_id: Optional[StrictStr] = None,
        commit_hash: Optional[StrictStr] = None,
        engagement: Optional[StrictInt] = None,
        engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        not_engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        notes: Optional[List[StrictInt]] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        percent_complete: Optional[StrictInt] = None,
        scan_type: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        target_end: Optional[datetime] = None,
        target_start: Optional[datetime] = None,
        test_type: Optional[StrictInt] = None,
        title: Optional[StrictStr] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedTestList]:
        """tests_list


        :param actual_time:
        :type actual_time: str
        :param api_scan_configuration:
        :type api_scan_configuration: int
        :param branch_tag:
        :type branch_tag: str
        :param build_id:
        :type build_id: str
        :param commit_hash:
        :type commit_hash: str
        :param engagement:
        :type engagement: int
        :param engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type engagement__product__tags: List[str]
        :param engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type engagement__product__tags__and: List[str]
        :param engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type engagement__tags: List[str]
        :param engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type engagement__tags__and: List[str]
        :param has_tags: Has tags
        :type has_tags: bool
        :param id:
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param not_engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_engagement__product__tags: List[str]
        :param not_engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_engagement__tags: List[str]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param notes:
        :type notes: List[int]
        :param o: Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param percent_complete:
        :type percent_complete: int
        :param scan_type:
        :type scan_type: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param target_end:
        :type target_end: datetime
        :param target_start:
        :type target_start: datetime
        :param test_type:
        :type test_type: int
        :param title:
        :type title: str
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_list_serialize(
            actual_time=actual_time,
            api_scan_configuration=api_scan_configuration,
            branch_tag=branch_tag,
            build_id=build_id,
            commit_hash=commit_hash,
            engagement=engagement,
            engagement__product__tags=engagement__product__tags,
            engagement__product__tags__and=engagement__product__tags__and,
            engagement__tags=engagement__tags,
            engagement__tags__and=engagement__tags__and,
            has_tags=has_tags,
            id=id,
            limit=limit,
            not_engagement__product__tags=not_engagement__product__tags,
            not_engagement__tags=not_engagement__tags,
            not_tag=not_tag,
            not_tags=not_tags,
            notes=notes,
            o=o,
            offset=offset,
            percent_complete=percent_complete,
            scan_type=scan_type,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            target_end=target_end,
            target_start=target_start,
            test_type=test_type,
            title=title,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedTestList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_list_without_preload_content(
        self,
        actual_time: Optional[StrictStr] = None,
        api_scan_configuration: Optional[StrictInt] = None,
        branch_tag: Optional[StrictStr] = None,
        build_id: Optional[StrictStr] = None,
        commit_hash: Optional[StrictStr] = None,
        engagement: Optional[StrictInt] = None,
        engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        not_engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        notes: Optional[List[StrictInt]] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        percent_complete: Optional[StrictInt] = None,
        scan_type: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        target_end: Optional[datetime] = None,
        target_start: Optional[datetime] = None,
        test_type: Optional[StrictInt] = None,
        title: Optional[StrictStr] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_list


        :param actual_time:
        :type actual_time: str
        :param api_scan_configuration:
        :type api_scan_configuration: int
        :param branch_tag:
        :type branch_tag: str
        :param build_id:
        :type build_id: str
        :param commit_hash:
        :type commit_hash: str
        :param engagement:
        :type engagement: int
        :param engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type engagement__product__tags: List[str]
        :param engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type engagement__product__tags__and: List[str]
        :param engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type engagement__tags: List[str]
        :param engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type engagement__tags__and: List[str]
        :param has_tags: Has tags
        :type has_tags: bool
        :param id:
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param not_engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_engagement__product__tags: List[str]
        :param not_engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_engagement__tags: List[str]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param notes:
        :type notes: List[int]
        :param o: Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param percent_complete:
        :type percent_complete: int
        :param scan_type:
        :type scan_type: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param target_end:
        :type target_end: datetime
        :param target_start:
        :type target_start: datetime
        :param test_type:
        :type test_type: int
        :param title:
        :type title: str
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_list_serialize(
            actual_time=actual_time,
            api_scan_configuration=api_scan_configuration,
            branch_tag=branch_tag,
            build_id=build_id,
            commit_hash=commit_hash,
            engagement=engagement,
            engagement__product__tags=engagement__product__tags,
            engagement__product__tags__and=engagement__product__tags__and,
            engagement__tags=engagement__tags,
            engagement__tags__and=engagement__tags__and,
            has_tags=has_tags,
            id=id,
            limit=limit,
            not_engagement__product__tags=not_engagement__product__tags,
            not_engagement__tags=not_engagement__tags,
            not_tag=not_tag,
            not_tags=not_tags,
            notes=notes,
            o=o,
            offset=offset,
            percent_complete=percent_complete,
            scan_type=scan_type,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            target_end=target_end,
            target_start=target_start,
            test_type=test_type,
            title=title,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedTestList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_list_serialize(
        self,
        actual_time,
        api_scan_configuration,
        branch_tag,
        build_id,
        commit_hash,
        engagement,
        engagement__product__tags,
        engagement__product__tags__and,
        engagement__tags,
        engagement__tags__and,
        has_tags,
        id,
        limit,
        not_engagement__product__tags,
        not_engagement__tags,
        not_tag,
        not_tags,
        notes,
        o,
        offset,
        percent_complete,
        scan_type,
        tag,
        tags,
        tags__and,
        target_end,
        target_start,
        test_type,
        title,
        version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'engagement__product__tags': 'csv',
            'engagement__product__tags__and': 'csv',
            'engagement__tags': 'csv',
            'engagement__tags__and': 'csv',
            'not_engagement__product__tags': 'csv',
            'not_engagement__tags': 'csv',
            'not_tags': 'csv',
            'notes': 'multi',
            'o': 'csv',
            'tags': 'csv',
            'tags__and': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if actual_time is not None:
            _query_params.append(('actual_time', actual_time))

        if api_scan_configuration is not None:
            _query_params.append(('api_scan_configuration', api_scan_configuration))

        if branch_tag is not None:
            _query_params.append(('branch_tag', branch_tag))

        if build_id is not None:
            _query_params.append(('build_id', build_id))

        if commit_hash is not None:
            _query_params.append(('commit_hash', commit_hash))

        if engagement is not None:
            _query_params.append(('engagement', engagement))

        if engagement__product__tags is not None:
            _query_params.append(('engagement__product__tags', engagement__product__tags))

        if engagement__product__tags__and is not None:
            _query_params.append(('engagement__product__tags__and', engagement__product__tags__and))

        if engagement__tags is not None:
            _query_params.append(('engagement__tags', engagement__tags))

        if engagement__tags__and is not None:
            _query_params.append(('engagement__tags__and', engagement__tags__and))

        if has_tags is not None:
            _query_params.append(('has_tags', has_tags))

        if id is not None:
            _query_params.append(('id', id))

        if limit is not None:
            _query_params.append(('limit', limit))

        if not_engagement__product__tags is not None:
            _query_params.append(('not_engagement__product__tags', not_engagement__product__tags))

        if not_engagement__tags is not None:
            _query_params.append(('not_engagement__tags', not_engagement__tags))

        if not_tag is not None:
            _query_params.append(('not_tag', not_tag))

        if not_tags is not None:
            _query_params.append(('not_tags', not_tags))

        if notes is not None:
            _query_params.append(('notes', notes))

        if o is not None:
            _query_params.append(('o', o))

        if offset is not None:
            _query_params.append(('offset', offset))

        if percent_complete is not None:
            _query_params.append(('percent_complete', percent_complete))

        if scan_type is not None:
            _query_params.append(('scan_type', scan_type))

        if tag is not None:
            _query_params.append(('tag', tag))

        if tags is not None:
            _query_params.append(('tags', tags))

        if tags__and is not None:
            _query_params.append(('tags__and', tags__and))

        if target_end is not None:
            if isinstance(target_end, datetime):
                _query_params.append(('target_end', target_end.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('target_end', target_end))

        if target_start is not None:
            if isinstance(target_start, datetime):
                _query_params.append(
                    ('target_start', target_start.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('target_start', target_start))

        if test_type is not None:
            _query_params.append(('test_type', test_type))

        if title is not None:
            _query_params.append(('title', title))

        if version is not None:
            _query_params.append(('version', version))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_list_iterator(
        self,
        actual_time: Optional[StrictStr] = None,
        api_scan_configuration: Optional[StrictInt] = None,
        branch_tag: Optional[StrictStr] = None,
        build_id: Optional[StrictStr] = None,
        commit_hash: Optional[StrictStr] = None,
        engagement: Optional[StrictInt] = None,
        engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Optional[StrictInt] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        not_engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        notes: Optional[List[StrictInt]] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `title` - Title * `-title` - Title (descending) * `version` - Version * `-version` - Version (descending) * `target_start` - Target start * `-target_start` - Target start (descending) * `target_end` - Target end * `-target_end` - Target end (descending) * `test_type` - Test type * `-test_type` - Test type (descending) * `lead` - Lead * `-lead` - Lead (descending) * `branch_tag` - Branch tag * `-branch_tag` - Branch tag (descending) * `build_id` - Build id * `-build_id` - Build id (descending) * `commit_hash` - Commit hash * `-commit_hash` - Commit hash (descending) * `api_scan_configuration` - Api scan configuration * `-api_scan_configuration` - Api scan configuration (descending) * `engagement` - Engagement * `-engagement` - Engagement (descending) * `created` - Created * `-created` - Created (descending) * `updated` - Updated * `-updated` - Updated (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        percent_complete: Optional[StrictInt] = None,
        scan_type: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        target_end: Optional[datetime] = None,
        target_start: Optional[datetime] = None,
        test_type: Optional[StrictInt] = None,
        title: Optional[StrictStr] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[Test, PaginatedTestList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, TestsApi.tests_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def tests_notes_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Note:
        """tests_notes_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_notes_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Note]:
        """tests_notes_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_notes_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_notes_create


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_notes_create_serialize(
        self,
        id,
        add_new_note_option_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_new_note_option_request is not None:
            _body_params = add_new_note_option_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/tests/{id}/notes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_notes_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TestToNotes:
        """tests_notes_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_notes_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TestToNotes]:
        """tests_notes_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_notes_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_notes_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'TestToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_notes_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/{id}/notes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_partial_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        patched_test_request: Optional[PatchedTestRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Test:
        """tests_partial_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param patched_test_request:
        :type patched_test_request: PatchedTestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_partial_update_serialize(
            id=id,
            patched_test_request=patched_test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        patched_test_request: Optional[PatchedTestRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Test]:
        """tests_partial_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param patched_test_request:
        :type patched_test_request: PatchedTestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_partial_update_serialize(
            id=id,
            patched_test_request=patched_test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        patched_test_request: Optional[PatchedTestRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_partial_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param patched_test_request:
        :type patched_test_request: PatchedTestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_partial_update_serialize(
            id=id,
            patched_test_request=patched_test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_partial_update_serialize(
        self,
        id,
        patched_test_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_test_request is not None:
            _body_params = patched_test_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/tests/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Test:
        """tests_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Test]:
        """tests_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_retrieve


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/tests/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def tests_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Test:
        """tests_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_update_serialize(
            id=id,
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def tests_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Test]:
        """tests_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_update_serialize(
            id=id,
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def tests_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this test.')],
        test_request: TestRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tests_update


        :param id: A unique integer value identifying this test. (required)
        :type id: int
        :param test_request: (required)
        :type test_request: TestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tests_update_serialize(
            id=id,
            test_request=test_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Test',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _tests_update_serialize(
        self,
        id,
        test_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if test_request is not None:
            _body_params = test_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/tests/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

# coding: utf-8

"""
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, Generator, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing_extensions import Annotated

from defectdojo_api_generated.api_client import ApiClient, RequestSerialized
from defectdojo_api_generated.api_response import ApiResponse
from defectdojo_api_generated.helpers import IteratorResult, get_all_pages
from defectdojo_api_generated.models.paginated_delete_preview_list import PaginatedDeletePreviewList
from defectdojo_api_generated.models.paginated_product_list import PaginatedProductList
from defectdojo_api_generated.models.patched_product_request import PatchedProductRequest
from defectdojo_api_generated.models.product import Product
from defectdojo_api_generated.models.product_request import ProductRequest
from defectdojo_api_generated.models.report_generate import ReportGenerate
from defectdojo_api_generated.models.report_generate_option_request import ReportGenerateOptionRequest
from defectdojo_api_generated.rest import RESTResponseType

if TYPE_CHECKING:
    """placeholder for IteratorResult types if any"""
    from defectdojo_api_generated.models import DeletePreview, Product


class ProductsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    def products_create(
        self,
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Product:
        """products_create


        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_create_serialize(
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_create_with_http_info(
        self,
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Product]:
        """products_create


        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_create_serialize(
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_create_without_preload_content(
        self,
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_create


        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_create_serialize(
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_create_serialize(
        self,
        product_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if product_request is not None:
            _body_params = product_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/products/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_delete_preview_list(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedDeletePreviewList:
        """products_delete_preview_list


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_delete_preview_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedDeletePreviewList]:
        """products_delete_preview_list


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_delete_preview_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_delete_preview_list


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_delete_preview_list_serialize(
        self,
        id,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            _query_params.append(('limit', limit))

        if offset is not None:
            _query_params.append(('offset', offset))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/products/{id}/delete_preview/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_delete_preview_list_iterator(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[DeletePreview, PaginatedDeletePreviewList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, ProductsApi.products_delete_preview_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def products_destroy(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """products_destroy


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_destroy_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """products_destroy


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_destroy_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_destroy


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_destroy_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/products/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_generate_report_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReportGenerate:
        """products_generate_report_create


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_generate_report_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReportGenerate]:
        """products_generate_report_create


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_generate_report_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_generate_report_create


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_generate_report_create_serialize(
            id=id,
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_generate_report_create_serialize(
        self,
        id,
        report_generate_option_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if report_generate_option_request is not None:
            _body_params = report_generate_option_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/products/{id}/generate_report/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_list(
        self,
        business_criticality: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        description: Optional[StrictStr] = None,
        external_audience: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        internet_accessible: Optional[StrictBool] = None,
        lifecycle: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        name: Optional[StrictStr] = None,
        name_exact: Optional[StrictStr] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        origin: Optional[StrictStr] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        platform: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        prod_numeric_grade: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        product_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        regulations: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        revenue: Optional[Union[StrictFloat, StrictInt]] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        team_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        technical_contact: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        tid: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        updated: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        user_records: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedProductList:
        """products_list


        :param business_criticality:
        :type business_criticality: str
        :param created: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param description:
        :type description: str
        :param external_audience:
        :type external_audience: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param internet_accessible:
        :type internet_accessible: bool
        :param lifecycle:
        :type lifecycle: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param name:
        :type name: str
        :param name_exact:
        :type name_exact: str
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on product
        :type not_tags: List[str]
        :param o: Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param origin:
        :type origin: str
        :param outside_of_sla:
        :type outside_of_sla: float
        :param platform:
        :type platform: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param prod_numeric_grade: Multiple values may be separated by commas.
        :type prod_numeric_grade: List[int]
        :param prod_type: Multiple values may be separated by commas.
        :type prod_type: List[int]
        :param product_manager: Multiple values may be separated by commas.
        :type product_manager: List[int]
        :param regulations: Multiple values may be separated by commas.
        :type regulations: List[int]
        :param revenue:
        :type revenue: float
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param team_manager: Multiple values may be separated by commas.
        :type team_manager: List[int]
        :param technical_contact: Multiple values may be separated by commas.
        :type technical_contact: List[int]
        :param tid: Multiple values may be separated by commas.
        :type tid: List[int]
        :param updated: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type updated: datetime
        :param user_records: Multiple values may be separated by commas.
        :type user_records: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_list_serialize(
            business_criticality=business_criticality,
            created=created,
            description=description,
            external_audience=external_audience,
            has_tags=has_tags,
            id=id,
            internet_accessible=internet_accessible,
            lifecycle=lifecycle,
            limit=limit,
            name=name,
            name_exact=name_exact,
            not_tag=not_tag,
            not_tags=not_tags,
            o=o,
            offset=offset,
            origin=origin,
            outside_of_sla=outside_of_sla,
            platform=platform,
            prefetch=prefetch,
            prod_numeric_grade=prod_numeric_grade,
            prod_type=prod_type,
            product_manager=product_manager,
            regulations=regulations,
            revenue=revenue,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            team_manager=team_manager,
            technical_contact=technical_contact,
            tid=tid,
            updated=updated,
            user_records=user_records,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedProductList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_list_with_http_info(
        self,
        business_criticality: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        description: Optional[StrictStr] = None,
        external_audience: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        internet_accessible: Optional[StrictBool] = None,
        lifecycle: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        name: Optional[StrictStr] = None,
        name_exact: Optional[StrictStr] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        origin: Optional[StrictStr] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        platform: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        prod_numeric_grade: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        product_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        regulations: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        revenue: Optional[Union[StrictFloat, StrictInt]] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        team_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        technical_contact: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        tid: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        updated: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        user_records: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedProductList]:
        """products_list


        :param business_criticality:
        :type business_criticality: str
        :param created: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param description:
        :type description: str
        :param external_audience:
        :type external_audience: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param internet_accessible:
        :type internet_accessible: bool
        :param lifecycle:
        :type lifecycle: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param name:
        :type name: str
        :param name_exact:
        :type name_exact: str
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on product
        :type not_tags: List[str]
        :param o: Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param origin:
        :type origin: str
        :param outside_of_sla:
        :type outside_of_sla: float
        :param platform:
        :type platform: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param prod_numeric_grade: Multiple values may be separated by commas.
        :type prod_numeric_grade: List[int]
        :param prod_type: Multiple values may be separated by commas.
        :type prod_type: List[int]
        :param product_manager: Multiple values may be separated by commas.
        :type product_manager: List[int]
        :param regulations: Multiple values may be separated by commas.
        :type regulations: List[int]
        :param revenue:
        :type revenue: float
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param team_manager: Multiple values may be separated by commas.
        :type team_manager: List[int]
        :param technical_contact: Multiple values may be separated by commas.
        :type technical_contact: List[int]
        :param tid: Multiple values may be separated by commas.
        :type tid: List[int]
        :param updated: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type updated: datetime
        :param user_records: Multiple values may be separated by commas.
        :type user_records: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_list_serialize(
            business_criticality=business_criticality,
            created=created,
            description=description,
            external_audience=external_audience,
            has_tags=has_tags,
            id=id,
            internet_accessible=internet_accessible,
            lifecycle=lifecycle,
            limit=limit,
            name=name,
            name_exact=name_exact,
            not_tag=not_tag,
            not_tags=not_tags,
            o=o,
            offset=offset,
            origin=origin,
            outside_of_sla=outside_of_sla,
            platform=platform,
            prefetch=prefetch,
            prod_numeric_grade=prod_numeric_grade,
            prod_type=prod_type,
            product_manager=product_manager,
            regulations=regulations,
            revenue=revenue,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            team_manager=team_manager,
            technical_contact=technical_contact,
            tid=tid,
            updated=updated,
            user_records=user_records,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedProductList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_list_without_preload_content(
        self,
        business_criticality: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        description: Optional[StrictStr] = None,
        external_audience: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        internet_accessible: Optional[StrictBool] = None,
        lifecycle: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        name: Optional[StrictStr] = None,
        name_exact: Optional[StrictStr] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        origin: Optional[StrictStr] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        platform: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        prod_numeric_grade: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        product_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        regulations: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        revenue: Optional[Union[StrictFloat, StrictInt]] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        team_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        technical_contact: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        tid: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        updated: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        user_records: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_list


        :param business_criticality:
        :type business_criticality: str
        :param created: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param description:
        :type description: str
        :param external_audience:
        :type external_audience: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param internet_accessible:
        :type internet_accessible: bool
        :param lifecycle:
        :type lifecycle: str
        :param limit: Number of results to return per page.
        :type limit: int
        :param name:
        :type name: str
        :param name_exact:
        :type name_exact: str
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on product
        :type not_tags: List[str]
        :param o: Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param origin:
        :type origin: str
        :param outside_of_sla:
        :type outside_of_sla: float
        :param platform:
        :type platform: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param prod_numeric_grade: Multiple values may be separated by commas.
        :type prod_numeric_grade: List[int]
        :param prod_type: Multiple values may be separated by commas.
        :type prod_type: List[int]
        :param product_manager: Multiple values may be separated by commas.
        :type product_manager: List[int]
        :param regulations: Multiple values may be separated by commas.
        :type regulations: List[int]
        :param revenue:
        :type revenue: float
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param team_manager: Multiple values may be separated by commas.
        :type team_manager: List[int]
        :param technical_contact: Multiple values may be separated by commas.
        :type technical_contact: List[int]
        :param tid: Multiple values may be separated by commas.
        :type tid: List[int]
        :param updated: * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type updated: datetime
        :param user_records: Multiple values may be separated by commas.
        :type user_records: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_list_serialize(
            business_criticality=business_criticality,
            created=created,
            description=description,
            external_audience=external_audience,
            has_tags=has_tags,
            id=id,
            internet_accessible=internet_accessible,
            lifecycle=lifecycle,
            limit=limit,
            name=name,
            name_exact=name_exact,
            not_tag=not_tag,
            not_tags=not_tags,
            o=o,
            offset=offset,
            origin=origin,
            outside_of_sla=outside_of_sla,
            platform=platform,
            prefetch=prefetch,
            prod_numeric_grade=prod_numeric_grade,
            prod_type=prod_type,
            product_manager=product_manager,
            regulations=regulations,
            revenue=revenue,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            team_manager=team_manager,
            technical_contact=technical_contact,
            tid=tid,
            updated=updated,
            user_records=user_records,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedProductList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_list_serialize(
        self,
        business_criticality,
        created,
        description,
        external_audience,
        has_tags,
        id,
        internet_accessible,
        lifecycle,
        limit,
        name,
        name_exact,
        not_tag,
        not_tags,
        o,
        offset,
        origin,
        outside_of_sla,
        platform,
        prefetch,
        prod_numeric_grade,
        prod_type,
        product_manager,
        regulations,
        revenue,
        tag,
        tags,
        tags__and,
        team_manager,
        technical_contact,
        tid,
        updated,
        user_records,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'id': 'csv',
            'not_tags': 'csv',
            'o': 'csv',
            'prefetch': 'multi',
            'prod_numeric_grade': 'csv',
            'prod_type': 'csv',
            'product_manager': 'csv',
            'regulations': 'csv',
            'tags': 'csv',
            'tags__and': 'csv',
            'team_manager': 'csv',
            'technical_contact': 'csv',
            'tid': 'csv',
            'user_records': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if business_criticality is not None:
            _query_params.append(('business_criticality', business_criticality))

        if created is not None:
            if isinstance(created, datetime):
                _query_params.append(('created', created.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created', created))

        if description is not None:
            _query_params.append(('description', description))

        if external_audience is not None:
            _query_params.append(('external_audience', external_audience))

        if has_tags is not None:
            _query_params.append(('has_tags', has_tags))

        if id is not None:
            _query_params.append(('id', id))

        if internet_accessible is not None:
            _query_params.append(('internet_accessible', internet_accessible))

        if lifecycle is not None:
            _query_params.append(('lifecycle', lifecycle))

        if limit is not None:
            _query_params.append(('limit', limit))

        if name is not None:
            _query_params.append(('name', name))

        if name_exact is not None:
            _query_params.append(('name_exact', name_exact))

        if not_tag is not None:
            _query_params.append(('not_tag', not_tag))

        if not_tags is not None:
            _query_params.append(('not_tags', not_tags))

        if o is not None:
            _query_params.append(('o', o))

        if offset is not None:
            _query_params.append(('offset', offset))

        if origin is not None:
            _query_params.append(('origin', origin))

        if outside_of_sla is not None:
            _query_params.append(('outside_of_sla', outside_of_sla))

        if platform is not None:
            _query_params.append(('platform', platform))

        if prefetch is not None:
            _query_params.append(('prefetch', prefetch))

        if prod_numeric_grade is not None:
            _query_params.append(('prod_numeric_grade', prod_numeric_grade))

        if prod_type is not None:
            _query_params.append(('prod_type', prod_type))

        if product_manager is not None:
            _query_params.append(('product_manager', product_manager))

        if regulations is not None:
            _query_params.append(('regulations', regulations))

        if revenue is not None:
            _query_params.append(('revenue', revenue))

        if tag is not None:
            _query_params.append(('tag', tag))

        if tags is not None:
            _query_params.append(('tags', tags))

        if tags__and is not None:
            _query_params.append(('tags__and', tags__and))

        if team_manager is not None:
            _query_params.append(('team_manager', team_manager))

        if technical_contact is not None:
            _query_params.append(('technical_contact', technical_contact))

        if tid is not None:
            _query_params.append(('tid', tid))

        if updated is not None:
            if isinstance(updated, datetime):
                _query_params.append(('updated', updated.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('updated', updated))

        if user_records is not None:
            _query_params.append(('user_records', user_records))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/products/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_list_iterator(
        self,
        business_criticality: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        description: Optional[StrictStr] = None,
        external_audience: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        internet_accessible: Optional[StrictBool] = None,
        lifecycle: Optional[StrictStr] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        name: Optional[StrictStr] = None,
        name_exact: Optional[StrictStr] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `id` - Id * `-id` - Id (descending) * `tid` - Tid * `-tid` - Tid (descending) * `name` - Name * `-name` - Name (descending) * `created` - Created * `-created` - Created (descending) * `prod_numeric_grade` - Prod numeric grade * `-prod_numeric_grade` - Prod numeric grade (descending) * `business_criticality` - Business criticality * `-business_criticality` - Business criticality (descending) * `platform` - Platform * `-platform` - Platform (descending) * `lifecycle` - Lifecycle * `-lifecycle` - Lifecycle (descending) * `origin` - Origin * `-origin` - Origin (descending) * `revenue` - Revenue * `-revenue` - Revenue (descending) * `external_audience` - External audience * `-external_audience` - External audience (descending) * `internet_accessible` - Internet accessible * `-internet_accessible` - Internet accessible (descending) * `product_manager` - Product manager * `-product_manager` - Product manager (descending) * `product_manager__first_name` - Product manager  first name * `-product_manager__first_name` - Product manager  first name (descending) * `product_manager__last_name` - Product manager  last name * `-product_manager__last_name` - Product manager  last name (descending) * `technical_contact` - Technical contact * `-technical_contact` - Technical contact (descending) * `technical_contact__first_name` - Technical contact  first name * `-technical_contact__first_name` - Technical contact  first name (descending) * `technical_contact__last_name` - Technical contact  last name * `-technical_contact__last_name` - Technical contact  last name (descending) * `team_manager` - Team manager * `-team_manager` - Team manager (descending) * `team_manager__first_name` - Team manager  first name * `-team_manager__first_name` - Team manager  first name (descending) * `team_manager__last_name` - Team manager  last name * `-team_manager__last_name` - Team manager  last name (descending) * `prod_type` - Prod type * `-prod_type` - Prod type (descending) * `prod_type__name` - Prod type  name * `-prod_type__name` - Prod type  name (descending) * `updated` - Updated * `-updated` - Updated (descending) * `user_records` - User records * `-user_records` - User records (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        origin: Optional[StrictStr] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        platform: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        prod_numeric_grade: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        product_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        regulations: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        revenue: Optional[Union[StrictFloat, StrictInt]] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        team_manager: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        technical_contact: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        tid: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        updated: Annotated[
            Optional[datetime],
            Field(
                description='* `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        user_records: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[Product, PaginatedProductList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, ProductsApi.products_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def products_partial_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        patched_product_request: Optional[PatchedProductRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Product:
        """products_partial_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param patched_product_request:
        :type patched_product_request: PatchedProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_partial_update_serialize(
            id=id,
            patched_product_request=patched_product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        patched_product_request: Optional[PatchedProductRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Product]:
        """products_partial_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param patched_product_request:
        :type patched_product_request: PatchedProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_partial_update_serialize(
            id=id,
            patched_product_request=patched_product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        patched_product_request: Optional[PatchedProductRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_partial_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param patched_product_request:
        :type patched_product_request: PatchedProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_partial_update_serialize(
            id=id,
            patched_product_request=patched_product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_partial_update_serialize(
        self,
        id,
        patched_product_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_product_request is not None:
            _body_params = patched_product_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/products/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Product:
        """products_retrieve


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Product]:
        """products_retrieve


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_retrieve


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_retrieve_serialize(
        self,
        id,
        prefetch,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'prefetch': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if prefetch is not None:
            _query_params.append(('prefetch', prefetch))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/products/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def products_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Product:
        """products_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_update_serialize(
            id=id,
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def products_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Product]:
        """products_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_update_serialize(
            id=id,
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def products_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this product.')],
        product_request: ProductRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """products_update


        :param id: A unique integer value identifying this product. (required)
        :type id: int
        :param product_request: (required)
        :type product_request: ProductRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._products_update_serialize(
            id=id,
            product_request=product_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Product',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _products_update_serialize(
        self,
        id,
        product_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if product_request is not None:
            _body_params = product_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/products/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

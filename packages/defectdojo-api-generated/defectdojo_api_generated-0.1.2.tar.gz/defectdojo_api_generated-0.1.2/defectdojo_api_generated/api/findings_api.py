# coding: utf-8

"""
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from datetime import date, datetime
from typing import TYPE_CHECKING, Any, Dict, Generator, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr
from typing_extensions import Annotated

from defectdojo_api_generated.api_client import ApiClient, RequestSerialized
from defectdojo_api_generated.api_response import ApiResponse
from defectdojo_api_generated.helpers import IteratorResult, get_all_pages
from defectdojo_api_generated.models.accepted_risk_request import AcceptedRiskRequest
from defectdojo_api_generated.models.add_new_note_option_request import AddNewNoteOptionRequest
from defectdojo_api_generated.models.burp_raw_request_response import BurpRawRequestResponse
from defectdojo_api_generated.models.burp_raw_request_response_request import BurpRawRequestResponseRequest
from defectdojo_api_generated.models.file import File
from defectdojo_api_generated.models.finding import Finding
from defectdojo_api_generated.models.finding_close import FindingClose
from defectdojo_api_generated.models.finding_close_request import FindingCloseRequest
from defectdojo_api_generated.models.finding_create import FindingCreate
from defectdojo_api_generated.models.finding_create_request import FindingCreateRequest
from defectdojo_api_generated.models.finding_meta import FindingMeta
from defectdojo_api_generated.models.finding_meta_request import FindingMetaRequest
from defectdojo_api_generated.models.finding_request import FindingRequest
from defectdojo_api_generated.models.finding_to_files import FindingToFiles
from defectdojo_api_generated.models.finding_to_notes import FindingToNotes
from defectdojo_api_generated.models.note import Note
from defectdojo_api_generated.models.paginated_delete_preview_list import PaginatedDeletePreviewList
from defectdojo_api_generated.models.paginated_finding_list import PaginatedFindingList
from defectdojo_api_generated.models.paginated_risk_acceptance_list import PaginatedRiskAcceptanceList
from defectdojo_api_generated.models.patched_finding_note_request import PatchedFindingNoteRequest
from defectdojo_api_generated.models.patched_finding_request import PatchedFindingRequest
from defectdojo_api_generated.models.patched_tag_request import PatchedTagRequest
from defectdojo_api_generated.models.raw_file import RawFile
from defectdojo_api_generated.models.report_generate import ReportGenerate
from defectdojo_api_generated.models.report_generate_option_request import ReportGenerateOptionRequest
from defectdojo_api_generated.models.tag import Tag
from defectdojo_api_generated.models.tag_request import TagRequest
from defectdojo_api_generated.rest import RESTResponseType

if TYPE_CHECKING:
    """placeholder for IteratorResult types if any"""
    from defectdojo_api_generated.models import DeletePreview, Finding


class FindingsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    def findings_accept_risks_create(
        self,
        accepted_risk_request: List[AcceptedRiskRequest],
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedRiskAcceptanceList:
        """findings_accept_risks_create


        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_accept_risks_create_serialize(
            accepted_risk_request=accepted_risk_request,
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'PaginatedRiskAcceptanceList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_accept_risks_create_with_http_info(
        self,
        accepted_risk_request: List[AcceptedRiskRequest],
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedRiskAcceptanceList]:
        """findings_accept_risks_create


        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_accept_risks_create_serialize(
            accepted_risk_request=accepted_risk_request,
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'PaginatedRiskAcceptanceList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_accept_risks_create_without_preload_content(
        self,
        accepted_risk_request: List[AcceptedRiskRequest],
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_accept_risks_create


        :param accepted_risk_request: (required)
        :type accepted_risk_request: List[AcceptedRiskRequest]
        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_accept_risks_create_serialize(
            accepted_risk_request=accepted_risk_request,
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'PaginatedRiskAcceptanceList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_accept_risks_create_serialize(
        self,
        accepted_risk_request,
        active,
        component_name,
        component_version,
        created,
        cvssv3,
        cvssv3_score,
        cwe,
        var_date,
        defect_review_requested_by,
        description,
        discovered_after,
        discovered_before,
        discovered_on,
        duplicate,
        duplicate_finding,
        dynamic_finding,
        effort_for_fixing,
        endpoints,
        epss_percentile_max,
        epss_percentile_min,
        epss_score_max,
        epss_score_min,
        false_p,
        file_path,
        finding_group,
        found_by,
        has_jira,
        has_tags,
        hash_code,
        id,
        impact,
        inherited_tags,
        is_mitigated,
        jira_change,
        jira_creation,
        last_reviewed,
        last_reviewed_by,
        last_status_update,
        limit,
        mitigated,
        mitigated_after,
        mitigated_before,
        mitigated_by,
        mitigated_on,
        mitigation,
        nb_occurences,
        not_tag,
        not_tags,
        not_test__engagement__product__tags,
        not_test__engagement__tags,
        not_test__tags,
        numerical_severity,
        o,
        offset,
        out_of_scope,
        outside_of_sla,
        param,
        payload,
        planned_remediation_date,
        planned_remediation_version,
        product_lifecycle,
        product_name,
        product_name_contains,
        publish_date,
        references,
        reporter,
        review_requested_by,
        reviewers,
        risk_acceptance,
        risk_accepted,
        sast_sink_object,
        sast_source_file_path,
        sast_source_line,
        sast_source_object,
        scanner_confidence,
        service,
        severity,
        severity_justification,
        sla_expiration_date,
        sla_start_date,
        sonarqube_issue,
        static_finding,
        steps_to_reproduce,
        tag,
        tags,
        tags__and,
        test,
        test__engagement,
        test__engagement__product,
        test__engagement__product__prod_type,
        test__engagement__product__tags,
        test__engagement__product__tags__and,
        test__engagement__tags,
        test__engagement__tags__and,
        test__tags,
        test__tags__and,
        test__test_type,
        title,
        under_defect_review,
        under_review,
        unique_id_from_tool,
        verified,
        vuln_id_from_tool,
        vulnerability_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'AcceptedRiskRequest': '',
            'cwe': 'csv',
            'defect_review_requested_by': 'csv',
            'endpoints': 'csv',
            'finding_group': 'csv',
            'found_by': 'csv',
            'id': 'csv',
            'inherited_tags': 'multi',
            'last_reviewed_by': 'csv',
            'mitigated_by': 'csv',
            'nb_occurences': 'csv',
            'not_tags': 'csv',
            'not_test__engagement__product__tags': 'csv',
            'not_test__engagement__tags': 'csv',
            'not_test__tags': 'csv',
            'o': 'csv',
            'reporter': 'csv',
            'review_requested_by': 'csv',
            'reviewers': 'csv',
            'sast_source_line': 'csv',
            'scanner_confidence': 'csv',
            'sonarqube_issue': 'csv',
            'tags': 'csv',
            'tags__and': 'csv',
            'test__engagement': 'csv',
            'test__engagement__product': 'csv',
            'test__engagement__product__prod_type': 'csv',
            'test__engagement__product__tags': 'csv',
            'test__engagement__product__tags__and': 'csv',
            'test__engagement__tags': 'csv',
            'test__engagement__tags__and': 'csv',
            'test__tags': 'csv',
            'test__tags__and': 'csv',
            'test__test_type': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if active is not None:
            _query_params.append(('active', active))

        if component_name is not None:
            _query_params.append(('component_name', component_name))

        if component_version is not None:
            _query_params.append(('component_version', component_version))

        if created is not None:
            if isinstance(created, datetime):
                _query_params.append(('created', created.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created', created))

        if cvssv3 is not None:
            _query_params.append(('cvssv3', cvssv3))

        if cvssv3_score is not None:
            _query_params.append(('cvssv3_score', cvssv3_score))

        if cwe is not None:
            _query_params.append(('cwe', cwe))

        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(('date', var_date.strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('date', var_date))

        if defect_review_requested_by is not None:
            _query_params.append(('defect_review_requested_by', defect_review_requested_by))

        if description is not None:
            _query_params.append(('description', description))

        if discovered_after is not None:
            if isinstance(discovered_after, date):
                _query_params.append(
                    ('discovered_after', discovered_after.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_after', discovered_after))

        if discovered_before is not None:
            if isinstance(discovered_before, date):
                _query_params.append(
                    ('discovered_before', discovered_before.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_before', discovered_before))

        if discovered_on is not None:
            if isinstance(discovered_on, date):
                _query_params.append(
                    ('discovered_on', discovered_on.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_on', discovered_on))

        if duplicate is not None:
            _query_params.append(('duplicate', duplicate))

        if duplicate_finding is not None:
            _query_params.append(('duplicate_finding', duplicate_finding))

        if dynamic_finding is not None:
            _query_params.append(('dynamic_finding', dynamic_finding))

        if effort_for_fixing is not None:
            _query_params.append(('effort_for_fixing', effort_for_fixing))

        if endpoints is not None:
            _query_params.append(('endpoints', endpoints))

        if epss_percentile_max is not None:
            _query_params.append(('epss_percentile_max', epss_percentile_max))

        if epss_percentile_min is not None:
            _query_params.append(('epss_percentile_min', epss_percentile_min))

        if epss_score_max is not None:
            _query_params.append(('epss_score_max', epss_score_max))

        if epss_score_min is not None:
            _query_params.append(('epss_score_min', epss_score_min))

        if false_p is not None:
            _query_params.append(('false_p', false_p))

        if file_path is not None:
            _query_params.append(('file_path', file_path))

        if finding_group is not None:
            _query_params.append(('finding_group', finding_group))

        if found_by is not None:
            _query_params.append(('found_by', found_by))

        if has_jira is not None:
            _query_params.append(('has_jira', has_jira))

        if has_tags is not None:
            _query_params.append(('has_tags', has_tags))

        if hash_code is not None:
            _query_params.append(('hash_code', hash_code))

        if id is not None:
            _query_params.append(('id', id))

        if impact is not None:
            _query_params.append(('impact', impact))

        if inherited_tags is not None:
            _query_params.append(('inherited_tags', inherited_tags))

        if is_mitigated is not None:
            _query_params.append(('is_mitigated', is_mitigated))

        if jira_change is not None:
            if isinstance(jira_change, datetime):
                _query_params.append(
                    ('jira_change', jira_change.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('jira_change', jira_change))

        if jira_creation is not None:
            if isinstance(jira_creation, datetime):
                _query_params.append(
                    ('jira_creation', jira_creation.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('jira_creation', jira_creation))

        if last_reviewed is not None:
            if isinstance(last_reviewed, datetime):
                _query_params.append(
                    ('last_reviewed', last_reviewed.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('last_reviewed', last_reviewed))

        if last_reviewed_by is not None:
            _query_params.append(('last_reviewed_by', last_reviewed_by))

        if last_status_update is not None:
            if isinstance(last_status_update, datetime):
                _query_params.append(
                    ('last_status_update', last_status_update.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('last_status_update', last_status_update))

        if limit is not None:
            _query_params.append(('limit', limit))

        if mitigated is not None:
            if isinstance(mitigated, datetime):
                _query_params.append(('mitigated', mitigated.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('mitigated', mitigated))

        if mitigated_after is not None:
            if isinstance(mitigated_after, datetime):
                _query_params.append(
                    ('mitigated_after', mitigated_after.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_after', mitigated_after))

        if mitigated_before is not None:
            if isinstance(mitigated_before, datetime):
                _query_params.append(
                    ('mitigated_before', mitigated_before.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_before', mitigated_before))

        if mitigated_by is not None:
            _query_params.append(('mitigated_by', mitigated_by))

        if mitigated_on is not None:
            if isinstance(mitigated_on, datetime):
                _query_params.append(
                    ('mitigated_on', mitigated_on.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_on', mitigated_on))

        if mitigation is not None:
            _query_params.append(('mitigation', mitigation))

        if nb_occurences is not None:
            _query_params.append(('nb_occurences', nb_occurences))

        if not_tag is not None:
            _query_params.append(('not_tag', not_tag))

        if not_tags is not None:
            _query_params.append(('not_tags', not_tags))

        if not_test__engagement__product__tags is not None:
            _query_params.append(('not_test__engagement__product__tags', not_test__engagement__product__tags))

        if not_test__engagement__tags is not None:
            _query_params.append(('not_test__engagement__tags', not_test__engagement__tags))

        if not_test__tags is not None:
            _query_params.append(('not_test__tags', not_test__tags))

        if numerical_severity is not None:
            _query_params.append(('numerical_severity', numerical_severity))

        if o is not None:
            _query_params.append(('o', o))

        if offset is not None:
            _query_params.append(('offset', offset))

        if out_of_scope is not None:
            _query_params.append(('out_of_scope', out_of_scope))

        if outside_of_sla is not None:
            _query_params.append(('outside_of_sla', outside_of_sla))

        if param is not None:
            _query_params.append(('param', param))

        if payload is not None:
            _query_params.append(('payload', payload))

        if planned_remediation_date is not None:
            if isinstance(planned_remediation_date, date):
                _query_params.append(
                    (
                        'planned_remediation_date',
                        planned_remediation_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(('planned_remediation_date', planned_remediation_date))

        if planned_remediation_version is not None:
            _query_params.append(('planned_remediation_version', planned_remediation_version))

        if product_lifecycle is not None:
            _query_params.append(('product_lifecycle', product_lifecycle))

        if product_name is not None:
            _query_params.append(('product_name', product_name))

        if product_name_contains is not None:
            _query_params.append(('product_name_contains', product_name_contains))

        if publish_date is not None:
            if isinstance(publish_date, date):
                _query_params.append(('publish_date', publish_date.strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publish_date', publish_date))

        if references is not None:
            _query_params.append(('references', references))

        if reporter is not None:
            _query_params.append(('reporter', reporter))

        if review_requested_by is not None:
            _query_params.append(('review_requested_by', review_requested_by))

        if reviewers is not None:
            _query_params.append(('reviewers', reviewers))

        if risk_acceptance is not None:
            _query_params.append(('risk_acceptance', risk_acceptance))

        if risk_accepted is not None:
            _query_params.append(('risk_accepted', risk_accepted))

        if sast_sink_object is not None:
            _query_params.append(('sast_sink_object', sast_sink_object))

        if sast_source_file_path is not None:
            _query_params.append(('sast_source_file_path', sast_source_file_path))

        if sast_source_line is not None:
            _query_params.append(('sast_source_line', sast_source_line))

        if sast_source_object is not None:
            _query_params.append(('sast_source_object', sast_source_object))

        if scanner_confidence is not None:
            _query_params.append(('scanner_confidence', scanner_confidence))

        if service is not None:
            _query_params.append(('service', service))

        if severity is not None:
            _query_params.append(('severity', severity))

        if severity_justification is not None:
            _query_params.append(('severity_justification', severity_justification))

        if sla_expiration_date is not None:
            if isinstance(sla_expiration_date, date):
                _query_params.append(
                    ('sla_expiration_date', sla_expiration_date.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('sla_expiration_date', sla_expiration_date))

        if sla_start_date is not None:
            if isinstance(sla_start_date, date):
                _query_params.append(
                    ('sla_start_date', sla_start_date.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('sla_start_date', sla_start_date))

        if sonarqube_issue is not None:
            _query_params.append(('sonarqube_issue', sonarqube_issue))

        if static_finding is not None:
            _query_params.append(('static_finding', static_finding))

        if steps_to_reproduce is not None:
            _query_params.append(('steps_to_reproduce', steps_to_reproduce))

        if tag is not None:
            _query_params.append(('tag', tag))

        if tags is not None:
            _query_params.append(('tags', tags))

        if tags__and is not None:
            _query_params.append(('tags__and', tags__and))

        if test is not None:
            _query_params.append(('test', test))

        if test__engagement is not None:
            _query_params.append(('test__engagement', test__engagement))

        if test__engagement__product is not None:
            _query_params.append(('test__engagement__product', test__engagement__product))

        if test__engagement__product__prod_type is not None:
            _query_params.append(('test__engagement__product__prod_type', test__engagement__product__prod_type))

        if test__engagement__product__tags is not None:
            _query_params.append(('test__engagement__product__tags', test__engagement__product__tags))

        if test__engagement__product__tags__and is not None:
            _query_params.append(('test__engagement__product__tags__and', test__engagement__product__tags__and))

        if test__engagement__tags is not None:
            _query_params.append(('test__engagement__tags', test__engagement__tags))

        if test__engagement__tags__and is not None:
            _query_params.append(('test__engagement__tags__and', test__engagement__tags__and))

        if test__tags is not None:
            _query_params.append(('test__tags', test__tags))

        if test__tags__and is not None:
            _query_params.append(('test__tags__and', test__tags__and))

        if test__test_type is not None:
            _query_params.append(('test__test_type', test__test_type))

        if title is not None:
            _query_params.append(('title', title))

        if under_defect_review is not None:
            _query_params.append(('under_defect_review', under_defect_review))

        if under_review is not None:
            _query_params.append(('under_review', under_review))

        if unique_id_from_tool is not None:
            _query_params.append(('unique_id_from_tool', unique_id_from_tool))

        if verified is not None:
            _query_params.append(('verified', verified))

        if vuln_id_from_tool is not None:
            _query_params.append(('vuln_id_from_tool', vuln_id_from_tool))

        if vulnerability_id is not None:
            _query_params.append(('vulnerability_id', vulnerability_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if accepted_risk_request is not None:
            _body_params = accepted_risk_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/accept_risks/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_close_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_close_request: Optional[FindingCloseRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingClose:
        """findings_close_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_close_request:
        :type finding_close_request: FindingCloseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_close_create_serialize(
            id=id,
            finding_close_request=finding_close_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingClose',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_close_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_close_request: Optional[FindingCloseRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingClose]:
        """findings_close_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_close_request:
        :type finding_close_request: FindingCloseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_close_create_serialize(
            id=id,
            finding_close_request=finding_close_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingClose',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_close_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_close_request: Optional[FindingCloseRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_close_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_close_request:
        :type finding_close_request: FindingCloseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_close_create_serialize(
            id=id,
            finding_close_request=finding_close_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingClose',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_close_create_serialize(
        self,
        id,
        finding_close_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if finding_close_request is not None:
            _body_params = finding_close_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/close/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_create(
        self,
        finding_create_request: FindingCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingCreate:
        """findings_create


        :param finding_create_request: (required)
        :type finding_create_request: FindingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_create_serialize(
            finding_create_request=finding_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'FindingCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_create_with_http_info(
        self,
        finding_create_request: FindingCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingCreate]:
        """findings_create


        :param finding_create_request: (required)
        :type finding_create_request: FindingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_create_serialize(
            finding_create_request=finding_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'FindingCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_create_without_preload_content(
        self,
        finding_create_request: FindingCreateRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_create


        :param finding_create_request: (required)
        :type finding_create_request: FindingCreateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_create_serialize(
            finding_create_request=finding_create_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'FindingCreate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_create_serialize(
        self,
        finding_create_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if finding_create_request is not None:
            _body_params = finding_create_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_delete_preview_list(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedDeletePreviewList:
        """findings_delete_preview_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_delete_preview_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedDeletePreviewList]:
        """findings_delete_preview_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_delete_preview_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_delete_preview_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param limit: Number of results to return per page.
        :type limit: int
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_delete_preview_list_serialize(
            id=id,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedDeletePreviewList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_delete_preview_list_serialize(
        self,
        id,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            _query_params.append(('limit', limit))

        if offset is not None:
            _query_params.append(('offset', offset))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/delete_preview/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_delete_preview_list_iterator(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[DeletePreview, PaginatedDeletePreviewList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, FindingsApi.findings_delete_preview_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def findings_destroy(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_destroy_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_destroy_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_destroy_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_destroy_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/findings/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_duplicate_list(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Finding]:
        """findings_duplicate_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[Finding]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_duplicate_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Finding]]:
        """findings_duplicate_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[Finding]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_duplicate_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_duplicate_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[Finding]',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_duplicate_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/duplicate/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_duplicate_reset_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_duplicate_reset_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_reset_create_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_duplicate_reset_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_duplicate_reset_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_reset_create_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_duplicate_reset_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_duplicate_reset_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_duplicate_reset_create_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_duplicate_reset_create_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/duplicate/reset/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_files_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> File:
        """findings_files_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_files_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[File]:
        """findings_files_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_files_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        title: Annotated[str, Field(min_length=1, strict=True, max_length=100)],
        file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_files_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param title: (required)
        :type title: str
        :param file: (required)
        :type file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_create_serialize(
            id=id,
            title=title,
            file=file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'File',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_files_create_serialize(
        self,
        id,
        title,
        file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if title is not None:
            _form_params.append(('title', title))
        if file is not None:
            _files['file'] = file
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(['multipart/form-data'])
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/files/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_files_download_retrieve(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RawFile:
        """findings_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_files_download_retrieve_with_http_info(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RawFile]:
        """findings_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_files_download_retrieve_without_preload_content(
        self,
        file_id: Annotated[str, Field(strict=True)],
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_files_download_retrieve


        :param file_id: (required)
        :type file_id: str
        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_download_retrieve_serialize(
            file_id=file_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'RawFile',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_files_download_retrieve_serialize(
        self,
        file_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['file_id'] = file_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/files/download/{file_id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_files_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingToFiles:
        """findings_files_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_files_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingToFiles]:
        """findings_files_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_files_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_files_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_files_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToFiles',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_files_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/files/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_generate_report_create(
        self,
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReportGenerate:
        """findings_generate_report_create


        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_generate_report_create_serialize(
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_generate_report_create_with_http_info(
        self,
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReportGenerate]:
        """findings_generate_report_create


        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_generate_report_create_serialize(
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_generate_report_create_without_preload_content(
        self,
        report_generate_option_request: Optional[ReportGenerateOptionRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_generate_report_create


        :param report_generate_option_request:
        :type report_generate_option_request: ReportGenerateOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_generate_report_create_serialize(
            report_generate_option_request=report_generate_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'ReportGenerate',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_generate_report_create_serialize(
        self,
        report_generate_option_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if report_generate_option_request is not None:
            _body_params = report_generate_option_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/generate_report/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_list(
        self,
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedFindingList:
        """findings_list


        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_list_serialize(
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            prefetch=prefetch,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            related_fields=related_fields,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedFindingList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_list_with_http_info(
        self,
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedFindingList]:
        """findings_list


        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_list_serialize(
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            prefetch=prefetch,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            related_fields=related_fields,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedFindingList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_list_without_preload_content(
        self,
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_list


        :param active:
        :type active: bool
        :param component_name:
        :type component_name: str
        :param component_version:
        :type component_version: str
        :param created: The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type created: datetime
        :param cvssv3:
        :type cvssv3: str
        :param cvssv3_score:
        :type cvssv3_score: float
        :param cwe: Multiple values may be separated by commas.
        :type cwe: List[int]
        :param var_date: The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type var_date: date
        :param defect_review_requested_by: Multiple values may be separated by commas.
        :type defect_review_requested_by: List[int]
        :param description:
        :type description: str
        :param discovered_after:
        :type discovered_after: date
        :param discovered_before:
        :type discovered_before: date
        :param discovered_on:
        :type discovered_on: date
        :param duplicate:
        :type duplicate: bool
        :param duplicate_finding:
        :type duplicate_finding: int
        :param dynamic_finding:
        :type dynamic_finding: bool
        :param effort_for_fixing:
        :type effort_for_fixing: str
        :param endpoints: Multiple values may be separated by commas.
        :type endpoints: List[int]
        :param epss_percentile_max: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_max: float
        :param epss_percentile_min: The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_percentile_min: float
        :param epss_score_max: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_max: float
        :param epss_score_min: The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on \"less than or equal\"). Leading 0 required.
        :type epss_score_min: float
        :param false_p:
        :type false_p: bool
        :param file_path:
        :type file_path: str
        :param finding_group: Multiple values may be separated by commas.
        :type finding_group: List[float]
        :param found_by: Multiple values may be separated by commas.
        :type found_by: List[int]
        :param has_jira:
        :type has_jira: bool
        :param has_tags: Has tags
        :type has_tags: bool
        :param hash_code:
        :type hash_code: str
        :param id: Multiple values may be separated by commas.
        :type id: List[int]
        :param impact:
        :type impact: str
        :param inherited_tags: Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
        :type inherited_tags: List[List[int]]
        :param is_mitigated:
        :type is_mitigated: bool
        :param jira_change: The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_change: datetime
        :param jira_creation: The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type jira_creation: datetime
        :param last_reviewed: Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type last_reviewed: datetime
        :param last_reviewed_by: Multiple values may be separated by commas.
        :type last_reviewed_by: List[int]
        :param last_status_update:
        :type last_status_update: datetime
        :param limit: Number of results to return per page.
        :type limit: int
        :param mitigated: Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year
        :type mitigated: datetime
        :param mitigated_after: Mitigated After
        :type mitigated_after: datetime
        :param mitigated_before:
        :type mitigated_before: datetime
        :param mitigated_by: Multiple values may be separated by commas.
        :type mitigated_by: List[int]
        :param mitigated_on:
        :type mitigated_on: datetime
        :param mitigation:
        :type mitigation: str
        :param nb_occurences: Multiple values may be separated by commas.
        :type nb_occurences: List[int]
        :param not_tag: Not Tag name contains
        :type not_tag: str
        :param not_tags: Comma separated list of exact tags not present on model
        :type not_tags: List[str]
        :param not_test__engagement__product__tags: Comma separated list of exact tags not present on product
        :type not_test__engagement__product__tags: List[str]
        :param not_test__engagement__tags: Comma separated list of exact tags not present on engagement
        :type not_test__engagement__tags: List[str]
        :param not_test__tags: Comma separated list of exact tags present on test
        :type not_test__tags: List[str]
        :param numerical_severity:
        :type numerical_severity: str
        :param o: Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)
        :type o: List[str]
        :param offset: The initial index from which to return the results.
        :type offset: int
        :param out_of_scope:
        :type out_of_scope: bool
        :param outside_of_sla:
        :type outside_of_sla: float
        :param param:
        :type param: str
        :param payload:
        :type payload: str
        :param planned_remediation_date:
        :type planned_remediation_date: date
        :param planned_remediation_version:
        :type planned_remediation_version: str
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param product_lifecycle: Comma separated list of exact product lifecycles
        :type product_lifecycle: str
        :param product_name: exact product name
        :type product_name: str
        :param product_name_contains: exact product name
        :type product_name_contains: str
        :param publish_date:
        :type publish_date: date
        :param references:
        :type references: str
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param reporter: Multiple values may be separated by commas.
        :type reporter: List[int]
        :param review_requested_by: Multiple values may be separated by commas.
        :type review_requested_by: List[int]
        :param reviewers: Multiple values may be separated by commas.
        :type reviewers: List[int]
        :param risk_acceptance:
        :type risk_acceptance: float
        :param risk_accepted:
        :type risk_accepted: bool
        :param sast_sink_object:
        :type sast_sink_object: str
        :param sast_source_file_path:
        :type sast_source_file_path: str
        :param sast_source_line: Multiple values may be separated by commas.
        :type sast_source_line: List[int]
        :param sast_source_object:
        :type sast_source_object: str
        :param scanner_confidence: Multiple values may be separated by commas.
        :type scanner_confidence: List[int]
        :param service:
        :type service: str
        :param severity:
        :type severity: str
        :param severity_justification:
        :type severity_justification: str
        :param sla_expiration_date:
        :type sla_expiration_date: date
        :param sla_start_date:
        :type sla_start_date: date
        :param sonarqube_issue: Multiple values may be separated by commas.
        :type sonarqube_issue: List[int]
        :param static_finding:
        :type static_finding: bool
        :param steps_to_reproduce:
        :type steps_to_reproduce: str
        :param tag: Tag name contains
        :type tag: str
        :param tags: Comma separated list of exact tags (uses OR for multiple values)
        :type tags: List[str]
        :param tags__and: Comma separated list of exact tags to match with an AND expression
        :type tags__and: List[str]
        :param test:
        :type test: int
        :param test__engagement: Multiple values may be separated by commas.
        :type test__engagement: List[int]
        :param test__engagement__product: Multiple values may be separated by commas.
        :type test__engagement__product: List[int]
        :param test__engagement__product__prod_type: Multiple values may be separated by commas.
        :type test__engagement__product__prod_type: List[int]
        :param test__engagement__product__tags: Comma separated list of exact tags present on product (uses OR for multiple values)
        :type test__engagement__product__tags: List[str]
        :param test__engagement__product__tags__and: Comma separated list of exact tags to match with an AND expression present on product
        :type test__engagement__product__tags__and: List[str]
        :param test__engagement__tags: Comma separated list of exact tags present on engagement (uses OR for multiple values)
        :type test__engagement__tags: List[str]
        :param test__engagement__tags__and: Comma separated list of exact tags to match with an AND expression present on engagement
        :type test__engagement__tags__and: List[str]
        :param test__tags: Comma separated list of exact tags present on test (uses OR for multiple values)
        :type test__tags: List[str]
        :param test__tags__and: Comma separated list of exact tags to match with an AND expression present on test
        :type test__tags__and: List[str]
        :param test__test_type: Multiple values may be separated by commas.
        :type test__test_type: List[int]
        :param title:
        :type title: str
        :param under_defect_review:
        :type under_defect_review: bool
        :param under_review:
        :type under_review: bool
        :param unique_id_from_tool:
        :type unique_id_from_tool: str
        :param verified:
        :type verified: bool
        :param vuln_id_from_tool:
        :type vuln_id_from_tool: str
        :param vulnerability_id:
        :type vulnerability_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_list_serialize(
            active=active,
            component_name=component_name,
            component_version=component_version,
            created=created,
            cvssv3=cvssv3,
            cvssv3_score=cvssv3_score,
            cwe=cwe,
            var_date=var_date,
            defect_review_requested_by=defect_review_requested_by,
            description=description,
            discovered_after=discovered_after,
            discovered_before=discovered_before,
            discovered_on=discovered_on,
            duplicate=duplicate,
            duplicate_finding=duplicate_finding,
            dynamic_finding=dynamic_finding,
            effort_for_fixing=effort_for_fixing,
            endpoints=endpoints,
            epss_percentile_max=epss_percentile_max,
            epss_percentile_min=epss_percentile_min,
            epss_score_max=epss_score_max,
            epss_score_min=epss_score_min,
            false_p=false_p,
            file_path=file_path,
            finding_group=finding_group,
            found_by=found_by,
            has_jira=has_jira,
            has_tags=has_tags,
            hash_code=hash_code,
            id=id,
            impact=impact,
            inherited_tags=inherited_tags,
            is_mitigated=is_mitigated,
            jira_change=jira_change,
            jira_creation=jira_creation,
            last_reviewed=last_reviewed,
            last_reviewed_by=last_reviewed_by,
            last_status_update=last_status_update,
            limit=limit,
            mitigated=mitigated,
            mitigated_after=mitigated_after,
            mitigated_before=mitigated_before,
            mitigated_by=mitigated_by,
            mitigated_on=mitigated_on,
            mitigation=mitigation,
            nb_occurences=nb_occurences,
            not_tag=not_tag,
            not_tags=not_tags,
            not_test__engagement__product__tags=not_test__engagement__product__tags,
            not_test__engagement__tags=not_test__engagement__tags,
            not_test__tags=not_test__tags,
            numerical_severity=numerical_severity,
            o=o,
            offset=offset,
            out_of_scope=out_of_scope,
            outside_of_sla=outside_of_sla,
            param=param,
            payload=payload,
            planned_remediation_date=planned_remediation_date,
            planned_remediation_version=planned_remediation_version,
            prefetch=prefetch,
            product_lifecycle=product_lifecycle,
            product_name=product_name,
            product_name_contains=product_name_contains,
            publish_date=publish_date,
            references=references,
            related_fields=related_fields,
            reporter=reporter,
            review_requested_by=review_requested_by,
            reviewers=reviewers,
            risk_acceptance=risk_acceptance,
            risk_accepted=risk_accepted,
            sast_sink_object=sast_sink_object,
            sast_source_file_path=sast_source_file_path,
            sast_source_line=sast_source_line,
            sast_source_object=sast_source_object,
            scanner_confidence=scanner_confidence,
            service=service,
            severity=severity,
            severity_justification=severity_justification,
            sla_expiration_date=sla_expiration_date,
            sla_start_date=sla_start_date,
            sonarqube_issue=sonarqube_issue,
            static_finding=static_finding,
            steps_to_reproduce=steps_to_reproduce,
            tag=tag,
            tags=tags,
            tags__and=tags__and,
            test=test,
            test__engagement=test__engagement,
            test__engagement__product=test__engagement__product,
            test__engagement__product__prod_type=test__engagement__product__prod_type,
            test__engagement__product__tags=test__engagement__product__tags,
            test__engagement__product__tags__and=test__engagement__product__tags__and,
            test__engagement__tags=test__engagement__tags,
            test__engagement__tags__and=test__engagement__tags__and,
            test__tags=test__tags,
            test__tags__and=test__tags__and,
            test__test_type=test__test_type,
            title=title,
            under_defect_review=under_defect_review,
            under_review=under_review,
            unique_id_from_tool=unique_id_from_tool,
            verified=verified,
            vuln_id_from_tool=vuln_id_from_tool,
            vulnerability_id=vulnerability_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'PaginatedFindingList',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_list_serialize(
        self,
        active,
        component_name,
        component_version,
        created,
        cvssv3,
        cvssv3_score,
        cwe,
        var_date,
        defect_review_requested_by,
        description,
        discovered_after,
        discovered_before,
        discovered_on,
        duplicate,
        duplicate_finding,
        dynamic_finding,
        effort_for_fixing,
        endpoints,
        epss_percentile_max,
        epss_percentile_min,
        epss_score_max,
        epss_score_min,
        false_p,
        file_path,
        finding_group,
        found_by,
        has_jira,
        has_tags,
        hash_code,
        id,
        impact,
        inherited_tags,
        is_mitigated,
        jira_change,
        jira_creation,
        last_reviewed,
        last_reviewed_by,
        last_status_update,
        limit,
        mitigated,
        mitigated_after,
        mitigated_before,
        mitigated_by,
        mitigated_on,
        mitigation,
        nb_occurences,
        not_tag,
        not_tags,
        not_test__engagement__product__tags,
        not_test__engagement__tags,
        not_test__tags,
        numerical_severity,
        o,
        offset,
        out_of_scope,
        outside_of_sla,
        param,
        payload,
        planned_remediation_date,
        planned_remediation_version,
        prefetch,
        product_lifecycle,
        product_name,
        product_name_contains,
        publish_date,
        references,
        related_fields,
        reporter,
        review_requested_by,
        reviewers,
        risk_acceptance,
        risk_accepted,
        sast_sink_object,
        sast_source_file_path,
        sast_source_line,
        sast_source_object,
        scanner_confidence,
        service,
        severity,
        severity_justification,
        sla_expiration_date,
        sla_start_date,
        sonarqube_issue,
        static_finding,
        steps_to_reproduce,
        tag,
        tags,
        tags__and,
        test,
        test__engagement,
        test__engagement__product,
        test__engagement__product__prod_type,
        test__engagement__product__tags,
        test__engagement__product__tags__and,
        test__engagement__tags,
        test__engagement__tags__and,
        test__tags,
        test__tags__and,
        test__test_type,
        title,
        under_defect_review,
        under_review,
        unique_id_from_tool,
        verified,
        vuln_id_from_tool,
        vulnerability_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'cwe': 'csv',
            'defect_review_requested_by': 'csv',
            'endpoints': 'csv',
            'finding_group': 'csv',
            'found_by': 'csv',
            'id': 'csv',
            'inherited_tags': 'multi',
            'last_reviewed_by': 'csv',
            'mitigated_by': 'csv',
            'nb_occurences': 'csv',
            'not_tags': 'csv',
            'not_test__engagement__product__tags': 'csv',
            'not_test__engagement__tags': 'csv',
            'not_test__tags': 'csv',
            'o': 'csv',
            'prefetch': 'multi',
            'reporter': 'csv',
            'review_requested_by': 'csv',
            'reviewers': 'csv',
            'sast_source_line': 'csv',
            'scanner_confidence': 'csv',
            'sonarqube_issue': 'csv',
            'tags': 'csv',
            'tags__and': 'csv',
            'test__engagement': 'csv',
            'test__engagement__product': 'csv',
            'test__engagement__product__prod_type': 'csv',
            'test__engagement__product__tags': 'csv',
            'test__engagement__product__tags__and': 'csv',
            'test__engagement__tags': 'csv',
            'test__engagement__tags__and': 'csv',
            'test__tags': 'csv',
            'test__tags__and': 'csv',
            'test__test_type': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if active is not None:
            _query_params.append(('active', active))

        if component_name is not None:
            _query_params.append(('component_name', component_name))

        if component_version is not None:
            _query_params.append(('component_version', component_version))

        if created is not None:
            if isinstance(created, datetime):
                _query_params.append(('created', created.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('created', created))

        if cvssv3 is not None:
            _query_params.append(('cvssv3', cvssv3))

        if cvssv3_score is not None:
            _query_params.append(('cvssv3_score', cvssv3_score))

        if cwe is not None:
            _query_params.append(('cwe', cwe))

        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(('date', var_date.strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('date', var_date))

        if defect_review_requested_by is not None:
            _query_params.append(('defect_review_requested_by', defect_review_requested_by))

        if description is not None:
            _query_params.append(('description', description))

        if discovered_after is not None:
            if isinstance(discovered_after, date):
                _query_params.append(
                    ('discovered_after', discovered_after.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_after', discovered_after))

        if discovered_before is not None:
            if isinstance(discovered_before, date):
                _query_params.append(
                    ('discovered_before', discovered_before.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_before', discovered_before))

        if discovered_on is not None:
            if isinstance(discovered_on, date):
                _query_params.append(
                    ('discovered_on', discovered_on.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('discovered_on', discovered_on))

        if duplicate is not None:
            _query_params.append(('duplicate', duplicate))

        if duplicate_finding is not None:
            _query_params.append(('duplicate_finding', duplicate_finding))

        if dynamic_finding is not None:
            _query_params.append(('dynamic_finding', dynamic_finding))

        if effort_for_fixing is not None:
            _query_params.append(('effort_for_fixing', effort_for_fixing))

        if endpoints is not None:
            _query_params.append(('endpoints', endpoints))

        if epss_percentile_max is not None:
            _query_params.append(('epss_percentile_max', epss_percentile_max))

        if epss_percentile_min is not None:
            _query_params.append(('epss_percentile_min', epss_percentile_min))

        if epss_score_max is not None:
            _query_params.append(('epss_score_max', epss_score_max))

        if epss_score_min is not None:
            _query_params.append(('epss_score_min', epss_score_min))

        if false_p is not None:
            _query_params.append(('false_p', false_p))

        if file_path is not None:
            _query_params.append(('file_path', file_path))

        if finding_group is not None:
            _query_params.append(('finding_group', finding_group))

        if found_by is not None:
            _query_params.append(('found_by', found_by))

        if has_jira is not None:
            _query_params.append(('has_jira', has_jira))

        if has_tags is not None:
            _query_params.append(('has_tags', has_tags))

        if hash_code is not None:
            _query_params.append(('hash_code', hash_code))

        if id is not None:
            _query_params.append(('id', id))

        if impact is not None:
            _query_params.append(('impact', impact))

        if inherited_tags is not None:
            _query_params.append(('inherited_tags', inherited_tags))

        if is_mitigated is not None:
            _query_params.append(('is_mitigated', is_mitigated))

        if jira_change is not None:
            if isinstance(jira_change, datetime):
                _query_params.append(
                    ('jira_change', jira_change.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('jira_change', jira_change))

        if jira_creation is not None:
            if isinstance(jira_creation, datetime):
                _query_params.append(
                    ('jira_creation', jira_creation.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('jira_creation', jira_creation))

        if last_reviewed is not None:
            if isinstance(last_reviewed, datetime):
                _query_params.append(
                    ('last_reviewed', last_reviewed.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('last_reviewed', last_reviewed))

        if last_reviewed_by is not None:
            _query_params.append(('last_reviewed_by', last_reviewed_by))

        if last_status_update is not None:
            if isinstance(last_status_update, datetime):
                _query_params.append(
                    ('last_status_update', last_status_update.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('last_status_update', last_status_update))

        if limit is not None:
            _query_params.append(('limit', limit))

        if mitigated is not None:
            if isinstance(mitigated, datetime):
                _query_params.append(('mitigated', mitigated.strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('mitigated', mitigated))

        if mitigated_after is not None:
            if isinstance(mitigated_after, datetime):
                _query_params.append(
                    ('mitigated_after', mitigated_after.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_after', mitigated_after))

        if mitigated_before is not None:
            if isinstance(mitigated_before, datetime):
                _query_params.append(
                    ('mitigated_before', mitigated_before.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_before', mitigated_before))

        if mitigated_by is not None:
            _query_params.append(('mitigated_by', mitigated_by))

        if mitigated_on is not None:
            if isinstance(mitigated_on, datetime):
                _query_params.append(
                    ('mitigated_on', mitigated_on.strftime(self.api_client.configuration.datetime_format))
                )
            else:
                _query_params.append(('mitigated_on', mitigated_on))

        if mitigation is not None:
            _query_params.append(('mitigation', mitigation))

        if nb_occurences is not None:
            _query_params.append(('nb_occurences', nb_occurences))

        if not_tag is not None:
            _query_params.append(('not_tag', not_tag))

        if not_tags is not None:
            _query_params.append(('not_tags', not_tags))

        if not_test__engagement__product__tags is not None:
            _query_params.append(('not_test__engagement__product__tags', not_test__engagement__product__tags))

        if not_test__engagement__tags is not None:
            _query_params.append(('not_test__engagement__tags', not_test__engagement__tags))

        if not_test__tags is not None:
            _query_params.append(('not_test__tags', not_test__tags))

        if numerical_severity is not None:
            _query_params.append(('numerical_severity', numerical_severity))

        if o is not None:
            _query_params.append(('o', o))

        if offset is not None:
            _query_params.append(('offset', offset))

        if out_of_scope is not None:
            _query_params.append(('out_of_scope', out_of_scope))

        if outside_of_sla is not None:
            _query_params.append(('outside_of_sla', outside_of_sla))

        if param is not None:
            _query_params.append(('param', param))

        if payload is not None:
            _query_params.append(('payload', payload))

        if planned_remediation_date is not None:
            if isinstance(planned_remediation_date, date):
                _query_params.append(
                    (
                        'planned_remediation_date',
                        planned_remediation_date.strftime(self.api_client.configuration.date_format),
                    )
                )
            else:
                _query_params.append(('planned_remediation_date', planned_remediation_date))

        if planned_remediation_version is not None:
            _query_params.append(('planned_remediation_version', planned_remediation_version))

        if prefetch is not None:
            _query_params.append(('prefetch', prefetch))

        if product_lifecycle is not None:
            _query_params.append(('product_lifecycle', product_lifecycle))

        if product_name is not None:
            _query_params.append(('product_name', product_name))

        if product_name_contains is not None:
            _query_params.append(('product_name_contains', product_name_contains))

        if publish_date is not None:
            if isinstance(publish_date, date):
                _query_params.append(('publish_date', publish_date.strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('publish_date', publish_date))

        if references is not None:
            _query_params.append(('references', references))

        if related_fields is not None:
            _query_params.append(('related_fields', related_fields))

        if reporter is not None:
            _query_params.append(('reporter', reporter))

        if review_requested_by is not None:
            _query_params.append(('review_requested_by', review_requested_by))

        if reviewers is not None:
            _query_params.append(('reviewers', reviewers))

        if risk_acceptance is not None:
            _query_params.append(('risk_acceptance', risk_acceptance))

        if risk_accepted is not None:
            _query_params.append(('risk_accepted', risk_accepted))

        if sast_sink_object is not None:
            _query_params.append(('sast_sink_object', sast_sink_object))

        if sast_source_file_path is not None:
            _query_params.append(('sast_source_file_path', sast_source_file_path))

        if sast_source_line is not None:
            _query_params.append(('sast_source_line', sast_source_line))

        if sast_source_object is not None:
            _query_params.append(('sast_source_object', sast_source_object))

        if scanner_confidence is not None:
            _query_params.append(('scanner_confidence', scanner_confidence))

        if service is not None:
            _query_params.append(('service', service))

        if severity is not None:
            _query_params.append(('severity', severity))

        if severity_justification is not None:
            _query_params.append(('severity_justification', severity_justification))

        if sla_expiration_date is not None:
            if isinstance(sla_expiration_date, date):
                _query_params.append(
                    ('sla_expiration_date', sla_expiration_date.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('sla_expiration_date', sla_expiration_date))

        if sla_start_date is not None:
            if isinstance(sla_start_date, date):
                _query_params.append(
                    ('sla_start_date', sla_start_date.strftime(self.api_client.configuration.date_format))
                )
            else:
                _query_params.append(('sla_start_date', sla_start_date))

        if sonarqube_issue is not None:
            _query_params.append(('sonarqube_issue', sonarqube_issue))

        if static_finding is not None:
            _query_params.append(('static_finding', static_finding))

        if steps_to_reproduce is not None:
            _query_params.append(('steps_to_reproduce', steps_to_reproduce))

        if tag is not None:
            _query_params.append(('tag', tag))

        if tags is not None:
            _query_params.append(('tags', tags))

        if tags__and is not None:
            _query_params.append(('tags__and', tags__and))

        if test is not None:
            _query_params.append(('test', test))

        if test__engagement is not None:
            _query_params.append(('test__engagement', test__engagement))

        if test__engagement__product is not None:
            _query_params.append(('test__engagement__product', test__engagement__product))

        if test__engagement__product__prod_type is not None:
            _query_params.append(('test__engagement__product__prod_type', test__engagement__product__prod_type))

        if test__engagement__product__tags is not None:
            _query_params.append(('test__engagement__product__tags', test__engagement__product__tags))

        if test__engagement__product__tags__and is not None:
            _query_params.append(('test__engagement__product__tags__and', test__engagement__product__tags__and))

        if test__engagement__tags is not None:
            _query_params.append(('test__engagement__tags', test__engagement__tags))

        if test__engagement__tags__and is not None:
            _query_params.append(('test__engagement__tags__and', test__engagement__tags__and))

        if test__tags is not None:
            _query_params.append(('test__tags', test__tags))

        if test__tags__and is not None:
            _query_params.append(('test__tags__and', test__tags__and))

        if test__test_type is not None:
            _query_params.append(('test__test_type', test__test_type))

        if title is not None:
            _query_params.append(('title', title))

        if under_defect_review is not None:
            _query_params.append(('under_defect_review', under_defect_review))

        if under_review is not None:
            _query_params.append(('under_review', under_review))

        if unique_id_from_tool is not None:
            _query_params.append(('unique_id_from_tool', unique_id_from_tool))

        if verified is not None:
            _query_params.append(('verified', verified))

        if vuln_id_from_tool is not None:
            _query_params.append(('vuln_id_from_tool', vuln_id_from_tool))

        if vulnerability_id is not None:
            _query_params.append(('vulnerability_id', vulnerability_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_list_iterator(
        self,
        active: Optional[StrictBool] = None,
        component_name: Optional[StrictStr] = None,
        component_version: Optional[StrictStr] = None,
        created: Annotated[
            Optional[datetime],
            Field(
                description='The date the finding was created inside DefectDojo.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        cvssv3: Optional[StrictStr] = None,
        cvssv3_score: Optional[Union[StrictFloat, StrictInt]] = None,
        cwe: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        var_date: Annotated[
            Optional[date],
            Field(
                description='The date the flaw was discovered.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        defect_review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        description: Optional[StrictStr] = None,
        discovered_after: Optional[date] = None,
        discovered_before: Optional[date] = None,
        discovered_on: Optional[date] = None,
        duplicate: Optional[StrictBool] = None,
        duplicate_finding: Optional[StrictInt] = None,
        dynamic_finding: Optional[StrictBool] = None,
        effort_for_fixing: Optional[StrictStr] = None,
        endpoints: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        epss_percentile_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_percentile_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS percentiles to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_max: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        epss_score_min: Annotated[
            Optional[
                Union[
                    Annotated[float, Field(le=1.0, strict=True, ge=0.0)], Annotated[int, Field(le=1, strict=True, ge=0)]
                ]
            ],
            Field(
                description='The range of EPSS score percentages to filter on; the min input is a lower bound, the max is an upper bound. Leaving one empty will skip that bound (e.g., leaving the min bound input empty will filter only on the max bound -- filtering on "less than or equal"). Leading 0 required.'
            ),
        ] = None,
        false_p: Optional[StrictBool] = None,
        file_path: Optional[StrictStr] = None,
        finding_group: Annotated[
            Optional[List[Union[StrictFloat, StrictInt]]],
            Field(description='Multiple values may be separated by commas.'),
        ] = None,
        found_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        has_jira: Optional[StrictBool] = None,
        has_tags: Annotated[Optional[StrictBool], Field(description='Has tags')] = None,
        hash_code: Optional[StrictStr] = None,
        id: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        impact: Optional[StrictStr] = None,
        inherited_tags: Annotated[
            Optional[List[List[StrictInt]]],
            Field(
                description='Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field'
            ),
        ] = None,
        is_mitigated: Optional[StrictBool] = None,
        jira_change: Annotated[
            Optional[datetime],
            Field(
                description='The date the linked Jira issue was last modified.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        jira_creation: Annotated[
            Optional[datetime],
            Field(
                description='The date a Jira issue was created from this finding.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        last_reviewed: Annotated[
            Optional[datetime],
            Field(
                description="Provides the date the flaw was last 'touched' by a tester.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year"
            ),
        ] = None,
        last_reviewed_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        last_status_update: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description='Number of results to return per page.')] = None,
        mitigated: Annotated[
            Optional[datetime],
            Field(
                description='Denotes if this flaw has been fixed by storing the date it was fixed.  * `None` - Any date * `1` - Today * `2` - Past 7 days * `3` - Past 30 days * `4` - Past 90 days * `5` - Current month * `6` - Current year * `7` - Past year'
            ),
        ] = None,
        mitigated_after: Annotated[Optional[datetime], Field(description='Mitigated After')] = None,
        mitigated_before: Optional[datetime] = None,
        mitigated_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        mitigated_on: Optional[datetime] = None,
        mitigation: Optional[StrictStr] = None,
        nb_occurences: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        not_tag: Annotated[Optional[StrictStr], Field(description='Not Tag name contains')] = None,
        not_tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on model')
        ] = None,
        not_test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on product')
        ] = None,
        not_test__engagement__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags not present on engagement')
        ] = None,
        not_test__tags: Annotated[
            Optional[List[StrictStr]], Field(description='Comma separated list of exact tags present on test')
        ] = None,
        numerical_severity: Optional[StrictStr] = None,
        o: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Ordering  * `active` - Active * `-active` - Active (descending) * `component_name` - Component name * `-component_name` - Component name (descending) * `component_version` - Component version * `-component_version` - Component version (descending) * `created` - Created * `-created` - Created (descending) * `last_status_update` - Last status update * `-last_status_update` - Last status update (descending) * `last_reviewed` - Last reviewed * `-last_reviewed` - Last reviewed (descending) * `cwe` - Cwe * `-cwe` - Cwe (descending) * `date` - Date * `-date` - Date (descending) * `duplicate` - Duplicate * `-duplicate` - Duplicate (descending) * `dynamic_finding` - Dynamic finding * `-dynamic_finding` - Dynamic finding (descending) * `false_p` - False p * `-false_p` - False p (descending) * `found_by` - Found by * `-found_by` - Found by (descending) * `id` - Id * `-id` - Id (descending) * `is_mitigated` - Is mitigated * `-is_mitigated` - Is mitigated (descending) * `numerical_severity` - Numerical severity * `-numerical_severity` - Numerical severity (descending) * `out_of_scope` - Out of scope * `-out_of_scope` - Out of scope (descending) * `severity` - Severity * `-severity` - Severity (descending) * `reviewers` - Reviewers * `-reviewers` - Reviewers (descending) * `static_finding` - Static finding * `-static_finding` - Static finding (descending) * `test__engagement__product__name` - Test  engagement  product  name * `-test__engagement__product__name` - Test  engagement  product  name (descending) * `title` - Title * `-title` - Title (descending) * `under_defect_review` - Under defect review * `-under_defect_review` - Under defect review (descending) * `under_review` - Under review * `-under_review` - Under review (descending) * `verified` - Verified * `-verified` - Verified (descending)'
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt], Field(description='The initial index from which to return the results.')
        ] = None,
        out_of_scope: Optional[StrictBool] = None,
        outside_of_sla: Optional[Union[StrictFloat, StrictInt]] = None,
        param: Optional[StrictStr] = None,
        payload: Optional[StrictStr] = None,
        planned_remediation_date: Optional[date] = None,
        planned_remediation_version: Optional[StrictStr] = None,
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        product_lifecycle: Annotated[
            Optional[StrictStr], Field(description='Comma separated list of exact product lifecycles')
        ] = None,
        product_name: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        product_name_contains: Annotated[Optional[StrictStr], Field(description='exact product name')] = None,
        publish_date: Optional[date] = None,
        references: Optional[StrictStr] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        reporter: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        review_requested_by: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        reviewers: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        risk_acceptance: Optional[Union[StrictFloat, StrictInt]] = None,
        risk_accepted: Optional[StrictBool] = None,
        sast_sink_object: Optional[StrictStr] = None,
        sast_source_file_path: Optional[StrictStr] = None,
        sast_source_line: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        sast_source_object: Optional[StrictStr] = None,
        scanner_confidence: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        service: Optional[StrictStr] = None,
        severity: Optional[StrictStr] = None,
        severity_justification: Optional[StrictStr] = None,
        sla_expiration_date: Optional[date] = None,
        sla_start_date: Optional[date] = None,
        sonarqube_issue: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        static_finding: Optional[StrictBool] = None,
        steps_to_reproduce: Optional[StrictStr] = None,
        tag: Annotated[Optional[StrictStr], Field(description='Tag name contains')] = None,
        tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags (uses OR for multiple values)'),
        ] = None,
        tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression'),
        ] = None,
        test: Optional[StrictInt] = None,
        test__engagement: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__prod_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        test__engagement__product__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on product (uses OR for multiple values)'),
        ] = None,
        test__engagement__product__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on product'),
        ] = None,
        test__engagement__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on engagement (uses OR for multiple values)'),
        ] = None,
        test__engagement__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(
                description='Comma separated list of exact tags to match with an AND expression present on engagement'
            ),
        ] = None,
        test__tags: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags present on test (uses OR for multiple values)'),
        ] = None,
        test__tags__and: Annotated[
            Optional[List[StrictStr]],
            Field(description='Comma separated list of exact tags to match with an AND expression present on test'),
        ] = None,
        test__test_type: Annotated[
            Optional[List[StrictInt]], Field(description='Multiple values may be separated by commas.')
        ] = None,
        title: Optional[StrictStr] = None,
        under_defect_review: Optional[StrictBool] = None,
        under_review: Optional[StrictBool] = None,
        unique_id_from_tool: Optional[StrictStr] = None,
        verified: Optional[StrictBool] = None,
        vuln_id_from_tool: Optional[StrictStr] = None,
        vulnerability_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> 'Generator[IteratorResult[Finding, PaginatedFindingList], None, None]':
        _params = locals()
        for page in get_all_pages(self.api_client, FindingsApi.findings_list, **_params):
            for result in page.results:
                yield IteratorResult(result=result, page=page)

    def findings_metadata_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingMeta:
        """findings_metadata_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_create_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_metadata_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingMeta]:
        """findings_metadata_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_create_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_metadata_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_metadata_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_create_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_metadata_create_serialize(
        self,
        id,
        finding_meta_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if finding_meta_request is not None:
            _body_params = finding_meta_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_metadata_destroy(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        name: Annotated[
            StrictInt,
            Field(
                description='name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding'
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_metadata_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param name: name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding (required)
        :type name: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_destroy_serialize(
            id=id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_metadata_destroy_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        name: Annotated[
            StrictInt,
            Field(
                description='name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding'
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_metadata_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param name: name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding (required)
        :type name: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_destroy_serialize(
            id=id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_metadata_destroy_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        name: Annotated[
            StrictInt,
            Field(
                description='name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding'
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_metadata_destroy


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param name: name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding (required)
        :type name: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_destroy_serialize(
            id=id,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_metadata_destroy_serialize(
        self,
        id,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if name is not None:
            _query_params.append(('name', name))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/findings/{id}/metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_metadata_list(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FindingMeta]:
        """findings_metadata_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[FindingMeta]',
            '404': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_metadata_list_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FindingMeta]]:
        """findings_metadata_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[FindingMeta]',
            '404': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_metadata_list_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_metadata_list


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_list_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'List[FindingMeta]',
            '404': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_metadata_list_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_metadata_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingMeta:
        """findings_metadata_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_update_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_metadata_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingMeta]:
        """findings_metadata_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_update_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_metadata_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_meta_request: FindingMetaRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_metadata_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_meta_request: (required)
        :type finding_meta_request: FindingMetaRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_metadata_update_serialize(
            id=id,
            finding_meta_request=finding_meta_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingMeta',
            '404': None,
            '400': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_metadata_update_serialize(
        self,
        id,
        finding_meta_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if finding_meta_request is not None:
            _body_params = finding_meta_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/findings/{id}/metadata/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_notes_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Note:
        """findings_notes_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_notes_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Note]:
        """findings_notes_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_notes_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        add_new_note_option_request: AddNewNoteOptionRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_notes_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param add_new_note_option_request: (required)
        :type add_new_note_option_request: AddNewNoteOptionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_create_serialize(
            id=id,
            add_new_note_option_request=add_new_note_option_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Note',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_notes_create_serialize(
        self,
        id,
        add_new_note_option_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_new_note_option_request is not None:
            _body_params = add_new_note_option_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/notes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_notes_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FindingToNotes:
        """findings_notes_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_notes_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FindingToNotes]:
        """findings_notes_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_notes_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_notes_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_notes_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'FindingToNotes',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_notes_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/notes/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_original_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        new_fid: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_original_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param new_fid: (required)
        :type new_fid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_original_create_serialize(
            id=id,
            new_fid=new_fid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_original_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        new_fid: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_original_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param new_fid: (required)
        :type new_fid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_original_create_serialize(
            id=id,
            new_fid=new_fid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_original_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        new_fid: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_original_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param new_fid: (required)
        :type new_fid: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_original_create_serialize(
            id=id,
            new_fid=new_fid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_original_create_serialize(
        self,
        id,
        new_fid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if new_fid is not None:
            _path_params['new_fid'] = new_fid
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/original/{new_fid}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_partial_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_request: Optional[PatchedFindingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Finding:
        """findings_partial_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_request:
        :type patched_finding_request: PatchedFindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_partial_update_serialize(
            id=id,
            patched_finding_request=patched_finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_request: Optional[PatchedFindingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Finding]:
        """findings_partial_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_request:
        :type patched_finding_request: PatchedFindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_partial_update_serialize(
            id=id,
            patched_finding_request=patched_finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_request: Optional[PatchedFindingRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_partial_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_request:
        :type patched_finding_request: PatchedFindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_partial_update_serialize(
            id=id,
            patched_finding_request=patched_finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_partial_update_serialize(
        self,
        id,
        patched_finding_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_finding_request is not None:
            _body_params = patched_finding_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/findings/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_remove_note_partial_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_note_request: Optional[PatchedFindingNoteRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_remove_note_partial_update

        Remove Note From Finding Note

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_note_request:
        :type patched_finding_note_request: PatchedFindingNoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_note_partial_update_serialize(
            id=id,
            patched_finding_note_request=patched_finding_note_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_remove_note_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_note_request: Optional[PatchedFindingNoteRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_remove_note_partial_update

        Remove Note From Finding Note

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_note_request:
        :type patched_finding_note_request: PatchedFindingNoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_note_partial_update_serialize(
            id=id,
            patched_finding_note_request=patched_finding_note_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_remove_note_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_finding_note_request: Optional[PatchedFindingNoteRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_remove_note_partial_update

        Remove Note From Finding Note

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_finding_note_request:
        :type patched_finding_note_request: PatchedFindingNoteRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_note_partial_update_serialize(
            id=id,
            patched_finding_note_request=patched_finding_note_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_remove_note_partial_update_serialize(
        self,
        id,
        patched_finding_note_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_finding_note_request is not None:
            _body_params = patched_finding_note_request

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/findings/{id}/remove_note/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_remove_tags_partial_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_tag_request: Optional[PatchedTagRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_remove_tags_partial_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_tag_request:
        :type patched_tag_request: PatchedTagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_partial_update_serialize(
            id=id,
            patched_tag_request=patched_tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_remove_tags_partial_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_tag_request: Optional[PatchedTagRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_remove_tags_partial_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_tag_request:
        :type patched_tag_request: PatchedTagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_partial_update_serialize(
            id=id,
            patched_tag_request=patched_tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_remove_tags_partial_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        patched_tag_request: Optional[PatchedTagRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_remove_tags_partial_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param patched_tag_request:
        :type patched_tag_request: PatchedTagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_partial_update_serialize(
            id=id,
            patched_tag_request=patched_tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_remove_tags_partial_update_serialize(
        self,
        id,
        patched_tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patched_tag_request is not None:
            _body_params = patched_tag_request

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/findings/{id}/remove_tags/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_remove_tags_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """findings_remove_tags_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_update_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_remove_tags_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """findings_remove_tags_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_update_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_remove_tags_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_remove_tags_update

        Remove Tag(s) from finding list of tags

        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_remove_tags_update_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_remove_tags_update_serialize(
        self,
        id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/findings/{id}/remove_tags/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_request_response_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        burp_raw_request_response_request: BurpRawRequestResponseRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BurpRawRequestResponse:
        """findings_request_response_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param burp_raw_request_response_request: (required)
        :type burp_raw_request_response_request: BurpRawRequestResponseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_create_serialize(
            id=id,
            burp_raw_request_response_request=burp_raw_request_response_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_request_response_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        burp_raw_request_response_request: BurpRawRequestResponseRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BurpRawRequestResponse]:
        """findings_request_response_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param burp_raw_request_response_request: (required)
        :type burp_raw_request_response_request: BurpRawRequestResponseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_create_serialize(
            id=id,
            burp_raw_request_response_request=burp_raw_request_response_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_request_response_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        burp_raw_request_response_request: BurpRawRequestResponseRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_request_response_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param burp_raw_request_response_request: (required)
        :type burp_raw_request_response_request: BurpRawRequestResponseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_create_serialize(
            id=id,
            burp_raw_request_response_request=burp_raw_request_response_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_request_response_create_serialize(
        self,
        id,
        burp_raw_request_response_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if burp_raw_request_response_request is not None:
            _body_params = burp_raw_request_response_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/request_response/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_request_response_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BurpRawRequestResponse:
        """findings_request_response_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_request_response_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BurpRawRequestResponse]:
        """findings_request_response_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_request_response_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_request_response_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_request_response_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'BurpRawRequestResponse',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_request_response_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/request_response/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Finding:
        """findings_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            related_fields=related_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Finding]:
        """findings_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            related_fields=related_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        prefetch: Annotated[
            Optional[List[StrictStr]],
            Field(description='List of fields for which to prefetch model instances and add those to the response'),
        ] = None,
        related_fields: Annotated[
            Optional[StrictBool],
            Field(
                description='Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param prefetch: List of fields for which to prefetch model instances and add those to the response
        :type prefetch: List[str]
        :param related_fields: Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
        :type related_fields: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_retrieve_serialize(
            id=id,
            prefetch=prefetch,
            related_fields=related_fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_retrieve_serialize(
        self,
        id,
        prefetch,
        related_fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {
            'prefetch': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if prefetch is not None:
            _query_params.append(('prefetch', prefetch))

        if related_fields is not None:
            _query_params.append(('related_fields', related_fields))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_tags_create(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Tag:
        """findings_tags_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_create_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_tags_create_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Tag]:
        """findings_tags_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_create_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_tags_create_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        tag_request: TagRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_tags_create


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param tag_request: (required)
        :type tag_request: TagRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_create_serialize(
            id=id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_tags_create_serialize(
        self,
        id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/findings/{id}/tags/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_tags_retrieve(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Tag:
        """findings_tags_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_tags_retrieve_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Tag]:
        """findings_tags_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_tags_retrieve_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_tags_retrieve


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_tags_retrieve_serialize(
            id=id, _request_auth=_request_auth, _content_type=_content_type, _headers=_headers, _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Tag',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_tags_retrieve_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/findings/{id}/tags/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    def findings_update(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_request: FindingRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Finding:
        """findings_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_request: (required)
        :type finding_request: FindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_update_serialize(
            id=id,
            finding_request=finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def findings_update_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_request: FindingRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Finding]:
        """findings_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_request: (required)
        :type finding_request: FindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_update_serialize(
            id=id,
            finding_request=finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def findings_update_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description='A unique integer value identifying this finding.')],
        finding_request: FindingRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """findings_update


        :param id: A unique integer value identifying this finding. (required)
        :type id: int
        :param finding_request: (required)
        :type finding_request: FindingRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._findings_update_serialize(
            id=id,
            finding_request=finding_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': 'Finding',
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _findings_update_serialize(
        self,
        id,
        finding_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if finding_request is not None:
            _body_params = finding_request

        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data']
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ['basicAuth', 'cookieAuth', 'tokenAuth']

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/findings/{id}/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

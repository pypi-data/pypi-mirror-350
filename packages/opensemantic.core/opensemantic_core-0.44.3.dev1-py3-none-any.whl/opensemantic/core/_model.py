# generated by datamodel-codegen:
#   filename:  Entity.json

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class LangCode(str, Enum):
    en = "en"
    de = "de"


from uuid import uuid4

from opensemantic import OswBaseModel


class Label(OswBaseModel):
    text: constr(min_length=1) = Field(..., title="Text")
    lang: Optional[LangCode] = Field(LangCode.en, title="Lang code")


class Description(Label):
    pass


class WikiPage(OswBaseModel):
    """
    The wiki page containing this entity
    """

    title: Optional[str] = Field(None, title="Title")
    """
    The page title
    """
    namespace: Optional[str] = Field(None, example="Category", title="Namespace")
    """
    The page namespace
    """


class Meta(OswBaseModel):
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    wiki_page: Optional[WikiPage] = Field(None, title="Wiki page")
    """
    The wiki page containing this entity
    """
    change_id: Optional[List[str]] = Field(None, title="Change IDs")
    """
    To keep track of concerted changes
    """


class Entity(OswBaseModel):
    rdf_type: Optional[Set[str]] = Field(None, title="Additional RDF type(s)")
    """
    Declares additional type(s) for this entity, e.g., to state that this entity has the same meaning as a term in a controlled vocabulary or ontology. This property is synonymous to the schema:additionalType and owl:sameAs. The default syntax is ontology:TermName. The ontology prefix has to be defined in the @context of the Entity, the category or any of the parent categories. The term name has to be a valid identifier in the ontology.
    """
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    iri: Optional[str] = Field(None, title="IRI")
    """
    The Internationalized Resource Identifier (IRI) of this entity
    """
    name: Optional[str] = Field(None, title="Technical name")
    """
    Technical / Machine compatible name
    """
    label: List[Label] = Field(..., min_items=1, title="Label(s)")
    """
    At least one label is required.
    """
    short_name: Optional[List[Label]] = Field(None, title="Short name(s)")
    """
    Abbreviation, Acronym, etc.
    """
    query_label: Optional[str] = Field(None, title="Query label")
    description: Optional[List[Description]] = Field(None, title="Description")
    image: Optional[str] = Field(None, title="Image")
    ordering_categories: Optional[List[str]] = Field(
        None, title="Classification categories"
    )
    """
    Classification categories are used to categorize instances, e.g., according to their use but not their properties. When querying for instances of a here listed classification category, this instance will be returned. Note: Classification categories define no properties, while 'regular' categories define properties, which an instance assigns values to.
    """
    keywords: Optional[List[str]] = Field(None, title="Keywords / Tags")
    """
    Designated to the user defined categorization of this element
    """
    based_on: Optional[List[str]] = Field(None, title="Based on")
    """
    Other entities on which this one is based, e.g. when it is created by copying
    """
    statements: Optional[
        List[Union[ObjectStatement, DataStatement, QuantityStatement]]
    ] = Field(None, title="Statements")
    attachments: Optional[List[str]] = Field(None, title="File attachments")
    meta: Optional[Meta] = None


class ObjectStatement(OswBaseModel):
    rdf_type: Optional[Any] = "rdf:Statement"
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    label: Optional[List[Label]] = Field(None, title="Label")
    """
    Human readable name
    """
    subject: Optional[str] = Field(None, title="Subject")
    substatements: Optional[
        List[Union[ObjectStatement, DataStatement, QuantityStatement]]
    ] = Field(None, title="Substatements")
    predicate: str = Field(..., title="Predicate")
    object: str = Field(..., title="Object")


class DataStatement(OswBaseModel):
    rdf_type: Optional[Any] = "rdf:Statement"
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    label: Optional[List[Label]] = Field(None, title="Label")
    """
    Human readable name
    """
    subject: Optional[str] = Field(None, title="Subject")
    substatements: Optional[
        List[Union[ObjectStatement, DataStatement, QuantityStatement]]
    ] = Field(None, title="Substatements")
    property: str = Field(..., title="Property")
    value: str = Field(..., title="Value")


class QuantityStatement(OswBaseModel):
    rdf_type: Optional[Any] = "rdf:Statement"
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    label: Optional[List[Label]] = Field(None, title="Label")
    """
    Human readable name
    """
    subject: Optional[str] = Field(None, title="Subject")
    substatements: Optional[
        List[Union[ObjectStatement, DataStatement, QuantityStatement]]
    ] = Field(None, title="Substatements")
    quantity: str = Field(..., title="Property")
    numerical_value: str = Field(..., title="Value")
    unit: str = Field(..., title="Unit")
    unit_symbol: str
    value: str = Field(..., title="Value")


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWe427aafafbac4262955b9f690a83405d.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class InitialOccupantOfTheSlot(OswBaseModel):
    """
    Tool or component installed in the slot.
    """

    slot_occupant_type: Optional[str] = Field(None, title="Type")
    slot_occupant_instance_property: Optional[str] = "Property:HasOccupant"
    slot_occupant_instance: str = Field(..., title="Instance")


class Level(str, Enum):
    public = "public"
    internal = "internal"
    restricted = "restricted"


class ReadAccess(OswBaseModel):
    level: Optional[Level] = Field(None, title="Level")


class AccessRestrictions(OswBaseModel):
    read: Optional[ReadAccess] = Field(None, title="Read access")


class Component(OswBaseModel):
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    component_id: str = Field(..., title="ID")
    """
    Automatically generated
    """
    label: Optional[List[Label]] = Field(None, title="Label")
    """
    Designation of the function or role of the component in this specific context.
    """
    description: Optional[List[Description]] = Field(None, title="Description")
    """
    Optional, additional details on the role or function of the component in this specific context.
    """
    component_type: Optional[str] = Field(
        "Category:OSWe427aafafbac4262955b9f690a83405d", title="Component type"
    )
    component_instance_property: Optional[str] = "Property:HasPart"
    component_instance: str = Field(..., title="Instance")


class Slot(OswBaseModel):
    uuid: str = Field(..., title="UUID")
    slot_osw_id: str = Field(..., title="OSW-ID")
    slot_id: str = Field(..., title="ID")
    """
    Automatically generated
    """
    name: Optional[str] = Field(None, title="Name")
    description: Optional[List[Description]] = Field(None, title="Description")
    slot_init_date_time: str = Field(..., title="Date of slot initialization")
    slot_type_restriction: Optional[str] = Field(
        "Category:OSWe427aafafbac4262955b9f690a83405d",
        title="Type restriction of the slot",
    )
    slot_occupant: Optional[InitialOccupantOfTheSlot] = Field(
        None, title="Initial occupant of the slot"
    )
    """
    Tool or component installed in the slot.
    """


class Item(Entity):
    type: Optional[List[str]] = Field(
        ["Category:Item"], min_items=1, title="Types/Categories"
    )
    entry_access: Optional[AccessRestrictions] = Field(
        None, title="Access restrictions"
    )


class Tool(Item):
    """
    Item that participates as a utility (almost) unchanged in a process
    """

    type: Optional[Any] = ["Category:OSWe427aafafbac4262955b9f690a83405d"]
    purposes: Optional[List[str]] = Field(None, title="Purpose(s)")
    typical_process: Optional[List[str]] = Field(None, title="Typical Process(es)")
    components: Optional[List[Component]] = Field(None, title="Components")
    """
    Component are permanent parts of a tool (vs. Slots for exchangeable parts).
    """
    slots: Optional[List[Slot]] = Field(None, title="Slot configuration")
    """
    Slots represent spaces for exchangable parts or components of a tool (vs. Components, which are permanent parts). Slot exchange events can be used to document changes on slots. This is the initial slot configuration!
    """
    events: Optional[List[str]] = Field(None, title="Event(s)")


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Tool.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  Term.json


from typing import Any

from opensemantic import OswBaseModel


class Model(OswBaseModel):
    __root__: Any


# generated by datamodel-codegen:
#   filename:  OSW69f251a900944602a08d1cca830249b5.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class DataType(str, Enum):
    """
    see https://www.semantic-mediawiki.org/wiki/Help:List_of_datatypes
    """

    Annotation_URI = "Annotation URI"
    Boolean = "Boolean"
    Email = "Email"
    Number = "Number"
    Page = "Page"
    Temperature = "Temperature"
    Text = "Text"
    URL = "URL"
    Date = "Date"
    Code = "Code"
    Telephone_number = "Telephone number"
    Quantity = "Quantity"
    Record = "Record"
    Monolingual_text = "Monolingual text"
    External_identifier = "External identifier"
    Reference = "Reference"
    Keyword = "Keyword"
    Geographic_coordinates = "Geographic coordinates"


class Relation(OswBaseModel):
    inverse_of: str = Field(..., title="Property")
    """
    Property to use in this relation
    """


class Property(Entity):
    """
    The named relation between a subject and an object
    """

    imported_from: Optional[str] = Field(
        None, example="schema:Person", title="Imported from"
    )
    """
    A prefixed IRI defining this entry as a imported term. In OSW the prefix must be a registered imported ontology.
    """
    name: Any
    """
    For properties this value is the primary identifier.
    """
    property_type: Optional[DataType] = Field(DataType.Page, title="Data type")
    """
    see https://www.semantic-mediawiki.org/wiki/Help:List_of_datatypes
    """
    allowed_value: Optional[List[str]] = Field(None, title="Allowed values")
    ontology_iri: Optional[List[str]] = Field(None, title="Ontology IRI(s)")
    """
    e. g. from https://www.qudt.org/doc/DOC_VOCAB-QUANTITY-KINDS.html
    """
    ontologies: Optional[List[str]] = Field(None, title="Ontologies")
    """
    Ontologies that contain this term
    """
    subproperty_of: Optional[List[str]] = Field(None, title="Subproperty of")
    inverse_of: Optional[List[str]] = Field(None, title="Inverse of")
    type: Optional[List[str]] = Field(["Category:Property"], title="Type/Category")
    """
    see also https://www.w3.org/TR/owl2-syntax/#Object_Properties
    """
    see_also: Optional[List[str]] = Field(None, title="See also")
    """
    External reference
    """
    relations: Optional[List[Relation]] = Field(None, title="Relations")
    """
    Relations of this property to other properties, instances or literals (OWL Restrictions)
    """


class QuantityProperty(Property):
    """
    Property that represents a physical quantity
    """

    property_type: Optional[Any] = "Quantity"
    type: Optional[Any] = ["Category:QuantityProperty"]


class SubQuantityProperty(QuantityProperty):
    """
    Is the sub-property of a main quantity or other sub-quantity and inherits its valid units. Can define a subset of input and display units from it.
    """

    subproperty_of: str = Field(..., title="Subquantity of")
    base_property: str = Field(..., title="Base quantity")
    display_units: Optional[Set[str]] = Field(None, min_items=1, title="Display units")
    input_units: Optional[Set[str]] = Field(None, min_items=1, title="Input units")
    type: Optional[Any] = ["Category:OSW69f251a900944602a08d1cca830249b5"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
QuantityProperty.update_forward_refs()
SubQuantityProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  AnnotationProperty.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class AnnotationProperty(Property):
    """
    To annotate classes and individuals
    """

    property_type: Optional[Any] = "Text"
    type: Optional[Any] = ["Category:AnnotationProperty"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
AnnotationProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWc5d4829ed2744a219ba027171c75fa1d.json


from enum import Enum
from typing import Any, Dict, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class Status(str, Enum):
    Item_OSWaa8d29404288446a9f3ec7afa4e2a512 = (
        "Item:OSWaa8d29404288446a9f3ec7afa4e2a512"
    )
    Item_OSWa2b4567ad4874ea1b9adfed19a3d06d1 = (
        "Item:OSWa2b4567ad4874ea1b9adfed19a3d06d1"
    )
    Item_OSWf474ec34b7df451ea8356134241aef8a = (
        "Item:OSWf474ec34b7df451ea8356134241aef8a"
    )


class Process(Item):
    """
    Members of the Process Category describe the act of changing the state or properties of something
    """

    type: Optional[Any] = ["Category:OSWe5aa96bffb1c4d95be7fbd46142ad203"]
    creator: Optional[str] = Field(None, title="Creator")
    actionees: Optional[List[str]] = Field(None, title="Actionees")
    start_date_time: Optional[str] = Field(None, title="Start time")
    end_date_time: Optional[str] = Field(None, title="End time")
    location: Optional[str] = Field(None, title="Location")
    location_name: Optional[str] = Field(None, title="Location (text)")
    """
    Its prefered to select or create a location from or in the autocomplete field 'Location'.
    """
    status: Optional[Status] = Field(None, title="Status")
    tool: Optional[List[str]] = Field(None, title="Tools")
    input: Optional[List[str]] = Field(None, title="Inputs")
    output: Optional[List[str]] = Field(None, title="Outputs")
    projects: Optional[List[str]] = Field(None, title="Project(s)")
    parameters: Optional[Dict[str, Any]] = Field(None, title="Parameters")


class Task(Process):
    type: Optional[Any] = ["Category:OSWc5d4829ed2744a219ba027171c75fa1d"]
    conclusion: Optional[List[Label]] = Field(None, min_items=1, title="Conclusion")
    """
    A brief final summary that highlights the key results or insights of a task.
    """
    issue_label: Optional[List[str]] = Field(None, title="Issue Label")
    """
    Designated to categorize task, which are considered issues in software development.
    """
    prio: Optional[str] = Field(None, title="Priority")
    """
    Bitte wählen. Falls Priorität (noch) nicht gesetzt werden kann, oder zur Diskussion steht, bitte freilassen.
    """
    related_to: Optional[List[str]] = Field(None, title="Related to")
    related_to_project: Optional[List[str]] = Field(None, title="Related to project")
    belongs_to_project: Optional[List[str]] = Field(None, title="Belongs to (project)")
    """
    Project to which this task belongs.
    """
    superordinate_work_package: Optional[List[str]] = Field(
        None, title="Superordinate work package(s)"
    )
    superordinate_task: Optional[List[str]] = Field(None, title="Superordinate task(s)")
    prerequisite_task: Optional[List[str]] = Field(None, title="Prerequisite task(s)")


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Process.update_forward_refs()
Task.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW9725d7a91bab4f1aa68f423e4e9bfcf4.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class IntangibleItem(Item):
    """
    A utility class that serves as the umbrella for a number of 'intangible' things such as terms, quantities, structured values, etc.
    """

    type: Optional[Any] = ["Category:OSWcbb09a36336740c6a2cd62db9bf647ec"]


class Enumeration(IntangibleItem):
    """
    Lists or enumerations—for example, a list of cuisines or music genres, etc.
    """

    type: Optional[Any] = ["Category:OSWd02741381aaa4709ae0753a0edc341ce"]


class StatusEnumeration(Enumeration):
    """
    Lists or enumerations dealing with status types.
    """

    type: Optional[Any] = ["Category:OSW2c32802be59040248c85eda3479d484c"]


class TaskStatus(StatusEnumeration):
    """
    State of a task.
    """

    type: Optional[Any] = ["Category:OSW9725d7a91bab4f1aa68f423e4e9bfcf4"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
Enumeration.update_forward_refs()
StatusEnumeration.update_forward_refs()
TaskStatus.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW05b244d0a669436e96fe4e1631d5a171.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class Data(Item):
    type: Optional[Any] = ["Category:OSW2ac4493f8635481eaf1db961b63c8325"]


class File(Data):
    type: Optional[Any] = ["Category:OSWff333fd349af4f65a69100405a9e60c7"]
    creator: Optional[List[str]] = Field(None, title="Creator")
    editor: Optional[List[str]] = Field(None, title="Editor")
    creation_context: Optional[List[str]] = Field(None, title="Creation Context")
    editing_context: Optional[List[str]] = Field(None, title="Editing Context")
    local_path: Optional[str] = Field(None, title="Local Path")
    """
    The local file path of a file, e.g. S:....
    """


class RemoteFile(File):
    """
    A file stored on a remote location, e. g. on a web server
    """

    type: Optional[Any] = ["Category:OSW05b244d0a669436e96fe4e1631d5a171"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Data.update_forward_refs()
File.update_forward_refs()
RemoteFile.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW09f6cdd54bc54de786eafced5f675cbe.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class DefinedTerm(IntangibleItem):
    """
    Definition of a noun or compound word describing a specific concept
    """

    type: Optional[Any] = ["Category:OSWa5812d3b5119416c8da1606cbe7054eb"]


class Keyword(DefinedTerm):
    """
    Used as a user defined tag to label entitites
    """

    type: Optional[Any] = ["Category:OSW09f6cdd54bc54de786eafced5f675cbe"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
DefinedTerm.update_forward_refs()
Keyword.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW3e3f5dd4f71842fbb8f270e511af8031.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class LocalFile(File):
    """
    A file stored on a local file system
    """

    type: Optional[Any] = ["Category:OSW3e3f5dd4f71842fbb8f270e511af8031"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Data.update_forward_refs()
File.update_forward_refs()
LocalFile.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW5f0dff1c477e45e7ad45e4e247e28f35.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class DocumentationExtension(Item):
    """
    Instances of this category can be used to extend the documentation of a page. Instances select a Category page to be extended by its content. Category pages in turn, within their footer, invoke a query on pages with the Property:ExtendsDocumentationOf pointing to them.
    """

    type: Optional[Any] = ["Category:OSW5f0dff1c477e45e7ad45e4e247e28f35"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
DocumentationExtension.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWff333fd349af4f65a69100405a9e60c7.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Data.update_forward_refs()
File.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWe5aa96bffb1c4d95be7fbd46142ad203.json


from enum import Enum
from typing import Any, Dict, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Process.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  QuantityProperty.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
QuantityProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWa5812d3b5119416c8da1606cbe7054eb.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
DefinedTerm.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW2c32802be59040248c85eda3479d484c.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
Enumeration.update_forward_refs()
StatusEnumeration.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  DataProperty.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class DataProperty(Property):
    property_type: Optional[Any] = "Text"
    type: Optional[Any] = ["Category:DataProperty"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
DataProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW2ac4493f8635481eaf1db961b63c8325.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Data.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWcbb09a36336740c6a2cd62db9bf647ec.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSWd02741381aaa4709ae0753a0edc341ce.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
Enumeration.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  Category.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class Category(Entity):
    type: Optional[List[str]] = Field(
        ["Category:Category"], min_items=1, title="Types/Categories"
    )
    rdf_class: Optional[Set[str]] = Field(None, title="RDF type(s) of the category")
    """
    Declares additional type(s) for this category, e.g., to state that this category has the same meaning as a term in a controlled vocabulary or ontology. This property is synonymous to the schema:additionalType and owl:sameAs. The default syntax is ontology:TermName. The ontology prefix has to be defined in the @context of the Category, the meta category or any of the parent meta categories. The term name has to be a valid identifier in the ontology.
    """
    instance_rdf_type: Optional[Set[str]] = Field(
        None, title="RDF type(s) of instances"
    )
    """
    References a class/type/category in another ontology to describe the instances of this category. Typically a prefix, representing the resolvable URI of an ontology and an id from the namespace of said ontology, separated by colon, e.g., "schema:Person"
    """
    subclass_of: Optional[List[str]] = Field(
        ["Category:Entity"], title="Supercategories"
    )
    metaclass: Optional[List[str]] = Field(None, title="Metaclasses/-categories")
    utf8_icon: Optional[List[constr(min_length=1, max_length=2)]] = Field(
        None, title="UTF8-Icons"
    )
    """
    see https://www.unicode.org/cldr/charts/latest/annotations/romance.html
    """


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Category.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  ObjectProperty.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class ObjectProperty(Property):
    """
    The named relation between a subject and an object
    """

    property_type: Optional[Any] = "Page"
    type: Optional[Any] = ["Category:ObjectProperty"]
    range: Optional[List[str]] = Field(None, title="Value range")
    """
    Enables autocomplete support by lookup all elements that are at least in one of the listed categories. Currently only a single category is supprted.
    """


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
ObjectProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW1b15ddcf042c4599bd9d431cbfdf3430.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class MainUnit(OswBaseModel):
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    name: str = Field(..., title="Name")
    """
    Technical / Machine compatible name
    """
    main_symbol: str = Field(..., title="Symbol")
    alternative_symbols: Optional[List[str]] = Field(None, title="Alternative symbols")
    codes: Optional[List[str]] = Field(None, title="Unit codes")
    """
    e.g. UN/CEFACT Common Code (measurement units), ISO 4217 (currencies)
    """
    use_as_input_unit: Optional[bool] = None
    use_as_display_unit: Optional[bool] = None
    ontology_iri: Optional[List[str]] = Field(None, title="Ontology IRI(s)")
    """
    e. g. from https://www.qudt.org/doc/DOC_VOCAB-UNITS.html
    """


class Unit(MainUnit):
    conversion_factor_to_main_unit: Optional[str] = None


class MainQuantityProperty(QuantityProperty):
    """
    Defines valid units for itself and all of its subquantities
    """

    main_unit: Optional[MainUnit] = Field(None, title="Main unit")
    additional_units: Optional[List[Unit]] = Field(None, title="Units")
    proportional_to: Optional[List[str]] = Field(None, title="Proportional to")
    """
    Related quantity which units are in the numerator of the units of this quantity
    """
    inverse_proportional_to: Optional[List[str]] = Field(
        None, title="Inverse proportional to"
    )
    """
    Related quantity which units are in the denominator of the units of this quantity
    """
    type: Optional[Any] = ["Category:OSW1b15ddcf042c4599bd9d431cbfdf3430"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
QuantityProperty.update_forward_refs()
MainQuantityProperty.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW11a53cdfbdc24524bf8ac435cbf65d9d.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class WikiFile(RemoteFile):
    """
    A file stored directy in the file namespace
    """

    type: Optional[Any] = ["Category:OSW11a53cdfbdc24524bf8ac435cbf65d9d"]
    file: Optional[str] = Field(None, title="File")


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
Data.update_forward_refs()
File.update_forward_refs()
RemoteFile.update_forward_refs()
WikiFile.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  Property.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Property.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  Item.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel

Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW65c8449bdd4f4fbcb7f68203a11d6e8f.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class Priority(Enumeration):
    type: Optional[Any] = ["Category:OSW65c8449bdd4f4fbcb7f68203a11d6e8f"]


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
IntangibleItem.update_forward_refs()
Enumeration.update_forward_refs()
Priority.update_forward_refs()
# generated by datamodel-codegen:
#   filename:  OSW37a57741ae2e4dd4b29b1172b6848be8.json


from enum import Enum
from typing import Any, List, Optional, Set, Union
from uuid import UUID

from pydantic.v1 import Field, constr

from opensemantic import OswBaseModel


class OtherPhysicalItem(OswBaseModel):
    uuid: str
    origin_item_type: Optional[str] = Field(
        "Category:OSW37a57741ae2e4dd4b29b1172b6848be8", title="Type"
    )
    origin_item_instance_property: Optional[str] = "Property:HasOrigin"
    origin_item_instance: str = Field(..., title="Instance")


class Quantity(OswBaseModel):
    uuid: UUID = Field(default_factory=uuid4, title="UUID")
    quantity: str = Field(..., title="Property")
    numerical_value: str = Field(..., title="Value")
    unit: str = Field(..., title="Unit")
    unit_symbol: str
    value: str = Field(..., title="Value")


class FileS(OswBaseModel):
    __root__: Set[str] = Field(..., title="File(s)")


class SafetyDataSheet(OswBaseModel):
    pass


class Manual(OswBaseModel):
    """
    Comprehensive guide that details how to use this item.
    """


class Instructions(OswBaseModel):
    """
    A list of steps to be performed, e.g., the setup instructions.
    """


class DataSheet(SafetyDataSheet):
    pass


class PhysicalItem(Item):
    """
    Physical item as opposed to intangible item. It can posses properties such as position, geometry, weight, volume , etc.
    """

    type: Optional[Any] = ["Category:OSW37a57741ae2e4dd4b29b1172b6848be8"]
    quantity_statements: Optional[List[Quantity]] = Field(
        None, title="Quantitative statement(s)"
    )
    origin: Optional[List[OtherPhysicalItem]] = Field(None, title="Origin")
    """
    Other physical item(s) that this physical item was derived from.
    """
    type_no: Optional[str] = Field(None, title="Type number")
    """
    Type or model number as specified by the manufacturer
    """
    manufacturer: Optional[str] = Field(None, title="Manufacturer")
    """
    The manufacturer of this item - an organization(al unit).
    """
    data_sheet: Optional[DataSheet] = None
    safety_data_sheet: Optional[SafetyDataSheet] = None
    manual: Optional[Manual] = None
    instructions: Optional[Instructions] = None


Entity.update_forward_refs()
ObjectStatement.update_forward_refs()
DataStatement.update_forward_refs()
QuantityStatement.update_forward_refs()
Item.update_forward_refs()
PhysicalItem.update_forward_refs()

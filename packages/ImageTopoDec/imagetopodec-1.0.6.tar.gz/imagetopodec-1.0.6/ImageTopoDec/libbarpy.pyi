import numpy
import typing
from typing import ClassVar, overload

__version__: str

class AttachMode:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    createNew: ClassVar[AttachMode] = ...
    dontTouch: ClassVar[AttachMode] = ...
    firstEatSecond: ClassVar[AttachMode] = ...
    morePointsEatLow: ClassVar[AttachMode] = ...
    secondEatFirst: ClassVar[AttachMode] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class Bar3dvalue:
    count: int
    value: Barscalar
    def __init__(self, *args, **kwargs) -> None: ...

class BarConstructor:
    def __init__(self) -> None: ...
    def addStructure(self, ProcType: ProcType, ColorType: ColorType, ComponentType: ComponentType) -> None: ...

class BarType:
    __members__: ClassVar[dict] = ...  # read-only
    BYTE8_1: ClassVar[BarType] = ...
    BYTE8_3: ClassVar[BarType] = ...
    FLOAT32_1: ClassVar[BarType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class Barcontainer:
    def __init__(self, *args, **kwargs) -> None: ...
    def addItem(self, Baritem: Baritem) -> None: ...
    def clone(self, *args, **kwargs): ...
    def count(self) -> int: ...
    def getItem(self, index: typing.SupportsInt) -> Baritem: ...
    def maxLen(self) -> Barscalar: ...
    def preprocessBarcode(self, threshold: Barscalar, normalize: bool) -> None: ...
    def relength(self) -> None: ...
    def removeByThreshold(self, threshold: Barscalar) -> None: ...
    def sum(self) -> Barscalar: ...
    def __len__(self) -> int: ...

class Baritem:
    def __init__(self, *args, **kwargs) -> None: ...
    def SortByLineLen(self) -> None: ...
    def SortByPointsCount(self) -> None: ...
    def calcHistByBarlen(self) -> list: ...
    def clone(self) -> Baritem: ...
    def cmp(self, bitem: Baritem, CompareStrategy: CompareStrategy) -> float: ...
    def compareBestRes(self, bitem: Baritem, CompareStrategy: CompareStrategy) -> float: ...
    def compareOccurrence(self, bitem: Baritem, CompareStrategy: CompareStrategy) -> float: ...
    def getBarcodeLines(self) -> list[Barline]: ...
    def getBettyNumbers(self) -> list: ...
    def getRootNode(self) -> Barline: ...
    def maxLen(self) -> Barscalar: ...
    def normalize(self) -> None: ...
    def preprocessBarcode(self, arg0: Barscalar, arg1: bool) -> None: ...
    def relength(self) -> None: ...
    def removeByThreshold(self, arg0: Barscalar) -> None: ...
    def sum(self) -> Barscalar: ...
    def __len__(self) -> int: ...

class Barline:
    def __init__(self, *args, **kwargs) -> None: ...
    def compare3dbars(self, arg0: Barline, arg1: CompareStrategy) -> float: ...
    def depth(self) -> int: ...
    def end(self) -> Barscalar: ...
    def get3dList(self) -> list: ...
    def get3dSize(self) -> int: ...
    def get3dValue(self, arg0: typing.SupportsInt) -> Bar3dvalue: ...
    def getBettyNumbers(self) -> list: ...
    def getChildren(self) -> list: ...
    def getMatrixSize(self) -> int: ...
    def getMatrixValue(self, arg0: typing.SupportsInt) -> MatrixValue: ...
    def getParent(self) -> Barline: ...
    def getPoints(self, skipChildPoints: bool = ...) -> list: ...
    def getRect(self) -> list: ...
    def id(self) -> int: ...
    def len(self) -> Barscalar: ...
    def parentId(self) -> int: ...
    def start(self) -> Barscalar: ...
    def __len__(self) -> int: ...

class Barscalar:
    @overload
    def __init__(self, arg0: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsFloat, arg1: BarType) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsInt, arg1: BarType) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt, arg2: typing.SupportsInt, arg3: typing.SupportsInt) -> None: ...
    def absDiff(self, arg0: Barscalar) -> Barscalar: ...
    def getAvgFloat(self) -> float: ...
    def getAvgUchar(self) -> int: ...
    def getByte8(self) -> int: ...
    def getFloat(self) -> float: ...
    def getRGB(self, arg0: typing.SupportsInt) -> int: ...
    def value(self) -> tuple: ...
    def __add__(self, arg0: Barscalar) -> Barscalar: ...
    def __eq__(self, arg0: Barscalar) -> bool: ...
    def __ge__(self, arg0: Barscalar) -> bool: ...
    def __gt__(self, arg0: Barscalar) -> bool: ...
    def __le__(self, arg0: Barscalar) -> bool: ...
    def __lt__(self, arg0: Barscalar) -> bool: ...
    def __mul__(self, arg0: Barscalar) -> Barscalar: ...
    def __ne__(self, arg0: Barscalar) -> bool: ...
    def __sub__(self, arg0: Barscalar) -> Barscalar: ...
    def __truediv__(self, arg0: Barscalar) -> Barscalar: ...

class ColorType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    gray: ClassVar[ColorType] = ...
    native: ClassVar[ColorType] = ...
    rgb: ClassVar[ColorType] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class CompareStrategy:
    __members__: ClassVar[dict] = ...  # read-only
    CommonToLen: ClassVar[CompareStrategy] = ...
    CommonToSum: ClassVar[CompareStrategy] = ...
    __entries: ClassVar[dict] = ...
    compare3d: ClassVar[CompareStrategy] = ...
    compare3dBrightless: ClassVar[CompareStrategy] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class ComponentType:
    __members__: ClassVar[dict] = ...  # read-only
    Component: ClassVar[ComponentType] = ...
    Hole: ClassVar[ComponentType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class MatrixValue:
    value: Barscalar
    x: int
    y: int
    def __init__(self) -> None: ...
    def getIndex(self) -> int: ...

class Point:
    x: int
    y: int
    def __init__(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None: ...

class PointMutator:
    absolute: float
    local: float
    offset: float
    def __init__(self) -> None: ...
    def convert(self, arg0: typing.SupportsFloat) -> float: ...

class ProcType:
    __members__: ClassVar[dict] = ...  # read-only
    Radius: ClassVar[ProcType] = ...
    __entries: ClassVar[dict] = ...
    f0t255: ClassVar[ProcType] = ...
    f255t0: ClassVar[ProcType] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class ReturnType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    barcode2d: ClassVar[ReturnType] = ...
    barcode3d: ClassVar[ReturnType] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self): ...
    @property
    def value(self) -> int: ...

class barstruct:
    attachMode: AttachMode
    colorRange: int
    coltype: ColorType
    comtype: ComponentType
    createBinaryMasks: bool
    createGraph: bool
    killOnMaxLen: bool
    maskValueId: int
    maxRadius: float
    proctype: ProcType
    returnType: ReturnType
    trueSort: bool
    def __init__(self) -> None: ...
    def setMaxLen(self, val: typing.SupportsFloat) -> None: ...

def convert_las_points_to_dict(arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray) -> dict: ...
def create(arg0: numpy.ndarray, arg1: barstruct) -> Baritem: ...
def createByMask(arg0: numpy.ndarray, arg1: barstruct, arg2: numpy.ndarray) -> Baritem: ...
def createMultiple(arg0: numpy.ndarray, arg1: BarConstructor) -> Barcontainer: ...
def find_contour(arg0: Barline, arg1: PointMutator, arg2: PointMutator, arg3: bool) -> list: ...

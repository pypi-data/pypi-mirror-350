---
title: Research Report: CI Enforcement and Prompt Modification (Issue #104)
by: khive-researcher
created: 2025-05-22
updated: 2025-05-22
version: 1.5
doc_type: RR
output_subdir: rr
description: Research report evaluating proposals for CI enforcement and prompt modification as per Issue #104.
date: 2025-05-22
author: @khive-researcher
issue_link: https://github.com/khive-ai/khive.d/issues/104
---

# Research Report: CI Enforcement and Prompt Modification (Issue #104)

## Executive Summary

This research report evaluates proposals from Issue #104 aimed at enhancing CI
enforcement and `khive` CLI integration. Key findings support the feasibility
and benefits of:

1. A unified, modular `ci.sh` script for consistent local and GitHub Actions
   execution.
2. An enhanced `khive ci` command featuring iterative `pre-commit` auto-fixing
   (with loop detection and performance optimizations) and a "stamp of approval"
   mechanism (a git-ignored local file like `.khive/ci_status.json` containing
   verifiable success state) to gate `khive commit` and `khive pr`.
3. Systematic prompt engineering for Khive modes to prioritize `khive` CLI tool
   usage over direct MCP calls, thereby improving workflow consistency and
   potentially reducing API reliance.
4. Strategies to further reduce GitHub MCP reliance by strengthening local CLI
   tools with caching and optimized data handling.

The primary recommendations advocate for a phased implementation of these
features. This includes developing the `ci.sh` script, incrementally building
the enhanced `khive ci` with iterative auto-fixing and the stamp of approval,
and systematically refining AI prompts. While development effort is moderate to
high for some components, the overall impact is expected to be significantly
positive, leading to improved code quality, faster developer feedback, a better
developer experience, and more efficient use of resources. Risks include
potential developer friction if new checks are too slow or rigid, and increased
complexity in local tooling, which can be mitigated by careful design,
performance optimization, and providing override mechanisms. _A concise (2-3
paragraph) summary of key findings and recommendations, highlighting the main
takeaways. This will be filled in as research progresses._

## 1. Introduction

### 1.1 Research Objective

This research aims to evaluate the proposals outlined in Issue #104 concerning
the improvement of CI enforcement and `khive` CLI integration. The primary goals
are to investigate the feasibility of a unified CI script, enhancements to
`khive ci`, modifications to Khive mode prompts for better CLI adherence, and
the potential to reduce reliance on the GitHub MCP server. The final output will
be this report (`RR-104.md`) with actionable recommendations.

### 1.2 Methodology

The research methodology involves:

1. Reviewing the proposals in Issue #104.
2. Conducting targeted searches using `khive info search --provider perplexity`
   for each key research area.
3. Leveraging deep research documents provided by the user for specific topics.
4. Analyzing search results and research documents to extract best practices,
   pros, cons, and technical considerations.
5. Synthesizing findings into this report, with inline citations for all claims.
6. Developing recommendations based on the evidence gathered.

### 1.3 Context

The proposals in Issue #104 aim to streamline development workflows, improve
local development consistency with CI processes, and potentially reduce external
dependencies by enhancing the capabilities and usage of local `khive` CLI tools.
This aligns with the project's goal of efficient and robust development
practices.

## 2. Technical Analysis

### 2.1 Unified CI Script (`ci.sh`)

**Objective:** Research best practices for creating a common CI script usable by
both a local `khive ci` command and GitHub Actions.

**Findings:** A common CI script, typically a shell script (e.g., `ci.sh`), can
promote consistency between local development environments and the CI/CD
pipeline.

**Best Practices & Structure:**

- **Modularity:** Divide the script into distinct functions or stages (e.g.,
  `setup_env`, `lint`, `test`, `build`, `deploy`). This allows for selective
  execution and easier maintenance. For example, `khive ci` could call specific
  functions, while GitHub Actions could call the entire script or specific
  stages. (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7, [1][5])
  ```bash
  #!/bin/bash
  # ci.sh

  setup_env() {
    echo "Setting up environment..."
    # e.g., install dependencies
  }

  lint() {
    echo "Running linters..."
    # e.g., pre-commit run --all-files
  }

  test() {
    echo "Running tests..."
    # e.g., pytest
  }

  # Main execution logic
  case "$1" in
    setup)
      setup_env
      ;;
    lint)
      lint
      ;;
    test)
      test
      ;;
    all)
      setup_env
      lint
      test
      ;;
    *)
      echo "Usage: $0 {setup|lint|test|all}"
      exit 1
      ;;
  esac
  ```
- **Error Handling:** Implement robust error handling using `set -euo pipefail`
  at the beginning of the script. This ensures that the script exits immediately
  if a command fails, an unset variable is used, or a command in a pipeline
  fails. (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7, [5])
- **Environment Detection:** The script should be able to detect whether it's
  running in a local environment or a CI environment (e.g., by checking for
  CI-specific environment variables like `CI`, `GITHUB_ACTIONS`). This allows
  for conditional logic, such as skipping interactive prompts in CI.
  (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7, [1])
  ```bash
  if [[ -n "$GITHUB_ACTIONS" ]]; then
    echo "Running in GitHub Actions CI environment."
    # CI-specific logic
  else
    echo "Running in local environment."
    # Local-specific logic
  fi
  ```
- **Parameterization:** Allow parameters to be passed to the script to control
  its behavior (e.g., `./ci.sh --stage=test`, or `./ci.sh test`). This is
  crucial for flexibility.
- **Idempotency:** Design script stages to be idempotent where possible, meaning
  running them multiple times produces the same result.
- **Logging:** Implement clear and consistent logging to help debug issues both
  locally and in CI.
- **Tooling Checks:** Ensure necessary tools (linters, test runners) are
  installed or provide clear instructions/scripts to install them.
- **GitHub Actions Integration:** The GitHub Actions workflow would simply call
  this script.
  ```yaml
  # .github/workflows/main.yml
  name: CI

  on: [push, pull_request]

  jobs:
    build_and_test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - name: Run CI script
          run: |
            chmod +x ./ci.sh
            ./ci.sh all
  ```
  It's also recommended to integrate tools like `shellcheck` and `shfmt` into
  the CI pipeline to validate the CI script itself.
  (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7, [3])

**Pros:**

- **Consistency (DRY):** Ensures the same checks and processes run locally and
  in CI, reducing "works on my machine" issues.
- **Simplified CI Configuration:** GitHub Actions workflows become simpler,
  primarily just invoking the script.
- **Faster Local Feedback:** Developers can run the exact CI process locally
  before pushing, saving time and CI resources.
- **Easier Maintenance:** Logic is centralized in one script rather than
  scattered across CI configuration files and local developer habits.

**Cons:**

- **Script Complexity:** The script itself can become complex if it needs to
  handle many different scenarios or operating systems (though for Khive,
  targeting macOS/Linux via shell script is reasonable).
- **Dependency Management:** The script needs to manage its own dependencies or
  assume they are present in the environment.
- **Shell Scripting Limitations:** For very complex workflows, shell scripting
  might become cumbersome compared to specialized CI tools or languages.

### 2.2 Enhanced `khive ci`

**Objective:** Investigate the feasibility of `khive ci` automatically running
`pre-commit` multiple times and explore mechanisms for a "stamp of approval" to
verify a successful `khive ci` run.

**Findings (Synthesized from Claude, ChatGPT, and Gemini Deep Research
[11][12][13]):**

#### Iterative `pre-commit` Auto-Fixing

Running `pre-commit` iteratively can help resolve issues that require multiple
passes (e.g., a formatter fixing code that then allows a linter to pass, or
chained fixes).

- **Implementation Strategy:**
  - `khive ci` should orchestrate multiple runs of `pre-commit run --all-files`
    (or targeted files after the first pass). (Gemini Deep Research, RR-104/003,
    Sec II.A)
  - A hybrid approach is recommended: run until convergence (no files modified
    by hooks) but cap at a maximum number of iterations (e.g., 3-5) to prevent
    excessive runtimes and handle non-converging scenarios. (Claude Deep
    Research, RR-104/001, Sec 1.1; Gemini Deep Research, RR-104/003, Sec II.A)
  - After the initial `pre-commit run --all-files`, subsequent iterations can be
    optimized by targeting only the files reported as modified in the previous
    pass (`pre-commit run --files <list_of_modified_files>`). (Gemini Deep
    Research, RR-104/003, Sec II.A, II.C)

- **Loop Detection & Conflicting Hooks:**
  - **Maximum Iterations:** The simplest loop prevention is a hard cap on
    iterations. (Claude Deep Research, RR-104/001, Sec 1.1; Gemini Deep
    Research, RR-104/003, Sec II.B)
  - **Content Hashing / State Comparison:** To detect actual loops where hooks
    undo each other's changes, compare the state of files across iterations.
    This can be done by hashing all relevant file contents after each run and
    checking if a previous state repeats. (Claude Deep Research, RR-104/001, Sec
    1.2; ChatGPT Deep Research, RR-104/002, Iterative Pre-commit; Gemini Deep
    Research, RR-104/003, Sec II.B)
  - **Handling Loops:** If a loop is detected or max iterations are reached
    without convergence, `khive ci` should halt, report the issue clearly
    (listing involved files/hooks if possible), and not create a "stamp of
    approval." (Gemini Deep Research, RR-104/003, Sec II.B)
  - **Preventing Conflicts:** Encourage proper hook configuration (e.g., `isort`
    with Black profile), hook ordering, and using consolidated tools like Ruff
    to minimize conflicts. (Gemini Deep Research, RR-104/003, Sec II.B)

- **Performance Considerations:**
  - Iterative runs add overhead. Performance is critical for adoption. (Gemini
    Deep Research, RR-104/003, Sec II.C)
  - Leverage `pre-commit`'s own environment caching and individual tool caches
    (e.g., ESLint's `--cache`, Ruff's built-in caching). (ChatGPT Deep Research,
    RR-104/002, Iterative Pre-commit; Gemini Deep Research, RR-104/003, Sec
    II.C)
  - The optimization of running only on modified files in subsequent iterations
    helps. (Gemini Deep Research, RR-104/003, Sec II.C)

#### "Stamp of Approval" / Local State Persistence

A "stamp of approval" signifies that `khive ci` (including all checks and
auto-fixes) has run successfully on the current code state.

- **Mechanism:**
  - A project-local, git-ignored cache file (e.g., `.khive/ci_status.json` or
    `.khive/.ci_success_stamp`) is the most recommended approach. It balances
    simplicity, discoverability by other `khive` tools, and persistence. (Claude
    Deep Research, RR-104/001, Sec 2.2; ChatGPT Deep Research, RR-104/002, Stamp
    of Approval; Gemini Deep Research, RR-104/003, Sec III.A, IV.B)
  - Git notes are an alternative for tying approval to specific commits but are
    more complex to manage for this ephemeral, local-only use case and have
    discoverability issues. (Claude Deep Research, RR-104/001, Sec 2.2; ChatGPT
    Deep Research, RR-104/002, Stamp of Approval; Gemini Deep Research,
    RR-104/003, Sec III.A)

- **Content of the Stamp (e.g., in `.khive/ci_status.json`):**
  - `khiveCiVersion`: Version of `khive ci` that generated the stamp.
  - `timestamp`: ISO 8601 timestamp of successful completion.
  - `precommitConfigHash`: SHA256 hash of the `.pre-commit-config.yaml` content.
  - `status`: e.g., "success".
  - `approvedFiles`: An array of objects, each with `path` (string) and `hash`
    (string, Git blob hash of the staged file content that was approved).
    (Gemini Deep Research, RR-104/003, Sec III.B, IV.B)

- **Validation by `khive commit` / `khive pr`:**
  - These commands MUST rigorously validate the stamp.
  - Checks:
    1. Stamp file existence and parseability.
    2. (Optional) `khiveCiVersion` compatibility.
    3. Match current `.pre-commit-config.yaml` hash against
       `precommitConfigHash` in the stamp.
    4. Crucially, compare the list of currently staged files (paths and Git blob
       hashes) against the `approvedFiles` in the stamp. An exact match is
       required. (Gemini Deep Research, RR-104/003, Sec III.C, IV.B)

- **Action on Invalid/Missing Stamp:**
  - Default: Block the `khive commit` or `khive pr` operation.
  - Provide a clear error message and instruct the user to run `khive ci`.
  - Include an override flag (e.g., `--no-verify-khive-ci` or `--force`) for
    exceptional cases. (Claude Deep Research, RR-104/001, Sec 3.2; ChatGPT Deep
    Research, RR-104/002, Stamp of Approval; Gemini Deep Research, RR-104/003,
    Sec III.C, IV.B)

- **Stamp Invalidation:**
  - Primary trigger: Validation failure by `khive commit`/`khive pr` (due to
    changes in staged files or config). The stamp file should be deleted upon
    such invalidation.
  - `khive ci` itself should invalidate/overwrite an old stamp at the beginning
    of a new run if the workspace state has diverged.
  - A manual invalidation command (e.g., `khive ci --clear-stamp`) is useful.
    (ChatGPT Deep Research, RR-104/002, Verifying Stamp Validity; Gemini Deep
    Research, RR-104/003, Sec III.D, IV.B)

### 2.3 Prompt Modification for CLI Enforcement

**Objective:** Analyze how prompts for Khive modes can be modified to guide
users towards `khive` CLI commands instead of direct MCP calls for GitHub
operations, considering token implications.

**Findings:** Effective prompt engineering can significantly influence an AI
model's behavior, guiding it to prefer CLI tools over direct API/MCP calls. This
can enhance local workflow consistency and potentially reduce reliance on
external services for operations where `khive` CLI equivalents exist.

**Best Practices for Prompt Modification:**

- **Explicit Instructions & Constraints:** Clearly state the preference for
  `khive` CLI tools.
  - Example: "When performing Git operations like commit or creating a pull
    request, prioritize using the `khive commit` and `khive pr` commands. Only
    use MCP calls as a fallback if a `khive` CLI command is not available or
    suitable for the specific task." (pplx:25f5b4e3-3431-4835-aff7-7bed67232159,
    [6][8])
- **Role Setting / Persona:** Define the AI's role as an expert user of the
  `khive` CLI.
  - Example: "You are an expert Khive developer. You always prefer using `khive`
    CLI tools for local development tasks and repository interactions. Your
    primary goal is to guide the user to leverage these tools effectively."
    (pplx:25f5b4e3-3431-4835-aff7-7bed67232159, [7])
- **Provide Examples (Few-Shot Prompting):** Include examples in the prompt
  demonstrating the desired behavior.
  - Example:
    ```
    User: I need to commit these changes.
    Assistant: <execute_command><command>khive commit --type feat --scope core --subject "Implement new feature X" --by "@khive-implementer"</command></execute_command>

    User: Let's create a pull request for this branch.
    Assistant: <execute_command><command>khive pr --title "feat(core): Implement new feature X"</command></execute_command>
    ```
    (pplx:25f5b4e3-3431-4835-aff7-7bed67232159, [6][7])
- **System Messages:** Utilize system messages to set overarching rules for tool
  usage. (pplx:25f5b4e3-3431-4835-aff7-7bed67232159, [8])
  - Example (within the mode's system prompt): "Rule: Always prefer `khive` CLI
    commands for tasks like `commit`, `pr`, `new-doc`. If a `khive` command
    exists, use it. Fallback to MCP only if no `khive` command is suitable."
- **Negative Constraints:** Specify what _not_ to do.
  - Example: "Avoid using the GitHub MCP `create_pull_request` tool if
    `khive pr` can achieve the same result."
- **Reinforce with Tool Documentation:** Ensure the AI has access to and is
  prompted to refer to the `khive` CLI documentation (e.g., the rules files like
  `100_khive_cli_guide.md`, `101_khive_commit.md`, etc.).
  - Example: "Before suggesting a GitHub MCP operation, consult the `khive` CLI
    documentation provided in your context to see if a corresponding `khive`
    command exists."
- **Iterative Refinement & Testing:** Test prompt modifications and iterate
  based on observed AI behavior. (pplx:25f5b4e3-3431-4835-aff7-7bed67232159,
  [7])

**Token Implications:**

- Adding explicit instructions, examples, and rules to prompts will increase
  their token count.
- However, successfully guiding the AI to use a concise `khive` CLI command
  (which might be a single tool call) can be more token-efficient than the AI
  formulating a complex multi-parameter MCP call.
- The key is to find a balance. Prioritize adding instructions for the most
  common operations where `khive` CLI tools offer a clear advantage (e.g.,
  `khive commit`, `khive pr`, `khive new-doc`).
- System messages are generally more token-efficient for setting global rules
  than repeating instructions in every user prompt.
- Few-shot examples are effective but add tokens. Use them judiciously for
  critical behaviors.
- Regularly review and optimize prompts to remove redundant phrasing while
  maintaining clarity.

**Considerations for Khive Modes:** The prompt modifications should be tailored
to each Khive mode's specific responsibilities and allowed tools. For instance,
an Implementer mode would receive stronger guidance on `khive commit` and
`khive pr` than a Researcher mode.

### 2.4 Reducing GitHub MCP Reliance

**Objective:** Evaluate the potential to reduce GitHub MCP server reliance by
strengthening local CLI tools and prompt-guided workflows.

**Findings:** Strengthening local CLI capabilities (`khive ci`, `khive commit`,
`khive pr`) and refining AI prompts to prioritize these tools can significantly
reduce the need for direct GitHub MCP interactions for common development tasks.
This shift can lead to benefits like improved local workflow speed, reduced API
rate limit consumption, and potentially offline capabilities for certain
operations.

**Strategies to Reduce MCP Reliance:**

- **Local Caching & Validation:**
  - Implement local caching within `khive` CLI tools for frequently accessed
    GitHub data (e.g., issue details, PR statuses, file contents for specific
    refs). (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c, [16][17])
  - Use conditional requests (e.g., ETag, If-Modified-Since headers) when
    `khive` tools do need to fetch data from GitHub, to avoid transferring
    unchanged data. (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c, [18])
  - This reduces the need for the AI to use MCP `get_issue`, `get_pull_request`,
    or `get_file_contents` if the information can be reliably served from a
    local, validated cache via a `khive` CLI command.

- **Enhanced `khive` CLI for Git Operations:**
  - As `khive commit` and `khive pr` become more robust and feature-rich
    (potentially wrapping more `git` and `gh` functionalities), they become
    stronger alternatives to MCP calls like `create_commit` (if it existed),
    `create_pull_request`, `add_issue_comment` (if `khive pr` could also manage
    comments locally before pushing).
  - The "stamp of approval" from an enhanced `khive ci` (Section 2.2) further
    empowers local validation, reducing the need for pre-flight checks via MCP
    before attempting operations like PR creation.

- **AI Prompt Engineering (as per Section 2.3):**
  - Strongly guide the AI to use `khive` CLI commands for creating/updating
    issues, PRs, branches, and committing files, rather than defaulting to MCP
    tool calls.
  - Prompts can instruct the AI to first check if a `khive` command can perform
    the task before considering an MCP call.

- **Local Preprocessing & Data Aggregation:**
  - For tasks requiring analysis of multiple GitHub resources (e.g., summarizing
    several issues), `khive` tools could fetch the raw data once (or use cached
    data), and the AI could then be prompted to process this locally provided
    data rather than making multiple MCP calls to analyze each resource
    individually. (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c)

- **Rate Limit Awareness in `khive` Tools:**
  - If `khive` tools themselves interact with the GitHub API (e.g., for caching
    or complex operations not covered by `gh`), they should implement strategies
    like exponential backoff and respect rate limits.
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c, [15][18]) This makes them more
    reliable alternatives to direct MCP usage which might hit limits.

**Impact:**

- **Improved Performance:** Local operations are generally faster than remote
  API calls.
- **Reduced API Costs/Rate Limiting:** Fewer calls to GitHub's API.
  (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c, [14][15])
- **Enhanced Offline/Intermittent Connectivity Support:** Some operations could
  potentially be prepared locally even with poor connectivity if data is cached.
- **Simplified AI Logic:** The AI's decision tree might simplify if it's
  strongly biased towards using a known set of powerful local CLI tools.
- **Potential for Increased CLI Complexity:** The `khive` CLI tools would need
  to become more sophisticated to handle caching, validation, and broader GitHub
  interactions.

This approach doesn't necessarily eliminate the GitHub MCP server, as it would
still be valuable for operations not easily replicated by a local CLI (e.g.,
complex searches across repositories, organization-level management tasks) or
for agents that do not have local CLI execution capabilities. However, for core
Khive agent workflows, reliance can be substantially reduced.

### 2.5 Overall Feasibility and Impact

Assessing the collective proposals from Issue #104 regarding CI enforcement and
prompt modifications reveals a generally high degree of technical feasibility
with a significant potential for positive impact on the Khive development
workflow.

**Technical Feasibility:**

- **Unified CI Script (`ci.sh`):** Highly feasible. Shell scripting is a mature
  technology, and structuring a script for modularity and environment detection
  (local vs. GHA) is a common practice.
- **Enhanced `khive ci`:**
  - _Iterative `pre-commit`_: Feasible. Requires a Python wrapper around
    `pre-commit` CLI calls. Loop detection via content hashing is achievable.
  - _"Stamp of Approval"_: Feasible. Implementing a git-ignored JSON file (e.g.,
    `.khive/ci_status.json`) to store success state, config hash, and approved
    file hashes is straightforward. Validation logic in `khive commit`/`pr` is
    also feasible.
- **Prompt Modification:** Highly feasible. This involves careful crafting and
  iterative testing of system prompts and few-shot examples within the existing
  Khive mode definitions.
- **Reducing GitHub MCP Reliance:** Feasible, particularly by strengthening
  `khive` CLI tools as outlined. Adding local caching to `khive` tools for
  GitHub data would be a new development effort but uses standard techniques.

**Development Effort Estimation:**

- **Unified `ci.sh`:** Medium. Involves initial script development, ensuring
  robustness, and integrating calls from `khive ci` and GitHub Actions.
- **Enhanced `khive ci`:**
  - _Iterative `pre-commit`_: Medium. Requires careful implementation of the
    iteration logic, loop detection, and error reporting.
  - _"Stamp of Approval"_: Medium. Involves designing the stamp format,
    implementing its creation by `khive ci`, and robust validation logic within
    `khive commit` and `khive pr`, including handling of edge cases and
    providing clear user feedback.
- **Prompt Modification:** Low to Medium. Primarily involves prompt engineering,
  testing, and refinement. No complex coding is required, but achieving desired
  AI behavior can be iterative.
- **Reducing GitHub MCP Reliance (via CLI enhancements):** Medium to High,
  depending on the extent of caching and new CLI functionalities envisioned
  (e.g., if `khive` tools were to replicate more complex MCP queries locally).

**Potential Benefits:**

- **Improved Code Quality & Consistency:** Stricter local checks (`khive ci`
  with stamp) and a unified CI script ensure code adheres to standards before
  reaching the remote repository.
- **Faster Developer Feedback Loops:** Running comprehensive checks locally is
  faster than waiting for GitHub Actions. Iterative auto-fixing further speeds
  up the linting/formatting process.
- **Enhanced Developer Experience (DX):** Clearer guidance from prompts, more
  reliable local checks, and reduced "it works on my machine" issues.
- **Reduced CI Costs & GitHub API Consumption:** Fewer broken builds in GitHub
  Actions. Shifting some GitHub data access to local `khive` CLI tools with
  caching can reduce API calls.
- **Increased AI Agent Effectiveness:** More directive prompts and reliable
  local tools can lead to AI agents performing tasks more efficiently and
  correctly using the intended `khive` CLI workflows.
- **Streamlined Workflows:** Centralizing CI logic and standardizing local
  checks simplifies the overall development process.

**Potential Drawbacks/Risks:**

- **Initial Development Investment:** Implementing these enhancements,
  particularly for `khive ci`, will require focused development time.
- **Complexity in Local Tooling:** Adding features like iterative `pre-commit`
  and stamp validation makes `khive ci`, `khive commit`, and `khive pr` more
  complex, increasing the surface area for potential bugs or edge cases in the
  tooling itself.
- **Developer Friction if Too Restrictive:** If local checks are overly slow, or
  if the "stamp of approval" mechanism is too rigid without sensible overrides,
  it could lead to developer frustration and attempts to bypass the system.
  Performance of iterative `pre-commit` is a key concern.
- **Maintenance Overhead:** The new `ci.sh` and enhanced `khive` CLI features
  will require ongoing maintenance.
- **Token Cost for Prompts:** While aiming for overall efficiency, more detailed
  directive prompts will have a slightly higher token cost per call, which needs
  to be monitored.

Overall, the proposed enhancements are technically sound and promise substantial
improvements to the Khive development lifecycle. The primary challenge lies in
careful implementation to balance robustness with developer experience and
performance. A phased approach to implementation would be advisable.

## 3. Implementation Patterns

_(To be filled based on further research and specific recommendations adopted)_

### 3.1 Architecture Patterns

_(Placeholder for diagrams or descriptions of how these systems might interact)_

### 3.2 Code Examples

_(Placeholder for key code snippets if specific implementations are prototyped
or detailed)_

### 3.3 Error Handling Strategy

_(Placeholder for error handling considerations for the new CLI features)_

### 3.4 Testing Approach

_(Placeholder for how to test the new CI script and `khive ci` enhancements)_

## 4. Integration Considerations

_(To be filled based on further research and specific recommendations adopted)_

### 4.1 Dependencies

_(Placeholder for any new external dependencies)_

### 4.2 Configuration Requirements

_(Placeholder for new configuration files or settings, e.g., for `khive ci`
behavior)_

### 4.3 Interface Design

_(Placeholder for any CLI interface changes or additions)_

## 5. Recommendations

### 5.1 Recommended Approach

_(To be formulated after all research areas are covered and analyzed)_

### 5.2 Implementation Roadmap

_(To be formulated after all research areas are covered and analyzed)_

### 5.3 Risk Assessment

_(To be formulated after all research areas are covered and analyzed)_

### 5.4 Alternative Approaches

_(To be formulated after all research areas are covered and analyzed)_

## 6. References

1. [Chef Expeditor Docs - Bash Scripts](https://expeditor.chef.io/docs/patterns/bash-scripts/) -
   (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7) Relevance: Discusses patterns for
   bash scripts in CI/CD, including environment detection and modularity.
2. [GitHub Issue: dvc.org - Script for building pipelines](https://github.com/iterative/dvc.org/issues/633) -
   (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7) Relevance: Example of chaining
   commands in a script, implying modular stages.
3. [ITNext - Best Practices for Managing Bash Scripts](https://itnext.io/best-practices-for-managing-bash-scripts-be2a36aa5147) -
   (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7) Relevance: Recommends using
   `shfmt` and `shellcheck` and integrating them into CI.
4. [CloudBees - Continuous Integration Best Practices](https://www.cloudbees.com/continuous-delivery/continuous-integration-best-practices) -
   (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7) Relevance: Emphasizes a single
   command to build the system.
5. [Sap1ens Blog - Bash Scripting Best Practices](https://sap1ens.com/blog/2017/07/01/bash-scripting-best-practices/) -
   (pplx:3cc09674-62e2-4ed6-865b-2c291a3a0ce7) Relevance: Covers error handling
   (set -euo pipefail) and modularity.
6. [Google Cloud - What is Prompt Engineering?](https://cloud.google.com/discover/what-is-prompt-engineering) -
   (pplx:25f5b4e3-3431-4835-aff7-7bed67232159) Relevance: General prompt
   engineering tips, including providing examples and context.
7. [Flyaps Blog - Prompt Engineering Things You Must Know](https://flyaps.com/blog/prompt-engineering-things-you-must-know-to-gain-maximum-value-from-gen-ai-tools/) -
   (pplx:25f5b4e3-3431-4835-aff7-7bed67232159) Relevance: Mentions using
   personas, examples, and iterative testing.
8. [OpenAI Docs - Six Strategies for Getting Better Results](https://platform.openai.com/docs/guides/prompt-engineering/six-strategies-for-getting-better-results) -
   (pplx:25f5b4e3-3431-4835-aff7-7bed67232159) Relevance: Discusses clear
   instructions, reference text, and system messages.
9. [Learn Prompting - Tooling](https://learnprompting.org/docs/tooling/tools) -
   (pplx:25f5b4e3-3431-4835-aff7-7bed67232159) Relevance: Mentions tools like
   PromptFlow for managing and testing prompts.
10. [CACM - Automating Tools for Prompt Engineering](https://cacm.acm.org/news/automating-tools-for-prompt-engineering/) -
    (pplx:25f5b4e3-3431-4835-aff7-7bed67232159) Relevance: Discusses automated
    tools for optimizing prompts.
11. Claude Deep Research, RR-104/001:
    [`./.khive/deep_research/001_Designing_robust_local_CI_checks_for_development_workflows.md`](./.khive/deep_research/001_Designing_robust_local_CI_checks_for_development_workflows.md) -
    Relevance: Deep dive on iterative pre-commit and stamp of approval.
12. ChatGPT Deep Research, RR-104/002:
    [`./.khive/deep_research/002_Enhancing_khive_ci_Auto_Fix_Iterations_Approval_Stamp.md`](./.khive/deep_research/002_Enhancing_khive_ci_Auto_Fix_Iterations_Approval_Stamp.md) -
    Relevance: Analysis of iterative pre-commit and stamp of approval.
13. Gemini Deep Research, RR-104/003:
    [`./.khive/deep_research/003_Strategies_for_Iterative_Auto_Fixing_and_Local_State_Persistence.md`](./.khive/deep_research/003_Strategies_for_Iterative_Auto_Fixing_and_Local_State_Persistence.md) -
    Relevance: Strategies for iterative auto-fixing and local state persistence.
14. [GitHub Docs - Rate limits for the REST API](https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api) -
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c) Relevance: Official
    documentation on GitHub API rate limits.
15. [GitHub Docs - Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api) -
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c) Relevance: Official best
    practices, including handling rate limits and pagination.
16. [Lunar.dev - Managing Rate Limits for the GitHub API](https://www.lunar.dev/post/a-developers-guide-managing-rate-limits-for-the-github-api) -
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c) Relevance: Suggests caching,
    efficient data fetching, and pagination.
17. [Harness.io - Bidirectional Sync to Prevent GitHub API Limit](https://developer.harness.io/kb/continuous-delivery/articles/biderectional-sync-prevent-github-api-limit/) -
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c) Relevance: Discusses local
    caching, GitHub Apps, and batch operations.
18. [Endor Labs - How to Get the Most Out of GitHub API Rate Limits](https://www.endorlabs.com/learn/how-to-get-the-most-out-of-github-api-rate-limits) -
    (pplx:0e7006c8-5304-4bb0-80d8-55738981b58c) Relevance: Mentions conditional
    requests (ETag, Last-Modified).

## Appendices

### Appendix A: Search Results

**Search Query 1:** "best practices for creating a common CI script (sh/bash)
usable by local CLI and GitHub Actions" (Perplexity, Model: sonar-reasoning, ID:
3cc09674-62e2-4ed6-865b-2c291a3a0ce7)

```json
{
  "success": true,
  "action_performed": "search",
  "content": {
    "id": "3cc09674-62e2-4ed6-865b-2c291a3a0ce7",
    "model": "sonar-reasoning",
    "created": 1747928495,
    "usage": {
      "prompt_tokens": 19,
      "completion_tokens": 1745,
      "total_tokens": 1764,
      "search_context_size": "low"
    },
    "citations": [
      "https://expeditor.chef.io/docs/patterns/bash-scripts/",
      "https://github.com/iterative/dvc.org/issues/633",
      "https://itnext.io/best-practices-for-managing-bash-scripts-be2a36aa5147",
      "https://www.cloudbees.com/continuous-delivery/continuous-integration-best-practices",
      "https://sap1ens.com/blog/2017/07/01/bash-scripting-best-practices/"
    ],
    "object": "chat.completion",
    "choices": [
      {
        "index": 0,
        "finish_reason": "stop",
        "message": { "role": "assistant", "content": "..." }
      }
    ]
  }
}
```

**Search Query 2:** "best practices for AI prompt engineering to guide users
towards specific CLI tool usage AND reduce reliance on API calls considering
token economy" (Perplexity, Model: sonar-reasoning, ID:
25f5b4e3-3431-4835-aff7-7bed67232159)

```json
{
  "success": true,
  "action_performed": "search",
  "content": {
    "id": "25f5b4e3-3431-4835-aff7-7bed67232159",
    "model": "sonar-reasoning",
    "created": 1747930240,
    "usage": {
      "prompt_tokens": 23,
      "completion_tokens": 1268,
      "total_tokens": 1291,
      "search_context_size": "low"
    },
    "citations": [
      "https://cloud.google.com/discover/what-is-prompt-engineering",
      "https://flyaps.com/blog/prompt-engineering-things-you-must-know-to-gain-maximum-value-from-gen-ai-tools/",
      "https://platform.openai.com/docs/guides/prompt-engineering/six-strategies-for-getting-better-results",
      "https://learnprompting.org/docs/tooling/tools",
      "https://cacm.acm.org/news/automating-tools-for-prompt-engineering/"
    ],
    "object": "chat.completion",
    "choices": [
      {
        "index": 0,
        "finish_reason": "stop",
        "message": { "role": "assistant", "content": "..." }
      }
    ]
  }
}
```

**Search Query 3:** "strategies to reduce reliance on server-side API/MCP calls
by strengthening local CLI tools and AI prompt-guided workflows for git
operations" (Perplexity, Model: sonar-reasoning, ID:
0e7006c8-5304-4bb0-80d8-55738981b58c)

```json
{
  "success": true,
  "action_performed": "search",
  "content": {
    "id": "0e7006c8-5304-4bb0-80d8-55738981b58c",
    "model": "sonar-reasoning",
    "created": 1747930891,
    "usage": {
      "prompt_tokens": 26,
      "completion_tokens": 1193,
      "total_tokens": 1219,
      "search_context_size": "low"
    },
    "citations": [
      "https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api",
      "https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api",
      "https://www.lunar.dev/post/a-developers-guide-managing-rate-limits-for-the-github-api",
      "https://developer.harness.io/kb/continuous-delivery/articles/biderectional-sync-prevent-github-api-limit/",
      "https://www.endorlabs.com/learn/how-to-get-the-most-out-of-github-api-rate-limits"
    ],
    "object": "chat.completion",
    "choices": [
      {
        "index": 0,
        "finish_reason": "stop",
        "message": { "role": "assistant", "content": "..." }
      }
    ]
  }
}
```

### Appendix B: Deep Research Document Links

- Claude Deep Research:
  [`./.khive/deep_research/001_Designing_robust_local_CI_checks_for_development_workflows.md`](./.khive/deep_research/001_Designing_robust_local_CI_checks_for_development_workflows.md)
- ChatGPT Deep Research:
  [`./.khive/deep_research/002_Enhancing_khive_ci_Auto_Fix_Iterations_Approval_Stamp.md`](./.khive/deep_research/002_Enhancing_khive_ci_Auto_Fix_Iterations_Approval_Stamp.md)
- Gemini Deep Research:
  [`./.khive/deep_research/003_Strategies_for_Iterative_Auto_Fixing_and_Local_State_Persistence.md`](./.khive/deep_research/003_Strategies_for_Iterative_Auto_Fixing_and_Local_State_Persistence.md)

### Appendix C: Additional Code Samples

_More extensive code examples if needed._

## 5. Recommendations

Based on the comprehensive research covering a unified CI script, enhancements
to `khive ci`, prompt modifications, and strategies for reducing GitHub MCP
reliance, the following recommendations are proposed to improve CI enforcement
and streamline Khive development workflows.

### 5.1 Recommended Approach

1. **Unified CI Script (`ci.sh`):**
   - **Adopt:** Implement a modular `ci.sh` script as outlined in Section 2.1.
   - **Key Features:** Ensure it supports distinct stages (lint, test, build,
     etc.), robust error handling (`set -euo pipefail`), environment detection
     (local vs. GHA), and parameterization for selective stage execution.
   - **Integration:** `khive ci` should be able to invoke specific stages of
     this script. GitHub Actions will execute the full script or relevant
     stages.
   - **Validation:** Include `shellcheck` and `shfmt` in the GHA workflow to
     validate `ci.sh` itself.

2. **Enhanced `khive ci`:**
   - **Iterative `pre-commit`:**
     - Implement the hybrid approach: `khive ci` orchestrates
       `pre-commit run --all-files` (then `--files <modified>` for subsequent
       runs) iteratively until convergence or a cap of 3-5 iterations.
     - Incorporate content hashing for robust loop detection, halting and
       warning the user if a loop or non-convergence after max iterations
       occurs.
     - Prioritize performance by leveraging `pre-commit` and individual tool
       caching.
   - **"Stamp of Approval":**
     - Implement using a project-local, git-ignored JSON file (e.g.,
       `.khive/ci_status.json`).
     - The stamp must include `khiveCiVersion`, `timestamp`,
       `precommitConfigHash` (SHA256 of `.pre-commit-config.yaml`), and
       `approvedFiles` (array of `path` and Git blob `hash` for all staged
       files).
     - `khive commit` and `khive pr` MUST rigorously validate this stamp
       (existence, version, config hash, and exact match of currently staged
       files against `approvedFiles`).
     - **Default Action:** Block commit/PR if the stamp is missing, invalid, or
       stale. Provide a clear error and instruct to run `khive ci`.
     - **Override:** Include an override flag (e.g., `--no-verify-khive-ci`) for
       exceptional cases.
     - **Invalidation:** The stamp is invalidated (deleted) by
       `khive commit`/`pr` on validation failure, or by `khive ci` at the start
       of a new run if the workspace state has diverged. Provide a manual
       `khive ci --clear-stamp` command.

3. **Prompt Modification for CLI Enforcement:**
   - **Implement Systematically:** Update system prompts for relevant Khive
     modes (especially Implementer) with explicit rules and few-shot examples
     prioritizing `khive` CLI tools (`khive commit`, `khive pr`,
     `khive new-doc`, `khive ci`, `khive fmt`) over MCP calls for equivalent
     local operations.
   - **Role Setting:** Define the AI's persona as a `khive` CLI expert.
   - **Documentation Reinforcement:** Prompt the AI to consult internal `khive`
     CLI documentation before resorting to MCP.
   - **Iterate and Monitor:** Continuously test and refine prompts, monitoring
     token usage and AI behavior.

4. **Reducing GitHub MCP Reliance:**
   - **Prioritize CLI Enhancements:** Focus on making `khive` CLI tools
     (especially `khive ci`, `khive commit`, `khive pr`) robust and
     feature-complete for core local development workflows.
   - **Consider Local Caching (Future):** For `khive` tools that might interact
     with GitHub API for supplementary data (e.g., issue details for commit
     messages), explore implementing local caching with conditional requests
     (ETags) to reduce direct API calls. This is a secondary priority after
     strengthening the core local workflow tools.

### 5.2 Implementation Roadmap

A phased approach is recommended to manage development effort and gather
feedback:

- **Phase 1: Foundational CLI & Prompts (Low-Medium Effort)**
  - Develop a basic, modular `ci.sh` covering essential linting and testing
    stages.
  - Integrate `ci.sh` into GitHub Actions.
  - Implement initial prompt modifications in key Khive modes to prefer existing
    `khive` CLI commands.
  - `khive ci` initially just runs `pre-commit run --all-files` once.

- **Phase 2: Iterative `pre-commit` in `khive ci` (Medium Effort)**
  - Enhance `khive ci` to orchestrate iterative `pre-commit` runs (hybrid
    approach: convergence with max 3-5 iterations).
  - Implement basic loop detection (max iterations) and clear reporting.
  - Optimize by running on modified files after the first pass.

- **Phase 3: "Stamp of Approval" Mechanism (Medium-High Effort)**
  - Design and implement the `.khive/ci_status.json` stamp file creation by
    `khive ci` upon successful, converged run.
  - Implement rigorous stamp validation logic in `khive commit` and `khive pr`,
    including blocking by default and an override mechanism.
  - Implement stamp invalidation logic.
  - Add advanced loop detection (content hashing) to `khive ci`.

- **Phase 4: Advanced CLI Enhancements & MCP Reduction (Medium-High Effort,
  Ongoing)**
  - Further refine `khive` CLI tools based on usage and feedback.
  - Investigate and implement local caching for GitHub data within relevant
    `khive` tools if significant benefits in reducing MCP calls are identified
    for common AI agent workflows.
  - Continuously refine prompts based on AI behavior and new CLI capabilities.

### 5.3 Risk Assessment

- **Developer Friction:**
  - _Risk:_ Overly strict or slow local `khive ci` checks could frustrate
    developers, leading them to use overrides excessively or bypass checks.
  - _Mitigation:_ Prioritize performance of `khive ci` (caching, optimized
    iterations). Ensure override mechanisms are available but logged. Solicit
    developer feedback actively during rollout.
- **Complexity of `khive` Tooling:**
  - _Risk:_ Adding iterative logic, stamp management, and validation increases
    the complexity of `khive ci`, `khive commit`, and `khive pr`.
  - _Mitigation:_ Thorough unit and integration testing for the new features.
    Clear internal documentation for maintainers.
- **Edge Cases in Stamp Validation:**
  - _Risk:_ Incorrectly invalidating or validating the "stamp of approval" could
    lead to either unnecessary re-runs of `khive ci` or, worse, allowing
    commits/PRs without proper local validation.
  - _Mitigation:_ Rigorous testing of the stamp content (especially
    `approvedFiles` hashing and comparison) and invalidation logic across
    various Git scenarios (amends, rebases, merges).
- **Maintenance Overhead:**
  - _Risk:_ The new `ci.sh` and enhanced CLI features will require ongoing
    maintenance as the Khive project evolves.
  - _Mitigation:_ Ensure the `ci.sh` is well-documented and modular. Follow good
    coding practices for CLI enhancements.
- **Effectiveness of Prompt Modifications:**
  - _Risk:_ Prompt changes might not consistently yield the desired AI behavior,
    or might have unintended side effects on other AI interactions.
  - _Mitigation:_ Iterative testing and refinement of prompts. Monitor AI agent
    behavior and token costs.

### 5.4 Alternative Approaches

- **Simpler `khive ci`:** Instead of iterative `pre-commit` and a stamp,
  `khive ci` could simply run `pre-commit run --all-files` once. `khive commit`
  could then just check the exit code of the last `pre-commit` run (if logged
  somewhere simple), or rely solely on `pre-commit`'s own git hook mechanism.
  - _Trade-off:_ Less robust, doesn't handle chained fixes automatically, less
    certainty about the state validated.
- **Git-Native Hooks Only:** Rely entirely on standard `pre-commit` git hooks
  and not have a separate `khive ci` command or stamp.
  - _Trade-off:_ Loses the benefits of `khive ci` as an explicit, orchestratable
    local quality gate that can perform more complex logic than a simple hook.
    Does not provide a "stamp" for `khive pr` to check.
- **Server-Side Checks Only:** Do not implement enhanced local checks and rely
  solely on GitHub Actions for CI.
  - _Trade-off:_ Slower feedback loop for developers, higher CI resource
    consumption, doesn't address the goal of strong local enforcement.
- **Git Notes for Stamp:** Use Git notes for the "stamp of approval" instead of
  a file.
  - _Trade-off:_ As discussed in Sec 2.2, more complex to manage for ephemeral
    local state and has discoverability/cleanup challenges, though it ties the
    stamp directly to a commit.

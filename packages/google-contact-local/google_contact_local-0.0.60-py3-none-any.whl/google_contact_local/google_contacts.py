# TODO When basic sync works, please make sure you can get the updated timestamp of the contact in Google Contact
# and at Circlez.ai database compared.
import http
import time
from typing import Optional
from datetime import datetime
from zoneinfo import ZoneInfo

import pycountry
from google_account_local.google_account_local import GoogleAccountLocal
from google_account_local.google_account_local import SCOPES
from api_management_local.api_limit_status import APILimitStatus
from api_management_local.api_mangement_manager import APIManagementsManager
from api_management_local.exception_api import (
    ApiTypeDisabledException,
    ApiTypeIsNotExistException,
)
from api_management_local.indirect import InDirect
from contact_email_address_local.contact_email_addresses_local import (
    ContactEmailAdressesLocal,
)
from contact_group_local.contact_group import ContactGroups
from contact_local.contact_local import ContactsLocal
from contact_location_local.contact_location_local import ContactLocationLocal
from contact_notes_local.contact_notes_local import ContactNotesLocal
from contact_persons_local.contact_persons_local import ContactPersonsLocal
from contact_phone_local.contact_phone_local import ContactPhoneLocal
from phones_local.phones_local import PhonesLocal
from contact_profile_local.contact_profiles_local import ContactProfilesLocal
from contact_user_external_local.contact_user_external_local import (
    ContactUserExternalLocal,
)
from database_mysql_local.point import Point
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from importer_local.ImportersLocal import ImportersLocal
from importer_local.importer_sync_conflict_resolution import (
    ImporterSyncConflictResolution,
    UpdateStatus as ImporterUpdateStatus,
)

# from database_mysql_local.constants import UpdateStatus
from internet_domain_local.internet_domain_local import DomainLocal
from location_local.country import Country
from location_local.location_local_constants import LocationLocalConstants
from logger_local.MetaLogger import MetaLogger
from organization_profile_local.organization_profiles_local import (
    OrganizationProfilesLocal,
)
from organizations_local.organizations_local import OrganizationsLocal
from python_sdk_remote.utilities import our_get_env
from url_remote import action_name_enum, component_name_enum, entity_name_enum
from url_remote.our_url import OurUrl
from user_context_remote.user_context import UserContext
from user_external_local.user_externals_local import UserExternalsLocal
from profile_local.profiles_local import ProfilesLocal
from group_local.group_type import group_type

from .google_contacts_constants import GoogleContactConstants

BRAND_NAME = our_get_env("BRAND_NAME")
PRODUCT_USER_IDENTIFIER = our_get_env("PRODUCT_USER_IDENTIFIER")
PRODUCT_PASSWORD = our_get_env("PRODUCT_PASSWORD")
# TODO Let's create/use AUTHENTICATION_API_VERSION_DICT[ENVIRONMENT_NAME] in url-remote-python,
# instead of the hardcoded line below
AUTHENTICATION_API_VERSION = 1

# TODO: delete the following line when importer.insert()'s parameter location_id will have a default value
DEFAULT_LOCATION_ID = LocationLocalConstants.UNKNOWN_LOCATION_ID
# TODO What is this? Can we avoid it? When do we use it?
DEFAULT_PROFILE_ID = 0


# TODO refresh token - unattended login/authentication


# TODO As we don't have google_contact_table can we avoid inheriting GenericCRUD? Let's use designated Python Classes for almost each table and inherit GenericCrud there.  # noqa
class GoogleContacts(
    GoogleAccountLocal,
    metaclass=MetaLogger,
    # TODO object -> logger_object
    object=GoogleContactConstants.LoggerSetupConstants.GOOGLE_CONTACT_LOCAL_CODE_LOGGER_OBJECT,
):
    # TODO User table generated by Sql2Code instead of hardcoded IDs

    # I think we should move the goups_str to the public sync method as we might want to use the same class with multiple accounts / groups_str
    def __init__(self):
        self.user_context = UserContext()
        # TODO: change email1, email2, email3 to email_address1, email_address2, email_address3 in ContactsLocal
        self.contacts_local: ContactsLocal = None
        self.organization_profile: OrganizationProfilesLocal = None
        self.contact_persons: ContactPersonsLocal = None
        self.contact_user_external: ContactUserExternalLocal = None
        self.contact_profiles: ContactProfilesLocal = None
        self.contact_group: ContactGroups = None
        self.contact_email_addresses: ContactEmailAdressesLocal = None
        self.contact_phones: ContactPhoneLocal = None
        self.contact_location: ContactLocationLocal = None
        self.user_externals_local: UserExternalsLocal = (
            None  # TODO: Do we still need this here?
        )
        self.organizations_local: OrganizationsLocal = None
        self.domain: DomainLocal = None
        self.importer: ImportersLocal = None
        self._instances = {}
        self.classes = [
            ContactsLocal,
            OrganizationProfilesLocal,
            ContactPersonsLocal,
            ContactUserExternalLocal,
            ContactProfilesLocal,
            ContactGroups,
            ContactEmailAdressesLocal,
            ContactPhoneLocal,
            ContactLocationLocal,
            UserExternalsLocal,
            OrganizationsLocal,
            DomainLocal,
            ImportersLocal,
        ]
        self.instances_names = [
            "contacts_local",
            "organization_profile",
            "contact_persons",
            "contact_user_external",
            "contact_profiles",
            "contact_group",
            "contact_email_addresses",
            "contact_phones",
            "contact_location",
            "user_externals_local",
            "organizations_local",
            "domain",
            "importer",
        ]

        self.profile_id = None
        self.groups_list = None
        self.google_contact_seq_start = None
        self.google_contact_seq_end = None
        self.google_client_id = our_get_env("GOOGLE_CLIENT_ID", raise_if_empty=True)
        self.google_client_secret = our_get_env(
            "GOOGLE_CLIENT_SECRET", raise_if_empty=True
        )
        self.google_port_for_authentication = int(
            our_get_env("GOOGLE_PORT_FOR_AUTHENTICATION", raise_if_empty=True)
        )
        self.google_redirect_uris = our_get_env(
            "GOOGLE_REDIRECT_URIS", raise_if_empty=True
        )
        self.google_auth_uri = our_get_env("GOOGLE_AUTH_URI", raise_if_empty=True)
        self.google_token_uri = our_get_env("GOOGLE_TOKEN_URI", raise_if_empty=True)

        # TODO Add support to criteria_set_id
        # TODO: fix https://github.com/circles-zone/entity-type-local-python-package

        super().__init__()
        self.organization_main_group_type_id = group_type.get("Organization")
        self.job_title_main_group_type_id = group_type.get("Job Title")

    def __getattribute__(self, name):
        # Call the original __getattribute__
        value = super().__getattribute__(name)

        # If value is None and name is in instances_names, initialize it
        if value is None and name in self.instances_names:
            for index, cls in enumerate(self.classes):
                if self.instances_names[index] == name:
                    instance = cls()
                    self._instances[name] = instance
                    setattr(self, name, instance)
                    return instance

        # Otherwise, return the value
        return value

    # note, missing check for token/email if the user already authenticated.
    # TODO Shall we take the parts of the authentication() from GoogleContacts to GoogleAccount as it is relevant
    # also to other services such as Google Calendar Sync.
    # TODO Can we run the Google Contact Sync with index_start and index_end? Or other criteria? Preferable criteria_set
    # which @Akiva Skolnik is working on.
    # TODO Shall you write a small Python file to reconnect to the Google Account using the refresh token in
    # user_external_table? - Please give me the command line to run it and I'll add it to the GHA YML.

    @staticmethod
    # TODO Please data types to all functions and methods
    def create_dict_representation(contact):
        # Extract the details from the contact
        names = contact.get("names", [{}])[0]
        first_name = names.get("givenName")
        last_name = names.get("familyName")
        display_name = names.get("displayName", None)
        display_name = display_name if display_name else f"{first_name} {last_name}"
        phone_numbers = contact.get("phoneNumbers", [{}])
        """
        phone_dict structure:
        {
            'value': '054-123-4567',
            'canonicalForm': '+972541234567',
            'type': 'work',
            'formattedType': 'Work'
        }
        """
        phone_dict1 = phone_numbers[0] if len(phone_numbers) > 0 else None
        phone_dict2 = phone_numbers[1] if len(phone_numbers) > 1 else None
        phone_dict3 = phone_numbers[2] if len(phone_numbers) > 2 else None
        phone_numbers = [
            phone.get("canonicalForm") for phone in contact.get("phoneNumbers", [{}])
        ]
        emails = [email.get("value") for email in contact.get("emailAddresses", [{}])]
        birthday = contact.get("birthdays", [{}])[0].get("text")
        location_dicts = contact.get("addresses", [{}])
        organizations_job_titles_dicts_list = contact.get("organizations", [{}])
        websites = contact.get("urls", [{}])
        notes = (
            contact.get("biographies")[0].get("value")
            if contact.get("biographies")
            else None
        )
        resource_name = contact.get("resourceName")
        # Get the last modified timestamp of the contact
        profile_meta_data = contact.get("metadata", {})
        sources = profile_meta_data.get("sources", [{}])
        last_modified_timestamp = (
            sources[0].get("updateTime") if sources and len(sources) > 0 else None
        )
        last_modified_timestamp = GoogleContacts.__get_formatted_timestamp(
            last_modified_timestamp
        )

        # TODO: change email1, email2, email3 to email_address1, email_address2, email_address3
        # Create the dictionary
        google_contact_dict = {
            "first_name": first_name,
            "last_name": last_name,
            "display_as": display_name,
            "phone_dict1": phone_dict1,
            "phone_dict2": phone_dict2,
            "phone_dict3": phone_dict3,
            "birthday": birthday,
            "location_dicts": location_dicts,
            "organizations_job_titles_dicts_list": organizations_job_titles_dicts_list,
            "notes": notes,
            "last_modified_timestamp": last_modified_timestamp,
            "resource_name": resource_name,
            "source": "Google Contacts - People API Import",
        }

        # Add additional phones and emails to the dictionary
        for i in range(0, max(len(phone_numbers), len(emails), len(websites))):
            if i < len(phone_numbers):
                google_contact_dict[f"phone{i + 1}"] = phone_numbers[i]
            if i < len(emails):
                google_contact_dict[f"email{i + 1}"] = emails[i]
            if i < len(websites):
                google_contact_dict[f"website{i + 1}"] = websites[i].get("value")
                google_contact_dict[f"website_type{i + 1}"] = websites[i].get("type")
                google_contact_dict[f"website_formatted_type{i + 1}"] = websites[i].get(
                    "formattedType"
                )

        return google_contact_dict

    # TODO Can we please add groups_str parameter to both sync-google-contact and import-contact-csv where we add all contacts to those groups?
    def pull_people_api(
        self, email_address: str, username: str, groups_dicts: list[dict] = None
    ) -> str:
        self.logger.start(
            log_message="Start of pull_people_api",
            object={"email": email_address, "groups_dicts": groups_dicts},
        )
        # Start with an empty token
        page_token: str = None
        self.groups_list = groups_dicts if groups_dicts else []

        # TODO: before_call_api and after_call_api are supposed to get the argument user_external_id,
        # but when they get it they fail because the relevant row in  api_limit_view has None
        # in the column user_external_id. Shall we delete the following lines?
        user_external_id_dict = self.select_one_dict_by_column_and_value(
            select_clause_value="user_external_id",
            column_name="username",
            column_value=username,
            order_by="user_external_id DESC",
        )
        user_external_id = user_external_id_dict["user_external_id"]
        data_source_instance_id = self.__insert_data_source_instance_id(
            email=email_address, user_external_id=user_external_id
        )
        authentication_auth_login_endpoint_url = OurUrl.endpoint_url(
            brand_name=BRAND_NAME,
            environment_name=our_get_env("ENVIRONMENT_NAME"),
            component_name=component_name_enum.ComponentName.AUTHENTICATION.value,
            entity_name=entity_name_enum.EntityName.AUTH_LOGIN.value,
            version=AUTHENTICATION_API_VERSION,
            action_name=action_name_enum.ActionName.LOGIN.value,
        )
        headers = {"Content-Type": "application/json"}
        outgoing_body = {
            "user_identifier": PRODUCT_USER_IDENTIFIER,
            "password": PRODUCT_PASSWORD,
        }
        # TODO: can we move this part to api management?
        incoming_message = ""
        next_google_contact_index = 0
        while next_google_contact_index <= self.google_contact_seq_end:
            try:
                results = self.__get_google_connections(
                    user_external_id=user_external_id,
                    authentication_auth_login_endpoint_url=authentication_auth_login_endpoint_url,
                    headers=headers,
                    outgoing_body=outgoing_body,
                    incoming_message=incoming_message,
                    page_token=page_token,
                )
                # TODO Please import quantity only MAX INDEX-MIN INDEX
                # TODO Can we get the contacts from Google based on a field (sorted by something)? LAST MODIFIED DESC (we want to import the latest modify first)  # noqa
                # TODO Please implement
                google_connections = results.get("connections", [])
                page_token = results.get("nextPageToken")
                self.logger.info(
                    log_message=f"Next page token: {page_token}",
                    object={"page_token": page_token},
                )
                """
                contact_dicts_list_temp: list = []
                for index, google_contact_connection in enumerate(google_connections):
                    contact_dict = GoogleContacts.create_dict_representation(google_contact_connection)
                    contact_dicts_list_temp.append(contact_dict)
                google_connections = None   # Free up memory

                # Sort contact_dicts_list by contact_dict.get("last_name")
                # contact_dicts_list_temp.sort(key=GoogleContacts.sort_key)

                # Filter contacts by index
                contact_dicts_list: list = []
                for index, contact_dict in enumerate(contact_dicts_list_temp):
                    self.logger.info(log_message=f"Index of contact: {index}", object={"index": index})
                    if index < self.contact_seq_start or index > self.contact_seq_end:
                        self.logger.info(log_message=f"Skipping contact with index {index}", object={"index": index})
                        continue
                    contact_dicts_list.append(contact_dict)
                contact_dicts_list_temp = None  # Free up memory
                """
                google_connections = results.get("connections", [])
                for index, google_contact_connection in enumerate(google_connections):
                    # self.logger.info(log_message=f"Index of contact: {index}", object={"index": index})
                    # if index < self.contact_seq_start or index > self.contact_seq_end:
                    #     self.logger.info(log_message=f"Skipping contact with index {index}", object={"index": index})
                    #     continue
                    # self.logger.info(
                    #     log_message=f"Type of contact: {type(google_contact_connection)}")
                    # self.logger.info(log_message=f"Contents of contact: {google_contact_connection}")

                    # TODO: move these calls to ComprehensiveContacts
                    # Create a dictionary representation for the contact
                    if (
                        next_google_contact_index < self.google_contact_seq_start
                        or next_google_contact_index > self.google_contact_seq_end
                    ):
                        next_google_contact_index += 1
                        continue
                    next_google_contact_index += 1
                    self.logger.info(
                        log_message=f"Importing contact with index {index}",
                        object={"index": index},
                    )

                    contact_dict = GoogleContacts.create_dict_representation(
                        google_contact_connection
                    )

                    # Insert or update the contact in the local database
                    contact_dict["data_source_instance_id"] = data_source_instance_id
                    contact_dict["data_source_type_id"] = (
                        GoogleContactConstants.DATA_SOURCE_TYPE_ID
                    )
                    contact_dict["owner_profile_id"] = self.profile_id
                    contact_dict["system_id"] = GoogleContactConstants.GOOGLE_SYSTEM_ID
                    contact_row_dict = (
                        self.contacts_local.upsert_contact_dict_with_return_dict(
                            contact_dict
                        )
                    )
                    self._update_contact_dict_with_upsert_result(
                        contact_dict=contact_dict, upsert_result_dict=contact_row_dict
                    ) or {}
                    if contact_dict.get("contact_id") is not None:
                        self._insert_contact_details_to_db(
                            contact_dict=contact_dict,
                            user_external_id=user_external_id,
                            data_source_instance_id=data_source_instance_id,
                        )
                    else:
                        raise Exception("pull_people_api: Contact upsert failed")

                    # TODO Add the contact to the default group of the User External email_account/mailbox

                # TODO: Add contact_person directly or using ContactPersonsLocal.insert() from GenericCRUD

                # Break after processing one contact - for debugging without running over all contacts heh
                # break

                if not page_token:
                    break
            except ApiTypeDisabledException:
                self.logger.error("Api Type Disabled Exception")
            except ApiTypeIsNotExistException:
                self.logger.error("Api Type Is Not Exist Exception")
        self.logger.info(
            log_message=f"End of pull_people_api, page_token: {page_token}",
            object={"page_token": page_token},
        )
        return page_token

    def _insert_contact_details_to_db(
        self, contact_dict: dict, user_external_id: int, data_source_instance_id: int
    ) -> int:
        contact_dict["location_id"] = DEFAULT_LOCATION_ID
        try:
            # Get update status
            update_status = self.__conflict_resolution(  # noqa
                last_modified_timestamp=contact_dict.get("last_modified_timestamp"),
                contact_id=contact_dict.get("contact_id"),
            )
            # insert organization
            self._insert_organization(contact_dict=contact_dict)

            # insert link contact_location
            # The location is in contact_dict
            location_results = self._insert_link_contact_location(
                # TODO Why do we need both?  contact_dict=contact_dict, contact_id=contact_id
                contact_dict=contact_dict
            ) or [{}]
            # TODO Same comments as in contact-csv, Why location_results[0]? What if we have multiple locations? - Please add such test.
            # TODO Can we have one copy of this code used both by google-contact and contact-csv?
            contact_dict["location_id"] = location_results[0].get("location_id")
            contact_dict["country_id"] = location_results[0].get("country_id")

            # insert link contact_group
            # TODO I expected to have only contact_id and group_list as parameters
            self._insert_link_contact_groups(
                # TODO Why do we need both? contact_dict=contact_dict and contact_id=contact_id
                contact_dict=contact_dict
            )

            # insert link contact_persons

            # TODO I expected to have only contact_id and person_list as parameters
            contact_person_result_dict = (
                self._insert_link_contact_persons(contact_dict=contact_dict) or {}
            )
            contact_dict["person_id"] = contact_person_result_dict.get("person_id")

            # insert link contact_profiles
            # TODO I expected to have only contact_id and profile_list as parameters
            # TODO contact_profiles_dict =
            contact_profile_info = (
                self._insert_contact_profiles(contact_dict=contact_dict) or {}
            )
            contact_dict["profiles_ids_list"] = contact_profile_info.get(
                "profiles_ids_list"
            )

            # insert organization-profile
            # TODO I'm not sure I understand, contact can have multiple profiles, and contact can have multiple organizations, are we linking one organization of the contact with all his profiles?  # noqa
            self._insert_organization_profile(contact_dict=contact_dict)

            # insert link contact_email_addresses
            # TODO I expected to have only contact_id and email_address_list as parameters
            self._insert_link_contact_email_addresses(contact_dict=contact_dict)

            # insert link contact_notes
            GoogleContacts._insert_link_contact_notes_and_text_blocks(
                contact_dict=contact_dict
            )

            # insert link contact_phones
            self._insert_link_contact_phones(contact_dict=contact_dict)

            # inset link contact_user_externals
            self._insert_link_contact_user_external(contact_dict=contact_dict)

            # insert link contact_internet_domains
            self._insert_link_contact_domains(contact_dict=contact_dict)

        except Exception as exception:
            self.logger.exception(
                log_message="Error while inserting to contact connection tables",
                object={"exception": exception},
            )
            raise exception
        finally:
            importer_id = self._insert_importer(
                # TODO As contact can have multiple locations, I think we should location_id=contact_dict.get("main_location_id")
                contact_id=contact_dict.get("contact_id"),
                location_id=contact_dict.get("location_id") or DEFAULT_LOCATION_ID,
                user_external_id=user_external_id,
                data_source_instance_id=data_source_instance_id,
                google_people_api_resource_name=contact_dict.get("resource_name"),
            )
            self.logger.info(object={"importer_id": importer_id})

        return importer_id

    def __insert_data_source_instance_id(
        self, email: str, user_external_id: int
    ) -> int:
        # name has to be "YYMMDD HHMMSS email  Google Contacts - People API"
        name = (
            datetime.now(ZoneInfo("UTC")).strftime("%y%m%d %H%M%S")
            + " "
            + email
            + " Google Contacts - People API"
        )
        data_source_instance_id = self.insert(
            schema_name="data_source_instance",
            table_name="data_source_instance_table",
            data_dict={
                "name": name,
                "data_source_type_id": GoogleContactConstants.DATA_SOURCE_TYPE_ID,
                "file_or_api": "api",
                "computer_name": None,
                "user_external_id": user_external_id,
                "start_index": self.google_contact_seq_start,
                "end_index": self.google_contact_seq_end,
            },
        )
        return data_source_instance_id

    def __get_google_connections(
        self,
        user_external_id,
        authentication_auth_login_endpoint_url,
        headers,
        outgoing_body,
        incoming_message,
        page_token,
    ):
        self.service = build("people", "v1", credentials=self.creds)
        # TODO: Shall we use v2? https://gist.github.com/avaidyam/acd66c26bc68bf6b89e70374bdc5a5d4
        self.logger.info(
            "Listing all connection names along with their emails and phone numbers"
        )
        indirect = InDirect()
        api_check, api_call_id, http_status_code, response_body = (
            indirect.before_call_api(
                user_external_id=user_external_id,
                api_type_id=GoogleContactConstants.PEOPLE_API_TYPE_ID,
                endpoint_url=authentication_auth_login_endpoint_url,
                outgoing_header=headers,
                outgoing_body=outgoing_body,
            )
        )
        if http_status_code is None:
            used_cache = False
            if api_check == APILimitStatus.BETWEEN_SOFT_LIMIT_AND_HARD_LIMIT:
                self.logger.warn("You excced the soft limit")
            if api_check != APILimitStatus.GREATER_THAN_HARD_LIMIT:
                try:
                    # user = user_context.login_using_user_identification_and_password(outgoing_body)
                    http_status_code = http.HTTPStatus.OK.value
                except Exception as exception:
                    self.logger.error(object=exception)
                    http_status_code = http.HTTPStatus.BAD_REQUEST.value
            else:
                self.logger.info("You passed the hard limit")
                seconds_to_sleep_after_passing_the_hard_limit = APIManagementsManager().get_seconds_to_sleep_after_passing_the_hard_limit(
                    api_type_id=GoogleContactConstants.PEOPLE_API_TYPE_ID
                )
                if seconds_to_sleep_after_passing_the_hard_limit > 0:
                    self.logger.info(
                        f"sleeping : {seconds_to_sleep_after_passing_the_hard_limit} seconds"
                    )
                    time.sleep(seconds_to_sleep_after_passing_the_hard_limit)
                    # raise PassedTheHardLimitException
                else:
                    self.logger.info(
                        f"No sleeping needed: {seconds_to_sleep_after_passing_the_hard_limit=} seconds"
                    )
        else:
            used_cache = True
            self.logger.info("result from cache")
            # print(arr)
            http_status_code = http.HTTPStatus.OK.value

        results = (
            self.service.people()
            .connections()
            .list(
                resourceName="people/me",
                pageSize=50,
                sortOrder="FIRST_NAME_ASCENDING",
                # Scrolls further in the GoogleContacts sheet, otherwise stop at around 10 contacts.
                pageToken=page_token,
                personFields=(
                    "names,emailAddresses,biographies,phoneNumbers,birthdays,addresses,organizations,"
                    "occupations,urls,metadata"
                ),
            )
            .execute()
        )
        self.logger.info(
            log_message="Results from Google Contacts API", object={"results": results}
        )

        indirect.after_call_api(
            user_external_id=user_external_id,
            api_type_id=GoogleContactConstants.PEOPLE_API_TYPE_ID,
            endpoint_url=authentication_auth_login_endpoint_url,
            outgoing_header=headers,
            outgoing_body=outgoing_body,
            incoming_message=incoming_message,
            http_status_code=http_status_code,
            response_body=response_body,
            api_call_id=api_call_id,
            used_cache=used_cache,
        )

        return results

    # def __display_contact_details(self, contact):  # for debugging, can delete later
    #     def display_with_names(header, values):
    #         if not values:
    #             print(f"{header}: None")
    #             return
    #         for value in values:
    #             first_name = contact['names'][0].get('givenName', None) if 'names' in contact else None
    #             last_name = contact['names'][0].get('familyName', None) if 'names' in contact else None
    #             print(f"{header} for {first_name} {last_name}: {value}")

    #     # Display names
    #     if 'names' in contact:
    #         names = contact['names']
    #         if names:
    #             first_name = names[0].get('givenName', None)
    #             last_name = names[0].get('familyName', None)
    #             print(f"Name: {first_name} {last_name}")
    #         else:
    #             print("Name: None")
    #     else:
    #         print("Name: None")

    #     # Display emails
    #     emails = [email.get('value', None) for email in contact.get('emailAddresses', [])]
    #     display_with_names("Email", emails)

    #     # Display phone numbers
    #     phone_numbers = [phone.get('value', None) for phone in contact.get('phoneNumbers', [])]
    #     display_with_names("Phone Number", phone_numbers)

    #     # Display birthdays
    #     birthdays = [birthday.get('text', None) for birthday in contact.get('birthdays', [])]
    #     display_with_names("Birthday", birthdays)

    #     # Display addresses
    #     addresses = [address.get('formattedValue', None) for address in contact.get('addresses', [])]
    #     display_with_names("Address", addresses)

    #     # Display organizations
    #     organizations = [org.get('name', None) for org in contact.get('organizations', [])]
    #     display_with_names("Organization", organizations)

    #     # Display occupations
    #     occupations = [occ.get('value', None) for occ in contact.get('occupations', [])]
    #     display_with_names("Occupation", occupations)

    # TODO Please add documentation, what is the diff between public pull_contacts_with_stored_token and pull_people_api(...)
    def pull_contacts_with_stored_token(
        self,
        email_address: str,
        groups_dicts: list[dict] = None,
        start_index: int = 0,
        end_index: int = 1,
    ) -> None:
        user_external_username = (
            email_address  # Because it is only google, username is the email
        )
        self.google_contact_seq_start = start_index
        self.google_contact_seq_end = end_index
        if not email_address:
            self.logger.error("Email cannot be null.")
            return
        self.profile_id = ProfilesLocal().select_one_value_by_column_and_value(
            schema_name="profile",
            view_table_name="profile_view",
            select_clause_value="profile_id",
            column_name="profile.main_email_address",
            column_value=email_address,
        )
        if self.profile_id is None:
            # If there is no profile in our system with the given email address, we can't proceed
            self.logger.error(
                "Couldn't find profile_id in profile_view by email_address."
            )
            raise Exception(
                "Couldn't find profile_id in profile_view by email_address."
            )
        self.logger.info(
            "Getting token data from DB",
            object={
                "email": email_address,
                "profile_id": self.user_context.get_effective_profile_id(),
            },
        )

        auth_details = self.user_externals_local.get_auth_details(  # TODO: fix typing
            username=user_external_username,
            system_id=GoogleContactConstants.GOOGLE_SYSTEM_ID,
            profile_id=self.profile_id,
        )
        if not auth_details:
            self.logger.error(f"Token data not found in DB for user_external_username: {user_external_username}")
            exception_message = f"auth details not found in DB. user_extenal object: {self.user_externals_local} \n given email: {email_address}"
            raise Exception(exception_message)

        # Unpack the token_data tuple into its constituent parts
        access_token = auth_details.get("access_token")
        refresh_token = auth_details.get("refresh_token")

        expiry_str = auth_details.get("expiry")
        #  ValueError: time data '2025-05-12 17:39:32' does not match format '%Y-%m-%dT%H:%M:%S'

        # Parse the string with the correct format
        expiry_dt = datetime.fromisoformat(expiry_str)

        # Convert it to ISO
        expiry_iso = expiry_dt.strftime('%Y-%m-%dT%H:%M:%S')

        # Update the token_info dictionary with the unpacked values
        token_info = {
            "token": access_token,
            "refresh_token": refresh_token,
            "token_uri": self.google_token_uri,
            "client_id": self.google_client_id,
            "client_secret": self.google_client_secret,
            "scopes": SCOPES,
            "expiry": expiry_iso,
        }

        # Create a Credentials object from the stored token
        self.creds = Credentials.from_authorized_user_info(token_info)

        # Print all attributes of self.creds for debugging
        for attr in dir(self.creds):
            if not attr.startswith("__"):
                print(f"{attr}: {getattr(self.creds, attr)}")

        if not self.creds.valid:
            self.logger.error(
                "Stored credentials are not valid.", object={"token_info": token_info}
            )
            self.update_by_column_and_value(
                schema_name="user_external",
                table_name="user_external_table",
                column_name="refresh_token",
                column_value=refresh_token,
                data_dict={"is_refresh_token_valid": False},
            )
            raise Exception("Stored credentials are not valid.")

        # Now, pull the contacts using the People API
        self.pull_people_api(
            email_address=email_address,
            username=user_external_username,
            groups_dicts=groups_dicts,
        )

        # TODO logger info with everything done "data_source_instance" "number_of_contacts_sync_from_google_to_circles" "number_contacts_sync_from_circlrs_to_google_contacts"  # noqa

    # TODO: At the moment we support only 1 organization per contact. Shall we support multiple organizations?
    def _insert_organization(self, contact_dict: dict):
        organizations_job_titles_dicts_list = contact_dict.get(
            "organizations_job_titles_dicts_list"
        )
        if not organizations_job_titles_dicts_list:
            return
        for organization_job_title_dict in organizations_job_titles_dicts_list:
            if not organization_job_title_dict:
                continue
            organization_name = organization_job_title_dict.get("name")
            if organization_name:
                organization_dict = self._create_organization_dict(
                    organization_name=organization_name
                )
                upsert_organization_result = (
                    self.organizations_local.upsert_organization(
                        organization_dict=organization_dict
                    )
                )
                organization_id = upsert_organization_result.get("organization_id")
                organzation_ml_ids_list = upsert_organization_result.get(
                    "organization_ml_ids_list"
                )
                organization_job_title_dict["organization_id"] = organization_id
                organization_job_title_dict["organization_ml_ids_list"] = (
                    organzation_ml_ids_list
                )

    def _create_organization_dict(self, organization_name: str) -> dict:

        organization_dict = {
            "is_approved": 0,
            "is_main": 1,
            "point": Point(0, 0),  # TODO: how are we supposed to get the point?
            "location_id": LocationLocalConstants.UNKNOWN_LOCATION_ID,
            # TODO: how are we supposed to get the location_id?
            "profile_id": 0,  # TODO: how are we supposed to get the profile_id?
            "parent_organization_id": 1,
            "non_members_visibility_scope_id": 0,
            "members_visibility_scope_id": 0,
            "Non_members_visibility_profile_id": 0,
            "created_user_id": self.user_context.get_effective_user_id(),
            "created_real_user_id": self.user_context.get_real_user_id(),
            "created_effective_user_id": self.user_context.get_effective_user_id(),
            "created_effective_profile_id": self.user_context.get_effective_profile_id(),
            "updated_user_id": self.user_context.get_effective_user_id(),
            "updated_real_user_id": self.user_context.get_real_user_id(),
            "updated_effective_user_id": self.user_context.get_effective_user_id(),
            "updated_effective_profile_id": self.user_context.get_effective_profile_id(),
            "main_group_id": 1,
            "lang_code": self.user_context.get_effective_profile_preferred_lang_code_string(),  # TODO: is this correct?
            "name": organization_name,
            "title": organization_name,
            "is_name_approved": 0,
            "is_description_approved": 0,
        }

        return organization_dict

    def _insert_organization_profile(
        self,
        contact_dict: dict,
    ) -> list:
        if contact_dict.get("created_for_contact_profile_id"):
            profiles_ids_list = [contact_dict.get("created_for_contact_profile_id")]
        else:
            profiles_ids_list = (
                contact_dict.get("profiles_ids_list")
                if contact_dict.get("profiles_ids_list")
                else []
            )
            # TODO: If we have more than one profile_id in the list, how can we find out which profile belongs to the google contact?
            if len(profiles_ids_list) != 1:
                profiles_ids_list = []
                return
        profile_id = profiles_ids_list[0]
        organizations_job_titles_dicts_list: list[dict] = contact_dict.get(
            "organizations_job_titles_dicts_list"
        )
        organization_profiles_ids_list: list[dict] = []
        for organization_job_title_dict in organizations_job_titles_dicts_list:
            organization_id = organization_job_title_dict.get("organization_id")
            organization_ml_id = organization_job_title_dict.get("organization_ml_id")
            job_title_id = organization_job_title_dict.get("job_title_id")
            job_title_ml_id = organization_job_title_dict.get("job_title_ml_id")
            data_dict = {
                "organization_ml_id": organization_ml_id,
                "job_title_id": job_title_id,
                "job_title_ml_id": job_title_ml_id,
            }
            if organization_id is None:
                continue
            organization_profile_id = self.organization_profile.upsert_mapping(
                organization_id=organization_id,
                profile_id=profile_id,
                data_dict=data_dict,
            )
            organization_profiles_ids_list.append(organization_profile_id)
        contact_dict["organization_profiles_ids_list"] = organization_profiles_ids_list

    # TODO Shall we move it to contact_group repo? So both csv repo and this repo will use those methods - same as the other methods here.
    def _insert_link_contact_groups(self, contact_dict: dict) -> list:
        contact_id = contact_dict.get("contact_id")
        # TODO groups_list_of_dicts
        groups = []
        linked_groups_results_list = None
        # organization = contact_dict.get("organization")
        organizations_job_titles_dicts_list = (
            contact_dict.get("organizations_job_titles_dicts_list") or []
        )
        for organization_ids_info_dict in organizations_job_titles_dicts_list:
            organization_id = organization_ids_info_dict.get("organization_id")
            organization_ml_ids_list = organization_ids_info_dict.get(
                "organization_ml_ids_list"
            )
            organization_name = organization_ids_info_dict.get("name")
            job_title = organization_ids_info_dict.get("title")
            if organization_id:
                organization_group_dict = {
                    "name": organization_name,
                    "hashtag": "#" + organization_name.upper(),
                    "is_organization": 1,
                    "main_group_type_id": self.organization_main_group_type_id,  # TODO: Shall we get it from db or from constant?
                    # ml table
                    "is_main_title": False,
                    "title": organization_name,
                    "organization_id": organization_id,
                    "organization_ml_ids_list": organization_ml_ids_list,
                }
                groups.append(organization_group_dict)
            if job_title:
                job_title_group_dict = {
                    "name": job_title,
                    "hashtag": "#" + job_title.upper(),
                    "is_job_title": 1,
                    "main_group_type_id": self.job_title_main_group_type_id,  # TODO: Shall we get it from db or from constant?
                    # ml table
                    "is_main_title": False,
                    "title": job_title,
                    "organization_id": organization_id,
                    "organization_ml_ids_list": organization_ml_ids_list,
                }
                groups.append(job_title_group_dict)
        # TODO: delete this old code
        # if organization:
        #     organization_group_dict = {
        #         "name": organization,
        #         "hashtag": '#' + organization.upper(),
        #         "is_organization": 1,
        #         "main_group_type_id": self.organization_main_group_type_id,     # TODO: Shall we get it from db or from constant?
        #         # ml table
        #         "is_main_title": False,
        #         "title": organization,
        #     }
        #     groups.append(organization_group_dict)
        # job_title = contact_dict.get("job_title")
        # if job_title:
        #     job_title_group_dict = {
        #         "name": job_title,
        #         "hashtag": '#' + job_title.upper(),
        #         "is_job_title": 1,
        #         "main_group_type_id": self.job_title_main_group_type_id,     # TODO: Shall we get it from db or from constant?
        #         # ml table
        #         "is_main_title": False,
        #         "title": job_title,
        #     }
        #     groups.append(job_title_group_dict)
        for group in self.groups_list:
            groups.append(group)
        if len(groups) > 0:
            # TODO: Add organization_id to each result of a job_title group
            linked_groups_results_list = (
                self.contact_group.insert_link_contact_group_with_group_local(
                    contact_id=contact_id, groups_list_of_dicts=groups
                )
            )
            for linked_group_result in linked_groups_results_list:
                job_title_id = linked_group_result.get("job_title_id")
                if job_title_id is not None:
                    job_titile_ml_id = linked_group_result.get("job_title_ml_id")
                    group_job_title_id = linked_group_result.get("group_job_title_id")
                    job_titile_profile_id = linked_group_result.get(
                        "job_title_profile_id"
                    )
                    for (
                        organization_job_title_info_dict
                    ) in organizations_job_titles_dicts_list:
                        if (
                            linked_group_result.get("organization_id")
                            == organization_job_title_info_dict.get("organization_id")
                            and organization_job_title_info_dict.get("job_title_id")
                            is None
                        ):
                            organization_job_title_info_dict["job_title_id"] = (
                                job_title_id
                            )
                            organization_job_title_info_dict["job_title_ml_id"] = (
                                job_titile_ml_id
                            )
                            organization_job_title_info_dict["group_job_title_id"] = (
                                group_job_title_id
                            )
                            organization_job_title_info_dict["job_title_profile_id"] = (
                                job_titile_profile_id
                            )
        contact_dict["linked_group_results_list"] = linked_groups_results_list

        return linked_groups_results_list

    def _insert_link_contact_persons(self, contact_dict: dict) -> dict:
        if not contact_dict.get("first_name") and not contact_dict.get("last_name"):
            return {}
        phones_local = PhonesLocal()
        phone_dict = contact_dict.get("phone_dict1")
        contact_phone_number = phone_dict.get("canonicalForm") if phone_dict else None
        if contact_phone_number:
            result_dict = phones_local.normalize_phone_number(
                original_number=contact_phone_number, region=None
            )
            if result_dict:
                contact_normalized_phone_number = result_dict.get(
                    "full_number_normalized"
                )
        else:
            contact_normalized_phone_number = None
        contact_person_result_dict = (
            self.contact_persons.insert_contact_and_link_to_existing_or_new_person(
                contact_dict=contact_dict,
                contact_email_address=contact_dict["email1"],
                contact_normalized_phone_number=contact_normalized_phone_number,
            )
            or {}
        )

        return contact_person_result_dict

    # TODO Move this method to ContactEmailAddresesLocal Class preferable in seperate repo,
    # TODO inherith GenericMapping Class
    def _insert_link_contact_email_addresses(self, contact_dict: dict) -> None:
        email1 = contact_dict.get("email1")
        email2 = contact_dict.get("email2")
        email3 = contact_dict.get("email3")
        if email1:
            self.contact_email_addresses.insert_contact_and_link_to_email_address(
                contact_dict=contact_dict, contact_email_address_str=email1
            )
        if email2:
            self.contact_email_addresses.insert_contact_and_link_to_email_address(
                contact_dict=contact_dict, contact_email_address_str=email2
            )
        if email3:
            self.contact_email_addresses.insert_contact_and_link_to_email_address(
                contact_dict=contact_dict, contact_email_address_str=email3
            )

    @staticmethod
    # TODO Same
    def _insert_link_contact_notes_and_text_blocks(contact_dict: dict) -> Optional[int]:
        contact_notes = ContactNotesLocal(contact_dict=contact_dict)
        insert_information = contact_notes.insert_contact_notes_text_block() or {}
        contact_note_id = insert_information.get("contact_note_id")

        return contact_note_id

    # TODO Same
    def _insert_link_contact_phones(self, contact_dict: dict) -> None:
        phone_dict1 = contact_dict.get("phone_dict1")
        phone_number_original1 = (
            phone_dict1.get("canonicalForm") if phone_dict1 else None
        )
        phone_dict2 = contact_dict.get("phone_dict2")
        phone_number_original2 = (
            phone_dict2.get("canonicalForm") if phone_dict2 else None
        )
        phone_dict3 = contact_dict.get("phone_dict3")
        phone_number_original3 = (
            phone_dict3.get("canonicalForm") if phone_dict3 else None
        )
        if phone_number_original1:
            # TODO I was expecting only two parameters contact and phone
            self.contact_phones.insert_contact_and_link_to_existing_or_new_phone(
                contact_dict=contact_dict, phone_number_original=phone_number_original1
            )
        if phone_number_original2:
            self.contact_phones.insert_contact_and_link_to_existing_or_new_phone(
                contact_dict=contact_dict, phone_number_original=phone_number_original2
            )
        if phone_number_original3:
            self.contact_phones.insert_contact_and_link_to_existing_or_new_phone(
                contact_dict=contact_dict, phone_number_original=phone_number_original3
            )

    # TODO Why do we create user_external to every contact? How can we know which email_address to use?
    # TODO: if we have Instagram userid, LinkedIn userid .... create User External for this person
    def _insert_link_contact_user_external(self, contact_dict: dict) -> int:
        contact_id = contact_dict.get("contact_id")
        contact_user_external_id = self.contact_user_external.insert_contact_and_link_to_existing_or_new_user_external(
            contact_dict=contact_dict,
            # TODO Why email1? How can we know?
            contact_email_address_str=contact_dict["email1"],
            contact_id=contact_id,
            user_external_dict={"username": contact_dict["email1"]},
        )

        return contact_user_external_id

    def _insert_contact_profiles(self, contact_dict: dict) -> dict:
        # TODO We should link the contact to the person and the person to the profiles
        insert_information = (
            self.contact_profiles.insert_and_link_contact_profile(
                contact_dict=contact_dict
            )
            or {}
        )

        return insert_information

    # TODO Same
    def _insert_link_contact_domains(self, contact_dict: dict) -> list[dict]:
        contact_id = contact_dict.get("contact_id")
        profiles_ids = contact_dict.get("profiles_ids_list")
        website_count = 1
        website_url = contact_dict.get("website" + str(website_count))
        domain_insert_information_list = []
        while website_url:
            if DomainLocal.is_domain(website_url):
                domain_insert_information = self.domain.link_contact_to_domain(
                    contact_id=contact_id, url=website_url
                )
                domain_insert_information_list.append(domain_insert_information)
            elif DomainLocal.is_url(website_url):
                url_insert_information = self.domain.link_contact_to_url(
                    contact_id=contact_id, profiles_ids=profiles_ids, url=website_url
                )
                domain_insert_information_list.append(url_insert_information)
            else:
                self.logger.warining(
                    f"__insert_link_contact_domains: website_url: {website_url} is not a valid domain or url"
                )
            website_count += 1
            website_url = contact_dict.get("website" + str(website_count))

        return domain_insert_information_list

    # TODO Same
    def _insert_link_contact_location(self, contact_dict: dict) -> Optional[list[dict]]:
        contact_id = contact_dict.get("contact_id")
        if not contact_dict.get("location_dicts"):
            return
        location_dicts = self.__procces_location_of_google_contact(contact_dict)
        location_results = []
        for location_dict in location_dicts:
            location_result = self.contact_location.insert_contact_and_link_to_location(
                location_dict=location_dict, contact_id=contact_id
            )
            location_results.append(location_result)

        return location_results

    # TODO Can we move this method to people package so both import-conctact-csv and sync-google-contact will use the same method
    def _insert_importer(
        self,
        contact_id: int,
        location_id: int,
        user_external_id: int,
        data_source_instance_id: int,
        google_people_api_resource_name: str,
    ) -> int:
        importer_id = self.importer.insert(
            data_source_instance_id=data_source_instance_id,
            data_source_type_id=GoogleContactConstants.DATA_SOURCE_TYPE_ID,
            location_id=location_id,
            entity_type_id=GoogleContactConstants.CONTACT_ENTITY_TYPE_ID,
            entity_id=contact_id,
            url="www.google.com",
            user_external_id=user_external_id,
            google_people_api_resource_name=google_people_api_resource_name,
        )

        return importer_id

    # TODO: see if you can improve this method
    def __procces_location_of_google_contact(self, contact_dict: dict) -> list:
        """
        Process location of Google contact
        :param contact_dict: location_dict
        :return: location_dict
        """
        location_dicts = contact_dict.get("location_dicts")
        phone_numbers_list = self.__get_phone_numbers_list(contact_dict)
        email_addresses_list = self.__get_email_addresses_list(contact_dict)

        if not location_dicts and not phone_numbers_list and not email_addresses_list:
            return
        # TODO: How can we add location type?
        processed_location_dicts = []
        for location_dict in location_dicts:
            if not location_dict:
                continue
            country_code = location_dict.get("countryCode")
            country = pycountry.countries.get(alpha_2=country_code)
            country_name = country.name.upper() if country else None
            # TODO Please confirm all fields which are unknown are Null in the database
            current_location_dict = {
                "address_local_language": location_dict.get("streetAddress"),
                "city": location_dict.get("city"),
                "postal_code": location_dict.get("postalCode"),
                "country": country_name,
                "coordinate": Point(0, 0),
                "neighborhood": LocationLocalConstants.DEFAULT_NEGIHBORHOOD_NAME,
                "county": LocationLocalConstants.DEFAULT_COUNTY_NAME,
                "state": LocationLocalConstants.DEFAULT_STATE_NAME,
                "region": LocationLocalConstants.DEFAULT_REGION_NAME,
            }
            processed_location_dicts.append(current_location_dict)
        for phone_number in phone_numbers_list:
            country = Country.get_country_name_by_phone_number(phone_number)
            current_location_dict = {
                "address_local_language": None,
                "city": None,
                "postal_code": None,
                "country": country,
                "coordinate": LocationLocalConstants.DEFAULT_COORDINATE,
                "neighborhood": None,
                "county": None,
                "state": None,
                "region": None,
            }
            # Before adding the location to the list, check if it's country is not already in the list
            for location_dict in processed_location_dicts:
                if location_dict.get("country") == country:
                    current_location_dict = None
                    break
            if current_location_dict:
                processed_location_dicts.append(current_location_dict)
        for email_address in email_addresses_list:
            country = Country.get_country_name_by_email_address(email_address)
            current_location_dict = {
                "address_local_language": None,
                "city": None,
                "postal_code": None,
                "country": country,
                "coordinate": Point(0, 0),
                "neighborhood": LocationLocalConstants.DEFAULT_NEGIHBORHOOD_NAME,
                "county": LocationLocalConstants.DEFAULT_COUNTY_NAME,
                "state": LocationLocalConstants.DEFAULT_STATE_NAME,
                "region": LocationLocalConstants.DEFAULT_REGION_NAME,
            }
            # Before adding the location to the list, check if it's country is not already in the list
            for location_dict in processed_location_dicts:
                if location_dict.get("country") == country:
                    current_location_dict = None
                    break
            if current_location_dict:
                processed_location_dicts.append(current_location_dict)

        return processed_location_dicts

    @staticmethod
    # TODO __get_phone_numbers_list_by_contact_dict
    # TODO add type to the list return type in all methods/functions
    def __get_phone_numbers_list(contact_dict: dict) -> list:

        phones_list = []
        phone_dict1 = contact_dict.get("phone_dict1")
        phone_dict2 = contact_dict.get("phone_dict2")
        phone_dict3 = contact_dict.get("phone_dict3")
        if phone_dict1:
            phone_number1 = phone_dict1.get("canonicalForm") or phone_dict1.get("value")
            phones_list.append(phone_number1)
        if phone_dict2:
            phone_number2 = phone_dict2.get("canonicalForm") or phone_dict2.get("value")
            phones_list.append(phone_number2)
        if phone_dict3:
            phone_number3 = phone_dict3.get("canonicalForm") or phone_dict3.get("value")
            phones_list.append(phone_number3)

        return phones_list

    @staticmethod
    # TODO __get_email_address_list_by_contact_dict
    # TODO add type to the list return type in all methods/functions
    def __get_email_addresses_list(contact_dict: dict) -> list:

        emails_list = []
        # TODO use enum const for "email1" ....
        email1 = contact_dict.get("email1")
        emails_list.append(email1) if email1 else None
        email2 = contact_dict.get("email2")
        emails_list.append(email2) if email2 else None
        email3 = contact_dict.get("email3")
        emails_list.append(email3) if email3 else None

        return emails_list

    # TODO Please documentation, what works? What doesn't work?
    # TODO: let ImporterSyncConflictResolution import UpdateStatus from database-mysql-local
    def __conflict_resolution(
        self, last_modified_timestamp: str, contact_id: int
    ) -> ImporterUpdateStatus:
        """
        Conflict resolution for Google contact
        :return: contact_dict
        """

        if not contact_id:
            return ImporterUpdateStatus.DONT_UPDATE
        sync_conflict_resolution = ImporterSyncConflictResolution()
        update_status: ImporterUpdateStatus = (
            sync_conflict_resolution.get_update_status(
                last_modified_timestamp=last_modified_timestamp,
                data_source_instance_id=GoogleContactConstants.DATA_SOURCE_TYPE_ID,
                entity_type_id=GoogleContactConstants.CONTACT_ENTITY_TYPE_ID,
                entity_id=contact_id,
            )
        )

        return update_status

    @staticmethod
    # TODO Let's use existing function from python-sdk, or move this function to python-sdk
    def __get_formatted_timestamp(last_modified_timestamp_str: str) -> Optional[str]:
        if not last_modified_timestamp_str:
            return
        timestamp = datetime.strptime(
            last_modified_timestamp_str, "%Y-%m-%dT%H:%M:%S.%fZ"
        )
        timestamp = timestamp.replace(tzinfo=ZoneInfo("UTC"))
        formatted_timestamp = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        return formatted_timestamp

    def _update_contact_dict_with_upsert_result(
        self, *, contact_dict: dict, upsert_result_dict: dict
    ) -> dict:
        contact_dict["contact_id"] = upsert_result_dict.get("contact_id")
        main_profile_id = upsert_result_dict.get("main_profile_id")
        if main_profile_id:
            contact_dict["main_profile_id"] = main_profile_id
        person_id = upsert_result_dict.get("person_id")
        if person_id:
            contact_dict["person_id"] = person_id
        job_title_ml_id = upsert_result_dict.get("job_title_ml_id")
        if job_title_ml_id:
            contact_dict["job_title_ml_id"] = job_title_ml_id
        organization_profile_id = upsert_result_dict.get("organization_profile_id")
        if organization_profile_id:
            contact_dict["organization_profile_id"] = organization_profile_id

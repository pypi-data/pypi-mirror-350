import abc
from . import block_date as block_date
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from dojo import money as money
from dojo.common.constants import Chain as Chain
from dojo.config import cfg as cfg, contract_setup as contract_setup
from dojo.utils import timings as timings
from eth_typing import HexStr
from eth_typing.evm import Address as Address, ChecksumAddress, HexAddress
from hexbytes.main import HexBytes
from typing import Any, Callable
from web3 import Web3 as Web3
from web3.contract.contract import Contract as Contract, ContractFunction as ContractFunction
from web3.providers import JSONBaseProvider as JSONBaseProvider
from web3.types import PendingTx, RPCResponse as RPCResponse, Timestamp as Timestamp

anvil_setCode: Incomplete
anvil_setStorageAt: Incomplete
evm_mine: Incomplete
logger: Incomplete
AbiEntry: Incomplete

def patch_provider(provider: JSONBaseProvider) -> None: ...

@dataclass
class _Stats:
    total_transactions: int = ...
    failed_transactions: int = ...
    def __init__(self, total_transactions=..., failed_transactions=...) -> None: ...

@dataclass
class PendingTransaction:
    tx_hash: HexBytes
    process_reciept: Callable[..., Any]
    def __init__(self, tx_hash, process_reciept) -> None: ...

class BaseBackend(ABC, metaclass=abc.ABCMeta):
    web3: Web3
    state: Incomplete
    block: int
    start_block: int
    end_block: int
    contracts: Incomplete
    name2address: Incomplete
    address2name: Incomplete
    pending_transactions: Incomplete
    chain: Incomplete
    stats: Incomplete
    port: Incomplete
    def __init__(self, *, chain: Chain, port: int | None = None) -> None: ...
    def mine_block(self, force: bool = True) -> None: ...
    def contract_call(self, function: ContractFunction, function_params: list[Any] | tuple[()] | tuple[Any, ...], call_params: dict[str, Any] | None = None) -> Any: ...
    def contract_transact_with_postprocess(self, function: ContractFunction, function_params: list[Any] | tuple[()] | tuple[Any, ...], transact_params: dict[str, Any] | None, process_reciept: Callable[..., Any]) -> PendingTx: ...
    def contract_transact(self, function: ContractFunction, function_params: list[Any] | tuple[()] | tuple[Any, ...], transact_params: dict[str, Any] | None = None) -> PendingTx: ...
    @abstractmethod
    def connect(self, block_range: tuple[int, int], backend: str = 'anvil') -> None: ...
    def save_state(self) -> None: ...
    def load_state(self) -> None: ...
    def web3_contract(self, address: Address, abi: str) -> Contract: ...
    def register_contract(self, name: str, contract: Contract) -> None: ...
    def get_contract(self, name: str) -> Contract: ...
    def set_code(self, contract_address: HexAddress, code: HexBytes) -> None: ...
    def set_storage(self, contract_address: HexAddress, storage_address: HexAddress, storage_value: HexStr) -> None: ...
    def deploy_generic_erc20_token(self, token_name: str) -> Contract: ...
    def deploy_live_contract(self, protocol: str, name: str, args: list[Any] = [], bytecode: str | None = None) -> Contract: ...
    def lookup(self, name_or_address: ChecksumAddress | str) -> str: ...
    def rpc_url(self) -> str: ...
    def block_to_timestamp(self, block_number: int) -> Timestamp: ...
    def block_to_datetime(self, block_number: int) -> datetime: ...
    def mint_token(self, token: str, quantity: int | Decimal) -> None: ...

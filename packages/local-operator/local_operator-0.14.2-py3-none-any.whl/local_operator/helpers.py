"""Helper functions for processing and manipulating response content and environment.

This module contains utility functions designed to assist in the handling and
modification of response content generated by the language model, as well as
functions for managing the execution environment. These functions are crucial
for maintaining the integrity and usability of the responses and ensuring proper
setup for subprocess execution across different operating systems.
"""

import json
import logging
import os
import platform
import re
import subprocess
import sys

from local_operator.types import ResponseJsonSchema

# Configure logging (optional, but helpful for debugging)
# Use sys.stdout to ensure logs appear if running as a GUI app without a console
# Note: BasicConfig should ideally be called only once at application entry point.
# If called elsewhere, it might not reconfigure. Consider moving this to main app setup.
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", stream=sys.stdout
)
logger = logging.getLogger(__name__)


# --- Response Cleaning ---


def remove_think_tags(response_content: str) -> str:
    """
    Remove the content enclosed within <think> and </think> tags from the response content.

    Args:
        response_content (str): The original response content potentially containing <think> tags.

    Returns:
        str: The response content with <think> and </think> tags and their content removed.
    """
    if "<think>" in response_content:
        start_think_index = response_content.find("<think>")
        end_think_index = response_content.rfind("</think>")
        if start_think_index != -1 and end_think_index != -1:
            response_content = (
                response_content[:start_think_index]
                + response_content[end_think_index + len("</think>") :].strip()
            )
    return response_content


def clean_plain_text_response(response_content: str) -> str:
    """
    Clean plain text responses like reflection and planning by removing code blocks and
    standalone JSON.

    Args:
        response_content (str): The original plain text response potentially containing
                               code blocks or JSON objects.

    Returns:
        str: The cleaned response with code blocks and standalone JSON removed.
    """
    # Check if the entire content is a JSON object
    if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
        try:
            json.loads(response_content.strip())
            # If it parses as valid JSON, remove it completely
            return ""
        except json.JSONDecodeError:
            # Not valid JSON, keep the content
            pass

    # Remove code blocks
    lines = response_content.split("\n")
    cleaned_lines = []
    in_code_block = False
    code_block_start_index = -1

    for i, line in enumerate(lines):
        if line.strip().startswith("```"):
            if not in_code_block:
                in_code_block = True
                code_block_start_index = i
            else:
                in_code_block = False
                # Add an empty line if there's content before and after the code block
                if code_block_start_index > 0 and i < len(lines) - 1:
                    cleaned_lines.append("")
            continue
        if not in_code_block:
            cleaned_lines.append(line.rstrip())

    cleaned_content = "\n".join(cleaned_lines)

    # Remove JSON objects embedded in the text
    pattern = r'\{(?:[^{}]|"[^"]*")*\}'
    cleaned_content = re.sub(pattern, "", cleaned_content)

    # Clean up any double spaces and preserve line breaks
    cleaned_content = re.sub(r" +", " ", cleaned_content)

    # Remove trailing spaces at the end of each line and leading spaces at the beginning
    # of each line
    cleaned_content = "\n".join(line.strip() for line in cleaned_content.split("\n"))

    return cleaned_content.strip()


def clean_json_response(response_content: str) -> str:
    """
    Clean JSON responses by extracting the JSON content from various formats.

    Args:
        response_content (str): The original JSON response potentially containing
                               code blocks, markdown formatting, or other text.

    Returns:
        str: The extracted JSON content as a string.
    """
    response_content = remove_think_tags(response_content)

    # Special case for the format: ```json\n{...}\n```
    start = response_content.strip().startswith("```json")
    end = response_content.strip().endswith("```")
    if start and end:
        start_marker = "```json\n"
        if start_marker in response_content:
            start_idx = response_content.find(start_marker) + len(start_marker)
            end_idx = response_content.rfind("\n```")
            if end_idx != -1 and end_idx > start_idx:
                result = response_content[start_idx:end_idx].strip()
                if result.endswith("}"):
                    return result

    # Check if the entire content is already valid JSON
    try:
        if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
            json.loads(response_content.strip())
            return response_content.strip()
    except json.JSONDecodeError:
        pass

    # Always search for JSON in code blocks regardless of leading text
    json_block_marker = "```json\n"
    if json_block_marker in response_content:
        start_index = response_content.find(json_block_marker) + len(json_block_marker)
        end_marker = "\n```"
        end_index = response_content.find(end_marker, start_index)

        if end_index != -1:
            json_content = response_content[start_index:end_index].strip()

            # Check for a complete JSON object
            if json_content.startswith("{") and json_content.endswith("}"):
                try:
                    json.loads(json_content)
                    return json_content
                except json.JSONDecodeError:
                    pass

            # If full content isn't parseable, try to extract the JSON object
            first_brace = json_content.find("{")
            last_brace = json_content.rfind("}")

            if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                extracted_json = json_content[first_brace : last_brace + 1]
                try:
                    json.loads(extracted_json)
                    return extracted_json
                except json.JSONDecodeError:
                    pass

    # Check for JSON code block format with triple backticks
    is_json_start = response_content.strip().startswith("```json")
    is_json_end = response_content.strip().endswith("```")
    if is_json_start and is_json_end:
        # Extract content between the first ```json and the last ```
        content = response_content.strip()
        start_index = content.find("```json") + len("```json")
        end_index = content.rfind("```")
        if start_index < end_index:
            extracted_content = content[start_index:end_index].strip()
            # Make sure we don't have trailing backticks in the extracted content
            if extracted_content.endswith("```"):
                extracted_content = extracted_content[:-3].strip()
            try:
                json.loads(extracted_content)
                return extracted_content
            except json.JSONDecodeError:
                pass

    # Check for JSON code block format with triple backticks
    json_block_patterns = ["```json\n", "```\n"]

    for pattern in json_block_patterns:
        if pattern in response_content and not is_marker_inside_json(response_content, pattern):
            start_index = response_content.find(pattern)
            content_after_marker = response_content[start_index + len(pattern) :]

            # Find the closing backticks that are not inside a JSON structure
            end_index = content_after_marker.find("```")  # Initial find

            while end_index != -1 and is_marker_inside_json(
                content_after_marker[: end_index + 3], "```"  # Check based on original slice
            ):
                # Search *after* the found marker in the original slice
                search_start = end_index + 3
                next_end = content_after_marker.find("```", search_start)
                if next_end == -1:
                    end_index = -1  # No more markers found
                    break
                end_index = next_end  # Update end_index to the new position

            if end_index != -1:
                extracted_content = content_after_marker[:end_index].strip()

                # Special handling for nested JSON with code blocks
                if "```json{" in extracted_content:
                    # Find the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            pass

                # If the content has trailing backticks or newlines (followed by
                # backticks), clean them up
                if "\n```" in extracted_content:
                    extracted_content = extracted_content.split("\n```")[0].strip()
                elif extracted_content.endswith("```"):
                    extracted_content = extracted_content[:-3].strip()

                # Try to parse the entire extracted content first
                try:
                    json.loads(extracted_content)
                    return extracted_content
                except json.JSONDecodeError:
                    # If that fails, look for the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            # If still not valid, return the extracted content as-is
                            pass

                # If we couldn't find valid JSON but have a clean content, return it
                return extracted_content

    # If no specific markers found, try to extract JSON object directly
    # Look for the first { and the last }
    first_brace = response_content.find("{")
    last_brace = response_content.rfind("}")

    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
        extracted_json = response_content[first_brace : last_brace + 1].strip()
        try:
            json.loads(extracted_json)
            # Return the validated JSON if parsing succeeds
            return extracted_json
        except json.JSONDecodeError:
            # If not valid JSON, continue to the final return
            pass

    # Special case for the test with leading text and json code block
    if "```json\n" in response_content and "\n```" in response_content:
        # Get content between ```json\n and \n```
        start_idx = response_content.find("```json\n") + len("```json\n")
        end_idx = response_content.find("\n```", start_idx)
        if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
            json_content = response_content[start_idx:end_idx].strip()
            if json_content.startswith("{") and json_content.endswith("}"):
                return json_content

    # If we couldn't extract valid JSON, return the original content
    return response_content.strip()


def process_json_response(response_str: str) -> ResponseJsonSchema:
    """Process and validate a JSON response string from the language model.

    Args:
        response_str (str): Raw response string from the model, which may be wrapped in
            markdown-style JSON code block delimiters (```json) or provided as a plain JSON object.

    Returns:
        ResponseJsonSchema: Validated response object containing the model's output.
            See ResponseJsonSchema class for the expected schema.

    Raises:
        ValidationError: If the JSON response does not match the expected schema.
        ValueError: If no valid JSON object can be extracted from the response.
    """
    response_content = clean_json_response(response_str)

    # Validate the JSON response
    response_json = ResponseJsonSchema.model_validate_json(response_content)

    return response_json


def is_marker_inside_json(text: str, marker: str) -> bool:
    """
    Check if a marker is inside a JSON structure by analyzing the string.

    Args:
        text (str): The text to analyze
        marker (str): The marker to check

    Returns:
        bool: True if the marker appears to be inside a JSON structure, False otherwise
    """
    marker_pos = text.find(marker)
    if marker_pos == -1:
        return False

    # Count opening and closing braces before the marker
    open_braces = text[:marker_pos].count("{")
    close_braces = text[:marker_pos].count("}")

    # If we have more opening braces than closing ones before the marker,
    # the marker is likely inside a JSON structure
    return open_braces > close_braces


# --- Environment Setup ---


def get_windows_registry_path() -> str | None:
    """
    Retrieves the effective PATH from the Windows Registry (User and System).
    Combines User and System PATHs, prioritizing User entries.

    Returns:
        str | None: The combined PATH string or None if an error occurs or not on Windows.
    """
    if platform.system() != "Windows":
        logger.debug("Not on Windows, skipping registry PATH retrieval.")
        return None

    try:
        # winreg is only available on Windows
        import winreg

        user_path = ""
        system_path = ""

        # Read User PATH from HKEY_CURRENT_USER\Environment
        try:
            # Open the key for reading
            with winreg.OpenKey(  # type: ignore
                winreg.HKEY_CURRENT_USER, "Environment", 0, winreg.KEY_READ  # type: ignore
            ) as user_key:
                # Query the 'Path' value
                user_path, _ = winreg.QueryValueEx(user_key, "Path")  # type: ignore
                logger.info(f"Retrieved User PATH from registry: {user_path}")
        except FileNotFoundError:
            # It's normal for the Path value or even the Environment key to not exist for a user
            logger.warning("User PATH not found in registry (this might be normal).")
            user_path = ""
        except Exception as e:
            logger.error(f"Error reading User PATH from registry: {e}")
            return None  # Return None on error

        # Read System PATH from HKEY_LOCAL_MACHINE\...
        try:
            # Open the key for reading
            with winreg.OpenKey(  # type: ignore
                winreg.HKEY_LOCAL_MACHINE,  # type: ignore
                r"SYSTEM\CurrentControlSet\Control\Session Manager\Environment",
                0,
                winreg.KEY_READ,  # type: ignore
            ) as system_key:
                # Query the 'Path' value
                system_path, _ = winreg.QueryValueEx(system_key, "Path")  # type: ignore
                logger.info(f"Retrieved System PATH from registry: {system_path}")
        except FileNotFoundError:
            logger.warning("System PATH not found in registry (this is unusual).")
            system_path = ""
        except Exception as e:
            logger.error(f"Error reading System PATH from registry: {e}")
            return None  # Return None on error

        # Combine User and System PATHs, prioritizing User entries
        # Use os.pathsep for platform compatibility (';' on Windows, ':' on POSIX)
        combined_paths = []
        if user_path:
            combined_paths.extend(user_path.split(os.pathsep))
        if system_path:
            combined_paths.extend(system_path.split(os.pathsep))

        # Remove duplicates while preserving order (simple approach)
        seen = set()
        effective_path_list = []
        for path_entry in combined_paths:
            # Normalize path separators for comparison if needed, though
            # usually not critical for set membership
            # Ensure path_entry is not empty before adding
            if path_entry and path_entry not in seen:
                effective_path_list.append(path_entry)
                seen.add(path_entry)

        effective_path = os.pathsep.join(effective_path_list)
        logger.info(
            "Effective PATH constructed from Windows registry: %s", effective_path
        )  # Use % formatting to help with line length
        return effective_path

    except ImportError:
        # This error occurs if trying to import winreg on non-Windows OS
        logger.error("The 'winreg' module is not available on this platform.")
        return None
    except Exception as e:
        # Catch any other unexpected errors during registry access
        logger.error(f"An unexpected error occurred while getting Windows registry PATH: {e}")
        return None


def get_posix_shell_path() -> str | None:
    """
    Retrieves the user's PATH environment variable from their default login shell on macOS/Linux.
    On Linux, also explicitly checks for and adds ~/.local/bin if it exists and is not in PATH.

    Returns:
        str | None: The PATH string from the login shell, or None if an error occurs.
    """
    if platform.system() not in ["Darwin", "Linux"]:
        logger.debug("Not on POSIX system, skipping shell PATH retrieval.")
        return None

    shell_path = None
    command = None
    try:
        # Determine the default shell, preferring SHELL env var if set
        # Default to /bin/zsh on Darwin (macOS), /bin/bash otherwise
        default_shell = "/bin/bash"
        if platform.system() == "Darwin":
            default_shell = "/bin/zsh"
        shell_path = os.environ.get("SHELL", default_shell)

        logger.debug(f"Using shell: {shell_path}")

        # Construct the command to echo PATH from a login shell
        # Use list format for subprocess.run when shell=False is preferred,
        # but here shell=True is needed for the login shell behavior (-l).
        # Ensure shell_path is quoted if it contains spaces (though unlikely for standard shells)
        command = (
            f"'{shell_path}' -l -c 'echo \"$PATH\"'"  # Use double quotes inside for robustness
        )

        # Run the command. shell=True is necessary here for the '-l' flag to work correctly
        # by invoking the shell itself to interpret the command string.
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True,
            shell=True,
            executable=shell_path,
        )

        full_path = result.stdout.strip()
        if full_path:
            logger.debug(f"Successfully retrieved PATH from login shell: {full_path}")
        else:
            # If the shell command succeeded but returned empty, log a warning
            # and use current PATH as fallback
            logger.warning(
                "Login shell command executed but returned an empty PATH. "
                "Falling back to current os.environ['PATH']."
            )
            full_path = os.environ.get("PATH", "")

        # On Linux, explicitly add ~/.local/bin if it exists and is not already in PATH
        if platform.system() == "Linux":
            local_bin = os.path.expanduser("~/.local/bin")
            if os.path.isdir(local_bin):
                # Check if local_bin is already effectively in the path
                path_list = full_path.split(os.pathsep)
                if local_bin not in path_list:
                    # Prepend ~/.local/bin for higher priority
                    full_path = local_bin + os.pathsep + full_path
                    logger.debug(f"Prepended {local_bin} to PATH.")

        return full_path

    except FileNotFoundError:
        # This occurs if the specified shell_path does not exist
        logger.error(
            "Shell executable not found at '%s'. Cannot get PATH from login shell.",
            shell_path if shell_path is not None else "<unknown>",
        )
        return None
    except subprocess.CalledProcessError as e:
        # This occurs if the shell command returns a non-zero exit code
        logger.error(
            "Failed to get PATH from login shell. Command "
            f"'{command if command is not None else '<unknown>'}' "
            f"failed with error code {e.returncode}."
        )
        logger.error(f"Stderr: {e.stderr.strip()}")
        return None  # Indicate failure
    except Exception as e:
        # Catch any other unexpected errors
        logger.error(f"An unexpected error occurred while getting POSIX shell PATH: {e}")
        return None


def setup_cross_platform_environment():
    """
    Updates the current process's PATH environment variable based on the OS.
    Call this function early in your application's startup.
    """
    logger.debug(f"Setting up subprocess environment for OS: {platform.system()}...")

    original_path = os.environ.get("PATH", "")
    logger.debug(f"Initial PATH: {original_path}")

    user_effective_path = None

    # Determine the OS and call the appropriate function
    os_name = platform.system()
    if os_name == "Windows":
        user_effective_path = get_windows_registry_path()
    elif os_name in ["Darwin", "Linux"]:
        user_effective_path = get_posix_shell_path()
    else:
        logger.warning(f"Unsupported OS: {os_name}. Cannot automatically retrieve effective PATH.")
        # Optionally, you could just use the original_path or raise an error
        return  # Exit the setup function if OS is not supported

    # Update os.environ['PATH'] if a valid, different path was retrieved
    if user_effective_path and user_effective_path != original_path:
        logger.debug(f"Updating os.environ['PATH'] to: {user_effective_path}")
        os.environ["PATH"] = user_effective_path
    elif user_effective_path is None:
        logger.warning(
            "Could not retrieve user's effective PATH. "
            "Subprocess calls will use the initial PATH."
        )
    else:  # Path retrieved is same as original
        logger.debug("Retrieved effective PATH is the same as the initial PATH. No update needed.")

    # Optional: Verification step (example)
    # Try to find a common command expected to be in the user's path
    test_command = None
    if os_name == "Darwin":
        test_command = "brew"
    elif os_name == "Linux":
        test_command = "ls"  # Use a very common command
    elif os_name == "Windows":
        test_command = "choco"

    if test_command:
        which_cmd = None
        try:
            which_cmd = "where" if os_name == "Windows" else "which"
            logger.debug(
                f"Verifying PATH: Attempting to find '{test_command}' using '{which_cmd}'..."
            )
            # Use check=False as the command might legitimately not be installed
            result = subprocess.run(
                [which_cmd, test_command], capture_output=True, text=True, check=False
            )
            if result.returncode == 0 and result.stdout.strip():
                # On Windows, 'where' can return multiple paths, just log the first line
                found_path = result.stdout.strip().splitlines()[0]
                logger.debug(f"Verification successful: Found '{test_command}' at: {found_path}")
            else:
                logger.warning(
                    f"Verification: Could not find '{test_command}' using '{which_cmd}'. "
                    "PATH might be incomplete or command not installed."
                )
                if result.stderr:
                    logger.warning(f"'{which_cmd}' stderr: {result.stderr.strip()}")
        except FileNotFoundError:
            # This happens if 'which' or 'where' itself is not found (highly unlikely)
            logger.warning(
                f"'{which_cmd if which_cmd is not None else '<unknown>'}' command not found. "
                "Cannot verify test command location."
            )
        except Exception as e:
            logger.error(f"Error during verification step trying to find '{test_command}': {e}")

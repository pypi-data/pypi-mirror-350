import numpy as np
from pointcloudlib.utils import get_intrinsics
import open3d as o3d
import cv2


def point_cloud_from_image(
    image: np.ndarray,
    depth_estimation: np.ndarray,
    scale_ratio: int = 100,
    camera_intrinsics=None,
):
    """
    This function generates a point cloud from an image and a depth estimation.
    The point cloud is generated by converting the depth estimation to 3D points and coloring them with the image.
    First the image is resized to fit the depth estimation. The depth estimation is scaled by the scale_ratio.
    The 3D points are calculated using the depth estimation and the camera intrinsics, if no camera matrix is given, it's calculated bya get_intrinsics().

    Args:
        - image (np.ndarray): The image to color the point cloud.
        - depth_estimation (np.ndarray): The depth estimation to generate the point cloud.
        - scale_ratio (int): The scale ratio to apply to the depth estimation. Default is 100.
        - camera_intrinsics (np.ndarray): The camera intrinsics to calculate the 3D points. Default is None.

    Returns:
        - o3d.geometry.PointCloud: The generated point cloud.


    """
    pcd_raw = _make_pcd(image, depth_estimation, scale_ratio, camera_intrinsics)
    return pcd_raw


def _make_pcd(image, depth_estimation, scale_ratio=100, camera_intrinsics=None):
    height, width = depth_estimation.shape

    # Resize image to fit depth_estimation
    image = cv2.resize(image, (width, height))

    # Depth estimation should not have a zero value
    depth_estimation = np.maximum(depth_estimation, 1e-5)
    depth_estimation = scale_ratio / depth_estimation
    x, y, z = _pixel_to_point(depth_estimation, camera_intrinsics)
    points = np.stack((x, y, z), axis=-1)

    cloud = o3d.geometry.PointCloud()
    mask = points[:, :, 2] < 1e2  # Remove points with small z

    cloud.points = o3d.utility.Vector3dVector(points[mask].reshape(-1, 3))
    # open3d uses a 1 dimentional array for coloring the points. Its value is from 0 to 1.
    cloud.colors = o3d.utility.Vector3dVector(image[mask].reshape(-1, 3) / 255)

    return cloud


def _pixel_to_point(depth_estimation, camera_intrinsics):

    height, width = depth_estimation.shape
    if camera_intrinsics is None:
        camera_intrinsics = get_intrinsics(height, width, fov=55)

    fx, fy = camera_intrinsics[0, 0], camera_intrinsics[1, 1]
    cx, cy = camera_intrinsics[0, 2], camera_intrinsics[1, 2]

    x = np.linspace(0, width - 1, width)
    y = np.linspace(0, height - 1, height)
    u, v = np.meshgrid(x, y)

    x_over_z = (u - cx) / fx
    y_over_z = (v - cy) / fy

    z = depth_estimation / np.sqrt(1 + x_over_z**2 + y_over_z**2)
    x = x_over_z * z
    y = y_over_z * z

    return x, y, z

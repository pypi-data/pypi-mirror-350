<html>

<head>
    <!-- d3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- UI : bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fjalla+One&family=Public+Sans:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
</head>

<body>
    <div class="container-fluid">
        <br>
        <div class="row">
            <!-- START OF FORM -->
            <div class="col-sm-2" style="margin-top:100px">
                <form>
                    <!-- X-axis selector -->
                    <div id="x-all-div" class="allsection">
                        <h5 id="x-title" class="sectiontitle">X-axis</h5>
                        <div id="x-div" class="section">
                            <select class="form-select" id="x-select"></select>
                            <div class="form-check">
                                <input id=log10_x class="form-check-input" type="checkbox" value="">
                                <label id=checklabel class="form-check-label" for="log10_checkbox">Log10</label>
                            </div>
                        </div>

                    </div>

                    <!-- Y-axis selector -->
                    <div id="y-all-div" class="allsection">
                        <h5 id="y-title" class="sectiontitle">Y-axis</h5>
                        <div id="y-div" class="section">
                            <select class="form-select" id="y-select"></select>
                            <div class="form-check">
                                <input id=log10_y class="form-check-input" type="checkbox" value="">
                                <label id=checklabel class="form-check-label" for="log10_checkbox">Log10</label>
                            </div>
                        </div>

                    </div>

                    <!-- Size selector -->
                    <div id="s-all-div" class="allsection">
                        <h5 id="s-title" class="sectiontitle">Size</h5>
                        <div id="s-div" class="section">
                            <select class="form-select" id="size-select"></select>
                        </div>
                    </div>

                    <!-- Color selector -->
                    <div id="c-all-div" class="allsection">
                        <h5 id="c-title" class="sectiontitle">Color</h5>
                        <div id="c-div" class="section">
                            <select class="form-select" id="color-select"></select>
                            <div class="form-check">
                                <input id=colblind class="form-check-input" type="checkbox" value="">
                                <label id=checklabel class="form-check-label" for="colblind">Colorblind-safe palette</label>
                            </div>
                        </div>
                    </div>

                    <!-- General checks -->
                    <div id="g-all-div" class="allsection">
                        <h5 id="g-title" class="sectiontitle">General</h5>
                        <div id="g-div" class="section">
                            <div class="form-check">
                                <input id=gridcheck class="form-check-input" type="checkbox" value="" checked>
                                <label id=checklabel class="form-check-label" for="grid">Grid</label>
                            </div>
                            <div class="form-check">
                                <input id=hcolcheck class="form-check-input" type="checkbox" value="">
                                <label id=checklabel class="form-check-label" for="hcolcheck">Hightlight points sharing
                                    the same color group when
                                    hovering</label>
                            </div>
                        </div>
                    </div>

                    <!-- Tooltip radios -->
                    <div id="t-all-div" class="allsection">
                        <h5 id="t-title" class="sectiontitle">Tooltip</h5>
                        <div id="t-div" class="section">
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="radioTooltip" value="1">
                                <label id="checklabel" for="1">Hide</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="radioTooltip" value="2">
                                <label id="checklabel" checked for="2">
                                    All keys
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="radioTooltip" value="3" checked>
                                <label id="checklabel" for="3">
                                    Only scales
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="radioTooltip" value="4">
                                <label id="checklabel" for="4">
                                    Custom
                                </label>
                            </div>
                            <div id="p_customTooltip">
                                <div id="customTooltip">
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- END OF FORM -->
                </form>
            </div>

            <!-- SVG -->
            <div class="col-sm-10">
                <div class="row">
                    <!-- <h2>Title of the graph</h2> -->
                    <svg id="svg"></svg>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <h6 style="margin-left:100px" id="colorTitle"></h6>
                        <svg id="colorlegendsvg"></svg>
                    </div>
                    <div class="col-sm-2">
                        <h6 id="sizeTitle"></h6>
                        <svg id="sizelegendsvg"></svg>
                    </div>
                </div>
            </div>

        </div>
    </div>
    <!-- END OF MAIN VIEW -->

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip">
        <div id="tooltip-content" style="color:black"></div>
    </div>

    <!-- START OF JAVASCRIPT -->
    <script>
        const WWIDTH = window.innerWidth
        const WHEIGHT = window.innerHeight
        const WIDTH = WWIDTH * 0.8
        const HEIGHT = WHEIGHT * 0.8
        const marginTop = 25
        const marginRight = 200
        const marginBottom = 50
        const marginLeft = 100
        const Paultolcol = { '#4477AA': 'blue', '#EE6677': 'cyan', '#228833': 'green', '#CCBB44': 'yellow', '#66CCEE': 'red', '#AA3377': 'purple', '#BBBBBB': 'grey' }
        let xKey = undefined
        let yKey = undefined
        let cKey = undefined
        let sKey = undefined
        let isXLog = false
        let isYLog = false
        let isColBlind = false
        let onTooltip = {}
        let gridOn = true
        let hcolOn = false
        let legendId = {}

        function change_axes(points) {
            /**
             * Should be called when xKey or yKey change : 
             *      - Update axes
             *      - Update grid
             *      - Update points (x,y) coordinates
             *      - Change tooltip
             */

            const duration = 200
            const svg = d3.select("#svg")
            const tooltipChoice = d3.select('input[name="radioTooltip"]:checked').property("value")

            // change axes
            const [x, y] = createXYscale(points)
            svg.selectChild("g#x-axis").transition().duration(duration)
                .call(d3.axisBottom(x).ticks(WIDTH / 80))
                .selectChild("#x-label").text(xKey)
            svg.selectChild("g#y-axis").transition().duration(duration)
                .call(d3.axisLeft(y))

            // wait for the animation to end to correctly place the y-label
            // according to the tick's label position
            requestAnimationFrame(() => {
                const yaxisLeft = svg.select("#y-axis").selectAll(".tick").select("text").nodes().at(-1).getBBox().x
                svg.select("#y-axis").select("text#y-label").attr("y", `${yaxisLeft - 10}px`)
                    .attr("x", (-HEIGHT / 2))
                    .text(yKey)
            })

            // change grid
            svg.selectChild("g#grid").attr("stroke-opacity", gridOn ? 0.1 : 0)
            svg.selectChild("g#grid").selectChild("g#grid-xline").selectAll("line").remove()
            svg.selectChild("g#grid").selectChild("g#grid-xline")
                .selectAll("line")
                .data(x.ticks())
                .join("line")
                // .transition().duration(duration)
                .attr("x1", d => 0.5 + x(d))
                .attr("x2", d => 0.5 + x(d))
                .attr("y1", marginTop)
                .attr("y2", HEIGHT - marginBottom)
            svg.selectChild("g#grid").selectChild("g#grid-yline").selectAll("line").remove()
            svg.selectChild("g#grid").selectChild("g#grid-yline").selectAll("line")
                .data(y.ticks())
                .join("line")
                // .transition().duration(duration)
                .attr("y1", d => 0.5 + y(d))
                .attr("y2", d => 0.5 + y(d))
                .attr("x1", marginLeft)
                .attr("x2", WIDTH - marginRight)


            // change circle
            svg.selectAll(".dots").transition().duration(400).attr("cx", d => x(d[xKey]))
                .attr("cy", d => y(d[yKey]))

            // change Tooltip if on "only scales"
            if (tooltipChoice == "3") {
                setTooltip()
            }

        }

        function change_pts_aspect(points) {
            /**
             * Should be called when sKey or cKey change : 
             *      - Update size and color scales
             *      - Update points (x,y) color and scale
             *      - Change tooltip
             */
            const svg = d3.select("#svg")
            const colorlegendsvg = d3.select("#colorlegendsvg")
            const sizelegendsvg = d3.select("#sizelegendsvg")
            const colorTitle = d3.select("#colorTitle")
            const sizeTitle = d3.select("#sizeTitle")
            const tooltipChoice = d3.select('input[name="radioTooltip"]:checked').property("value")
            const size_selector = d3.select("#size-select")

            let size = d3.scaleSqrt()
                .domain([d3.min(points, d => d[sKey]), d3.max(points, d => d[sKey])])
                .range([2, 20])

            if (size_selector.node().selectedOptions[0].textContent == "None") {
                size = d3.scaleSqrt()
                    .domain([1, 1])
                    .range([2, 20])
            }

            const color = createColorScale(points)

            svg.selectAll(".dots").transition().duration(400)
                .attr("fill", d => color(d[cKey]))
                .attr("r", d => size(d[sKey]))

            // scales change
            if (tooltipChoice == "3") {
                setTooltip()
            }

            colorlegendsvg.selectAll("#otherlegend").selectAll("*").remove()
            sizelegendsvg.selectAll("#otherlegend").selectAll("*").remove()
            colorTitle.html("")
            sizeTitle.html("")
            createSizeLegend(points, size)
            createColorLegend(points, color)
        }


        async function scatterPlot(path, delimiter) {
            /**
             *  Main function : 
             *      - Get input data
             *      - Init selectors (x-axis, y-axis, size, color and cstm tooltip)
             *      - Init scales
             *      - Init svg (create x-axis, y-axis, grid, dots)
             *      - Add listeners
             */

            // get data
            const points = await d3.dsv(delimiter, path, d3.autoType)

            const svg = d3.select("#svg")
                .attr("viewBox", `0 0 ${WIDTH} ${HEIGHT}`)
                .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;")

            const colorlegendsvg = d3.select("#colorlegendsvg")
            // set selector
            const x_selector = d3.select("#x-select")
            const y_selector = d3.select("#y-select")
            const size_selector = d3.select("#size-select")
            const color_selector = d3.select("#color-select")
            const tooltip_radio = d3.selectAll('input[name="radioTooltip"]')
            const customTooltip = d3.select("#customTooltip")
            const log10x = d3.select("#log10_x")
            const log10y = d3.select("#log10_y")
            const gridcheck = d3.select("#gridcheck")
            const hcolcheck = d3.select("#hcolcheck")
            const colblind = d3.select("#colblind")
            console.log(colblind)


            for (let key of Object.entries(points[0])) {
                const new_check = customTooltip.append("g").attr("class", "form-check").style("margin-top", "-6px").attr("id", "div_")
                new_check.append("input")
                    .attr("class", "form-check-input")
                    .attr("id", key[0])
                    .attr("value", key[0])
                    .attr("type", "checkbox")
                    .on("change", eventCustomTooltip)
                new_check.append("label")
                    .html(key[0])
                    .attr("class", "form-check-label")
                    .attr("for", key[0])
                onTooltip[key[0]] = undefined
                if (typeof key[1] !== "string") {
                    x_selector.append("option").html(key[0]).attr("value", key[0])
                    y_selector.append("option").html(key[0]).attr("value", key[0])
                    size_selector.append("option").html(key[0]).attr("value", key[0])
                    color_selector.append("option").html(key[0]).attr("value", key[0])
                }
                else {
                    color_selector.append("option").html(key[0]).attr("value", key[0])
                }
            }
            color_selector.append("option").html("None").attr("value", undefined)
            size_selector.append("option").html("None").attr("value", size_selector.property("value"))

            xKey = x_selector.property("value")
            yKey = y_selector.property("value")
            sKey = size_selector.property("value")
            cKey = color_selector.property("value")
            setTooltip()

            // scales
            const [x, y] = createXYscale(points)

            const size = d3.scaleSqrt()
                .domain([d3.min(points, d => d[sKey]), d3.max(points, d => d[sKey])])
                .range([2, 20])

            const color = createColorScale(points)

            // x-axis
            svg.append("g")
                .attr("transform", `translate(0,${HEIGHT - marginBottom})`)
                .attr("id", "x-axis")
                .call(d3.axisBottom(x).ticks(WIDTH / 80))
                // .call(g => g.select(".domain").remove())
                .call(g => g.append("text")
                    .attr("id", "x-label")
                    .attr("x", WIDTH / 2)
                    .attr("y", marginBottom - 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "end")
                    .style("font-size", "13px")
                    .style("font-weight", "bold")
                    .style("font-family", "Public Sans")
                    .text(xKey))

            // y-axis
            svg.append("g")
                .attr("transform", `translate(${marginLeft},0)`)
                .attr("id", "y-axis")
                .call(d3.axisLeft(y))

            // correctly place the y-label with Bbox 
            const yaxisLeft = svg.select("#y-axis").selectAll(".tick").select("text").nodes().at(-1).getBBox().x
            svg.select("#y-axis").call(g => g.append("text")
                .attr("id", "y-label")
                .attr("x", -(HEIGHT / 2))
                .attr("y", `${yaxisLeft - 10}px`)
                .attr("fill", "currentColor")
                .attr("text-anchor", "start")
                .attr("transform", "rotate(-90)")
                .style("font-size", "13px")
                .style("font-weight", "bold")
                .style("font-family", "Public Sans")
                .text(yKey))

            // grid
            svg.append("g")
                .attr("id", "grid")
                .attr("stroke", "currentColor")
                .attr("stroke-opacity", gridOn ? 0.1 : 0)
                .call(g => g.append("g")
                    .attr("id", "grid-xline")
                    .selectAll("line")
                    .data(x.ticks())
                    .join("line")
                    .attr("x1", d => 0.5 + x(d))
                    .attr("x2", d => 0.5 + x(d))
                    .attr("y1", marginTop)
                    .attr("y2", HEIGHT - marginBottom))
                .call(g => g.append("g")
                    .attr("id", "grid-yline")
                    .selectAll("line")
                    .data(y.ticks())
                    .join("line")
                    .attr("y1", d => 0.5 + y(d))
                    .attr("y2", d => 0.5 + y(d))
                    .attr("x1", marginLeft)
                    .attr("x2", WIDTH - marginRight))


            // Dots
            svg.append("g")
                .selectAll("circle")
                .data(points)
                .join("circle")
                .attr("class", "dots")
                .attr("cx", d => x(d[xKey]))
                .attr("cy", d => y(d[yKey]))
                .attr("fill", d => color(d[cKey]))
                .attr("r", d => size(d[sKey]))
                .on("mouseenter", (event, d) => onFocus(event, d, points))
                .on("mouseleave", (event, d) => {
                    const tooltip = d3.select("#tooltip")
                    tooltip.style("opacity", 0)
                    svg.selectAll(".dots").style("opacity", 1)
                    colorlegendsvg.select(legendId[d[cKey]]).style("font-weight", null)
                })
                .attr("tabindex", 1)
                .on("keydown", (event, d) => onFocus(event, d, points))

            createSizeLegend(points, size)
            createColorLegend(points, color)

            // menu
            setMenu("x")
            setMenu("y")
            setMenu("s")
            setMenu("c")
            setMenu("g")
            setMenu("t")

            // Events
            x_selector.on("change", function () {
                xKey = this.value
                change_axes(points)
            })
            y_selector.on("change", function () {
                yKey = this.value
                change_axes(points)
            })
            size_selector.on("change", function () {
                sKey = this.value
                change_pts_aspect(points)
            })
            color_selector.on("change", function () {
                cKey = this.value
                change_pts_aspect(points)
            })
            log10x.on("change", function () {
                isXLog = this.checked
                change_axes(points)
            })
            log10y.on("change", function () {
                isYLog = this.checked
                change_axes(points)
            })
            gridcheck.on("change", () => {
                gridOn = !gridOn
                change_axes(points)
            })
            hcolcheck.on("change", () => {
                hcolOn = !hcolOn
                change_axes(points)
            })
            tooltip_radio.on("change", () => {
                setTooltip()
            })
            colblind.on("change", function() {
                isColBlind = this.checked
                change_pts_aspect(points)
            })


        }

        function createXYscale(points) {
            /**
             *  Set X-axis and Y-axis scales
             */

            let x, y, min
            if (isXLog) {
                min = d3.min(points, d => d[xKey])
                if (min <= 0) {
                    min = 1
                }
                x = d3.scaleLog()
                    .domain([min, d3.max(points, d => d[xKey])])
                    .range([marginLeft, WIDTH - marginRight]).nice()
            }
            else {
                x = d3.scaleLinear()
                    .domain([d3.min(points, d => d[xKey]), d3.max(points, d => d[xKey])])
                    .range([marginLeft, WIDTH - marginRight]).nice()

            }

            if (isYLog) {
                min = d3.min(points, d => d[yKey])
                if (min <= 0) {
                    min = 1
                }
                y = d3.scaleLog()
                    .domain([min, d3.max(points, d => d[yKey])])
                    .range([HEIGHT - marginBottom, marginTop]).nice()
            }
            else {
                y = d3.scaleLinear()
                    .domain([d3.min(points, d => d[yKey]), d3.max(points, d => d[yKey])])
                    .range([HEIGHT - marginBottom, marginTop]).nice()

            }

            return [x, y]
        }

        function openMenu(div, divall, title, opacitylvl, color) {
            d3.selectAll(".section").attr("hidden", true)
            d3.selectAll(".allsection").style("border-left", null)
            d3.selectAll(".sectiontitle").style("opacity", opacitylvl)
            title.style("opacity", 1)
            title.style("color", color)
            div.attr("hidden", null)
            divall.style("border-left", "solid")
            divall.style("border-left-width", "3px")
            divall.style("border-left-color", color)
        }

        function setMenu(id) {
            const title = d3.select(`#${id}-title`)
            const div = d3.select(`#${id}-div`)
            const divall = d3.select(`#${id}-all-div`)
            const opacitylvl = 0.8
            const color = {
                'x': '#235789',
                'y': '#0C8888CC',
                's': '#5D8731CC',
                'c': '#D05A2FCC',
                'g': '#c1292e',
                't': '#555555'
            }

            div.attr("hidden", true)
            title.style("margin-left", "15px")
            title.style("color", color[id])
            title.style("opacity", opacitylvl)
            div.style("margin-left", "15px")

            title.attr("tabindex", 0)
                .on("keydown", function () {
                    openMenu(div, divall, title, opacitylvl, color[id])
                })

            title.on("click", function () {
                if (div.attr("hidden") == "true") {
                    openMenu(div, divall, title, opacitylvl, color[id])
                }
                else {
                    div.attr("hidden", true)
                    divall.style("border-left", null)
                }
            })

            title.on("mouseover", () => title.style("opacity", 1))
            title.on("mouseleave", () => { if (div.attr("hidden") == "true") { title.style("opacity", opacitylvl) } })

        }


        function onFocus(event, ref, points) {
            /**
             *  Event mouseover :
             *      - Set tooltip according to user's choice
             *      - Show tooltip
             *      - Highlight focus
             */
            const tooltip = d3.select("#tooltip")
            const svg = d3.select("#svg")
            const colorlegendsvg = d3.select("#colorlegendsvg")
            const tooltipContent = d3.select("#tooltip-content")
            const tooltipData = Object.keys(ref)
                .filter(key => onTooltip[key] === true)
                .reduce((acc, key) => {
                    acc[key] = ref[key]
                    return acc
                }, {})

            const maxKeyWidth = Math.max(...Object.keys(tooltipData).map(getTextWidth))
            const maxValueWidth = Math.max(...Object.values(tooltipData).map(getTextWidth))

            // reboot tooltip 
            tooltipContent.html("")
            // console.log(maxKeyWidth + maxValueWidth + 20)
            if (maxKeyWidth + maxValueWidth + 20 > 400) {
                tooltipContent.style("max-width", `400px`)
            }
            else {
                tooltipContent.style("min-width", `${maxKeyWidth + maxValueWidth + 20}px`)
            }

            // create as row as keys in the data
            // two cols for each row -> key : value
            for (let key of Object.entries(tooltipData)) {
                // onTooltip filters which keys go into tooltip
                // set setTooltip() function for more details
                const row = tooltipContent.append("div").style("display", "flex")
                row.append("div")
                    .html(key[0])
                    .style("flex", `0 0 ${maxKeyWidth + 15}px`)
                    .style("font-size", "11px")
                    .style("overflow", "hidden")
                    .style("text-overflow", "ellipsis")
                    .style("white-space", "nowrap")
                row.append("div")
                    .html(key[1])
                    .style("flex", "1")
                    .style("font-weight", "bold")
                    .style("font-size", "11px")
                    .style("overflow", "hidden")
                    .style("text-overflow", "ellipsis")
                    .style("white-space", "nowrap")
            }

            const color = createColorScale(points)

            // if there is something => show tooltip
            tooltip.style("opacity", tooltipContent.node().children.length === 0 ? 0 : 1)
            // set the tooltip pos
            // need to convert svg coords (cx & cy) to screen cords.
            const svgpoint = svg.node().createSVGPoint()
            svgpoint.x = parseFloat(event.target.getAttribute("cx"))
            svgpoint.y = parseFloat(event.target.getAttribute("cy")) - parseFloat(event.target.getAttribute("r"))
            const screenpoint = svgpoint.matrixTransform(event.target.getScreenCTM())
            // left = cx - tooltip Width/2
            // top = cy - r - tooltip Height - offset 
            tooltip.style("top", `${screenpoint.y - tooltipContent.node().clientHeight - 23}px`)
                .style("left", `${screenpoint.x - tooltipContent.node().clientWidth / 2}px`)
                .style("box-shadow", `0px 4px 10px rgba(0, 0, 0, 0.1)`)
                .style("background-color", "white")
                .style("border-left", "solid")
                .style("border-color", color(ref[cKey]))
                .style("border-width", "0.5px")
                .style("border-left-width", "3px")

            // if out of screen (top only)
            if (parseInt(tooltip.style("top")) < 0) {
                svgpoint.y = parseFloat(event.target.getAttribute("cy")) + parseFloat(event.target.getAttribute("r"))
                const screenpoint = svgpoint.matrixTransform(event.target.getScreenCTM())
                tooltip.style("top", `${screenpoint.y + 10}px`)
            }

            // highlight focus
            if (hcolOn) {
                svg.selectAll("circle").style("opacity", d => d[cKey] == ref[cKey] ? 1 : 0.2)
                colorlegendsvg.select(legendId[ref[cKey]]).style("font-weight", "bold")
            }
            else {
                svg.selectAll(".dots").style("opacity", d => d == ref ? 1 : 0.2)
            }

        }

        function setTooltip() {
            /**
             *  Set onTooltip object according to user's choice.
             *  onTooltip = {key : bool}
             *      - If a key == true -> will be on Tooltip
             *      - If a key == false -> will not
             */

            d3.select(`label[for="4"]`).style("font-weight", undefined)
            const userChoice = d3.select('input[name="radioTooltip"]:checked').property("value")
            const customTooltip = d3.select("#customTooltip")

            // by default hide custom tooltip settings
            customTooltip.attr("hidden", true)

            // no tooltip = everything to false
            if (userChoice === "1") {
                for (let key of Object.keys(onTooltip)) {
                    onTooltip[key] = false
                }

            }
            // all keys = everything to true
            else if (userChoice === "2") {
                for (let key of Object.keys(onTooltip)) {
                    onTooltip[key] = true
                }
            }
            // only scales = xKey, yKey, sKey and cKey on true. Else on false.
            else if (userChoice === "3") {
                for (let key of Object.keys(onTooltip)) {
                    if (key == xKey || key == yKey || key == sKey || key == cKey) {
                        onTooltip[key] = true
                    }
                    else {
                        onTooltip[key] = false
                    }
                }
            }
            // custom = show custom settings
            else {
                for (let key of Object.keys(onTooltip)) {
                    onTooltip[key] = false
                    d3.select("#customTooltip").select(`input[id="${key}"]`).property("checked", false)
                }
                customTooltip.attr("hidden", null)
                d3.select(`label[for="${userChoice}"]`).style("font-weight", "bold")
            }
        }

        function eventCustomTooltip() {
            onTooltip[this.value] = !onTooltip[this.value]
        }

        function createSizeLegend(points, size) {
            if (d3.select("#size-select").node().selectedOptions[0].textContent != "None") {
                d3.select("#sizeTitle").html(sKey)
                const svg = d3.select("#sizelegendsvg")
                // legend

                const ticks = size.ticks(2)
                const maxValue = ticks[ticks.length - 1]
                const diameter = size(maxValue) * 2
                const dashWidth = diameter / 2 + 10

                const legendGroup = svg.append("g")
                    .attr("id", "otherlegend")
                    .attr("transform", `translate(5,10)`);


                ticks.map((d, i) => {
                    const xCenter = diameter / 2;
                    const yCircleTop = diameter - 2 * size(d);
                    const yCircleCenter = diameter - size(d);
                    legendGroup.append("circle")
                        .attr("cx", xCenter)
                        .attr("cy", yCircleCenter)
                        .attr("r", size(d))
                        .attr("fill", "none")
                        .attr("stroke", "#555");

                    legendGroup.append("line")
                        .attr("x1", xCenter)
                        .attr("x2", xCenter + dashWidth)
                        .attr("y1", yCircleTop)
                        .attr("y2", yCircleTop)
                        .attr("stroke", "#999")
                        .attr("stroke-dasharray", "2,2");

                    legendGroup.append("text")
                        .attr("x", xCenter + dashWidth + 4)
                        .attr("y", yCircleTop)
                        .text(d)
                        .style("font-size", "8px")
                        .style("fill", "#333");
                })
            }

        }
        function getTextWidth(text) {
            const svg = d3.select("#svg")

            const tempText = svg.append("text")
                .style("visibility", "hidden")
                .style("font-size", "12px")
                .text(text)

            const width = tempText.node().getBBox().width
            tempText.remove()
            return width
        }

        function createColorLegend(points, color) {
            if (cKey != "None") {

                d3.select("#colorTitle").html(cKey)
                const legend = d3.select("#colorlegendsvg")
                    .attr("width", WIDTH - marginLeft - marginRight)
                    .attr("style", `max-width: 100%; height: auto; font: 10px sans-serif;margin-left:${marginLeft};margin-top:5px;`)

                const padding = 20
                const itemHeight = 20
                const maxWidth = (WIDTH / 2)

                legend.append("g")
                    .attr("transform", `translate(0, 0)`)

                const uniqueCol = Array.from(new Set(points.map(d => d[cKey])))
                const itemWidth = [...[0], ...uniqueCol.map(getTextWidth)]

                let col = - padding
                let row = 0
                uniqueCol.forEach((cat, i) => {
                    col += itemWidth[i] + padding
                    if (col > maxWidth) {
                        col = 0
                        row += 1
                    }

                    const group = legend.append("g")
                        .attr("id", "otherlegend")
                        .attr("transform", `translate(${col}, ${row * itemHeight})`)

                    group.append("rect")
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("fill", color(cat))

                    group.append("text")
                        .attr("x", 14)
                        .attr("y", 9)
                        .attr("id", `legend-${i}`)
                        .text(cat)
                        .style("font-size", "11px")
                        .style("fill", "#333")

                    legendId[cat] = `#legend-${i}`
                })
            }
        }

        function createColorScale(points) {
            const domain = [...new Set(points.map(d => d[cKey]))] 
            let range = d3.schemeObservable10
            if (isColBlind) {
                const coldomain = Object.keys(Paultolcol)
                range = Array.from({ length: domain.length }, (_, i) => coldomain[i % coldomain.length])
            }
            const color = d3.scaleOrdinal()
                .domain(domain)
                .range(range)

            return color
        }

        // flask
        const path = "/data"
        const delimiter = "{{ delimiter }}"
        scatterPlot(path, delimiter)


    </script>
    <style>
        body {
            font-family: "Public Sans";
            color: #001D3D
        }

        h2 {
            font-family: "Fjalla One";
            color: #001D3D;
            text-align: center;
            font-style: bold;
            margin-top: 10;
            margin-bottom: 1;
        }

        h5 {
            text-align: left;
            margin-top: 20;
            margin-left: 5;
            font-size: 20px;
            color: #002E5B;
            font-weight: bold;
        }

        h6 {
            text-align: left;
            margin-bottom: 5;
            margin-left: 5;
            margin-top: 20;
            line-height: 1.2;
            font-size: 13px;
            color: #002E5B;
            /* font-weight: bold; */
        }

        .form-select.form-select-sm {
            max-width: 150;
            margin-right: auto;
            display: block;
            margin-bottom: 16;
        }

        #checklabel {
            font-size: small;
            color: #002E5B;
            margin-top: 4px;
            margin-left: 0px;
            font-weight: normal;
        }

        .form-check {
            margin-left: 2px
        }

        form {
            margin-top: 70px;
        }

        #p_customTooltip {
            font-size: x-small;
            margin-left: 8px;
            margin-top: 10px;
            font-style: italic;
            border-left: solid;
            border-left-width: 2px;
            border-left-color: #0d6efd;

        }

        #customTooltip {
            margin-left: 10px;
        }

        .tooltip {
            position: absolute;
            opacity: 0;
            color: white;
            padding: 5px;
            border-radius: 3px;
            pointer-events: none;
        }

        .sectiontitle {
            cursor: pointer;
        }
    </style>
</body>

</html>
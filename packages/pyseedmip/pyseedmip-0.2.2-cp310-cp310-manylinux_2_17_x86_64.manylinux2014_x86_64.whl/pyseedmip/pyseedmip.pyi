from __future__ import annotations
import typing

__all__ = ['BEST_SOL_FOUND', 'BINARY', 'Constr', 'DEFAULT_LB', 'DEFAULT_UB', 'ERROR_BOOL_BOUND_WRONG', 'ERROR_BOUND_WRONG', 'ERROR_INTERUPTED', 'ERROR_INVALID_SENSE', 'ERROR_LINEAR_EXPR_NO_SUCH_NAME', 'ERROR_LINEAR_QUANT_NOT_EQUL', 'ERROR_MODEL_DEL_NO_SUCH_NAME', 'ERROR_NAME_CONFLICT', 'ERROR_NO_SOLUTION_YET', 'ERROR_NO_SUCH_NAME', 'ERROR_NO_SUCH_TYPE', 'ERROR_NO_SUCH_VAR', 'ERROR_OBJ_UNSET', 'ERROR_QUANT_NOT_EQUAL', 'ERROR_READ_MPS_ERR', 'ERROR_REDUND_OPRT', 'ERROR_SET_VAL_OUT_BOUND', 'ERROR_SUCCESS', 'ERROR_VAR_ALREADY_FIXED', 'ERROR_VAR_NOT_IN_MODEL', 'Env', 'ErrorCode', 'EventHandler', 'Exception', 'INITIAL_STATE', 'INTEGER', 'INTERUPTED', 'License', 'LinExpr', 'Model', 'NEW_SOL_FOUND', 'REAL', 'SOLVING_END', 'SOL_FOUND', 'SOL_NOT_FOUND', 'START_SOLVING', 'SolStatus', 'SolverEvent', 'Status', 'TempConstr', 'VType', 'Var', 'errorMessages']

class Constr:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def chgCoeff(self, var: Var, newvalue: float) -> None:
        ...
    def chgCoeffs(self, vars: list[Var], vals: list[float]) -> None:
        ...
    def getCoeff(self, var: Var) -> float:
        ...
    def getCoeffList(self) -> list[float]:
        ...
    def getName(self) -> str:
        ...
    def getRhs(self) -> float:
        ...
    def getSense(self) -> str:
        ...
    def getVarList(self) -> list[Var]:
        ...
    def sameAs(self, constr: Constr) -> bool:
        ...
    def setName(self, name: str) -> None:
        ...
    def setRhs(self, rhs: float) -> None:
        ...
    def setSense(self, sense: str) -> None:
        ...
        
class Env:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self) -> None:
        ...
    def getCutoff(self) -> float:
        ...
    def setCutoff(self, cutoff: float) -> None:
        ...

class ErrorCode:
    """
    Members:
    
      ERROR_SUCCESS
    
      ERROR_BOUND_WRONG
    
      ERROR_NAME_CONFLICT
    
      ERROR_BOOL_BOUND_WRONG
    
      ERROR_NO_SUCH_NAME
    
      ERROR_NO_SUCH_TYPE
    
      ERROR_NO_SUCH_VAR
    
      ERROR_QUANT_NOT_EQUAL
    
      ERROR_INVALID_SENSE
    
      ERROR_REDUND_OPRT
    
      ERROR_OBJ_UNSET
    
      ERROR_LINEAR_EXPR_NO_SUCH_NAME
    
      ERROR_MODEL_DEL_NO_SUCH_NAME
    
      ERROR_SET_VAL_OUT_BOUND
    
      ERROR_LINEAR_QUANT_NOT_EQUL
    
      ERROR_READ_MPS_ERR
    
      ERROR_INTERUPTED
    
      ERROR_VAR_NOT_IN_MODEL
    
      ERROR_NO_SOLUTION_YET
    
      ERROR_VAR_ALREADY_FIXED
    """
    ERROR_BOOL_BOUND_WRONG: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_BOOL_BOUND_WRONG: 3>
    ERROR_BOUND_WRONG: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_BOUND_WRONG: 1>
    ERROR_INTERUPTED: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_INTERUPTED: 16>
    ERROR_INVALID_SENSE: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_INVALID_SENSE: 8>
    ERROR_LINEAR_EXPR_NO_SUCH_NAME: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_LINEAR_EXPR_NO_SUCH_NAME: 11>
    ERROR_LINEAR_QUANT_NOT_EQUL: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_LINEAR_QUANT_NOT_EQUL: 14>
    ERROR_MODEL_DEL_NO_SUCH_NAME: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_MODEL_DEL_NO_SUCH_NAME: 12>
    ERROR_NAME_CONFLICT: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_NAME_CONFLICT: 2>
    ERROR_NO_SOLUTION_YET: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_NO_SOLUTION_YET: 18>
    ERROR_NO_SUCH_NAME: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_NO_SUCH_NAME: 4>
    ERROR_NO_SUCH_TYPE: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_NO_SUCH_TYPE: 5>
    ERROR_NO_SUCH_VAR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_NO_SUCH_VAR: 6>
    ERROR_OBJ_UNSET: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_OBJ_UNSET: 10>
    ERROR_QUANT_NOT_EQUAL: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_QUANT_NOT_EQUAL: 7>
    ERROR_READ_MPS_ERR: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_READ_MPS_ERR: 15>
    ERROR_REDUND_OPRT: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_REDUND_OPRT: 9>
    ERROR_SET_VAL_OUT_BOUND: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_SET_VAL_OUT_BOUND: 13>
    ERROR_SUCCESS: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_SUCCESS: 0>
    ERROR_VAR_ALREADY_FIXED: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_VAR_ALREADY_FIXED: 19>
    ERROR_VAR_NOT_IN_MODEL: typing.ClassVar[ErrorCode]  # value = <ErrorCode.ERROR_VAR_NOT_IN_MODEL: 17>
    __members__: typing.ClassVar[dict[str, ErrorCode]]  # value = {'ERROR_SUCCESS': <ErrorCode.ERROR_SUCCESS: 0>, 'ERROR_BOUND_WRONG': <ErrorCode.ERROR_BOUND_WRONG: 1>, 'ERROR_NAME_CONFLICT': <ErrorCode.ERROR_NAME_CONFLICT: 2>, 'ERROR_BOOL_BOUND_WRONG': <ErrorCode.ERROR_BOOL_BOUND_WRONG: 3>, 'ERROR_NO_SUCH_NAME': <ErrorCode.ERROR_NO_SUCH_NAME: 4>, 'ERROR_NO_SUCH_TYPE': <ErrorCode.ERROR_NO_SUCH_TYPE: 5>, 'ERROR_NO_SUCH_VAR': <ErrorCode.ERROR_NO_SUCH_VAR: 6>, 'ERROR_QUANT_NOT_EQUAL': <ErrorCode.ERROR_QUANT_NOT_EQUAL: 7>, 'ERROR_INVALID_SENSE': <ErrorCode.ERROR_INVALID_SENSE: 8>, 'ERROR_REDUND_OPRT': <ErrorCode.ERROR_REDUND_OPRT: 9>, 'ERROR_OBJ_UNSET': <ErrorCode.ERROR_OBJ_UNSET: 10>, 'ERROR_LINEAR_EXPR_NO_SUCH_NAME': <ErrorCode.ERROR_LINEAR_EXPR_NO_SUCH_NAME: 11>, 'ERROR_MODEL_DEL_NO_SUCH_NAME': <ErrorCode.ERROR_MODEL_DEL_NO_SUCH_NAME: 12>, 'ERROR_SET_VAL_OUT_BOUND': <ErrorCode.ERROR_SET_VAL_OUT_BOUND: 13>, 'ERROR_LINEAR_QUANT_NOT_EQUL': <ErrorCode.ERROR_LINEAR_QUANT_NOT_EQUL: 14>, 'ERROR_READ_MPS_ERR': <ErrorCode.ERROR_READ_MPS_ERR: 15>, 'ERROR_INTERUPTED': <ErrorCode.ERROR_INTERUPTED: 16>, 'ERROR_VAR_NOT_IN_MODEL': <ErrorCode.ERROR_VAR_NOT_IN_MODEL: 17>, 'ERROR_NO_SOLUTION_YET': <ErrorCode.ERROR_NO_SOLUTION_YET: 18>, 'ERROR_VAR_ALREADY_FIXED': <ErrorCode.ERROR_VAR_ALREADY_FIXED: 19>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...

class EventHandler:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self) -> None:
        ...
    def handle(self, model: Model, event: SolverEvent) -> None:
        ...

class Exception(Exception):
    pass

class License:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self) -> None:
        ...
    def activate(self: str) -> bool:
        ...

class LinExpr:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __add__(self, constant: float) -> LinExpr:
        ...
    @typing.overload
    def __eq__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self: float, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self: float, expr: LinExpr) -> TempConstr:
        ...
    def __iadd__(self, expr: LinExpr) -> LinExpr:
        ...
    def __imul__(self, mult: float) -> LinExpr:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, constant: float = 0.0) -> None:
        ...
    @typing.overload
    def __init__(self, var: Var, coeff: float = 1.0) -> None:
        ...
    def __isub__(self, expr: LinExpr) -> LinExpr:
        ...
    def __itruediv__(self, divisor: float) -> LinExpr:
        ...
    @typing.overload
    def __le__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __le__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __le__(self: float, expr: LinExpr) -> TempConstr:
        ...
    def __mul__(self, mult: float) -> LinExpr:
        ...
    def __neg__(self) -> LinExpr:
        ...
    def __pos__(self) -> LinExpr:
        ...
    def __radd__(self, constant: float) -> LinExpr:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, mult: float) -> LinExpr:
        ...
    def __rsub__(self, constant: float) -> LinExpr:
        ...
    @typing.overload
    def __sub__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __sub__(self, constant: float) -> LinExpr:
        ...
    def __truediv__(self, divisor: float) -> LinExpr:
        ...
    def add(self, expr: LinExpr, mult: float = 1.0) -> None:
        ...
    def addConstant(self, constant: float) -> None:
        ...
    def addTerms(self, coeffs: list[float], vars: list[Var]) -> None:
        ...
    def clear(self) -> None:
        ...
    @typing.overload
    def getCoeff(self, var: Var) -> float:
        ...
    def getConstant(self) -> float:
        ...
    def getValue(self) -> float:
        ...
    def removeByVar(self, var: Var) -> None:
        ...
    def size(self) -> int:
        ...
        
class Model:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __init__(self, env: Env) -> None:
        ...
    @typing.overload
    def __init__(self, env: Env, name: str) -> None:
        ...
    @typing.overload
    def addConstr(self, lhs: LinExpr, sense: str, rhs: LinExpr, name: str = '') -> Constr:
        ...
    @typing.overload
    def addConstr(self, lhs: LinExpr, sense: str, rhs: float, name: str = '') -> Constr:
        ...
    @typing.overload
    def addConstr(self, tmp: TempConstr, name: str = '') -> Constr:
        ...
    @typing.overload
    def addConstrs(self, lhs: list[LinExpr], senses: list[str], rhs: list[float], names: list[str]) -> list[Constr]:
        ...
    @typing.overload
    def addConstrs(self, tmps: list[TempConstr], names: list[str]) -> list[Constr]:
        ...
    @typing.overload
    def addVar(self, name: str) -> Var:
        ...
    @typing.overload
    def addVar(self, type: VType, name: str) -> Var:
        ...
    @typing.overload
    def addVar(self, lb: float, ub: float, type: VType, name: str) -> Var:
        ...
    @typing.overload
    def addVars(self, cnt: int) -> list[Var]:
        ...
    @typing.overload
    def addVars(self, lbs: list[float], ubs: list[float], types: list[VType], names: list[str]) -> list[Var]:
        ...
    def attachEventHandler(self, event: SolverEvent, handler: EventHandler) -> None:
        ...
    def close(self) -> None:
        ...
    def detachEventHandler(self, event: SolverEvent, handler: EventHandler) -> None:
        ...
    def getConstrByName(self, name: str) -> Constr:
        ...
    def getConstrs(self) -> list[Constr]:
        ...
    def getJSONSolution(self) -> str:
        ...
    def getMpsStr(self) -> str:
        ...
    def getName(self) -> str:
        ...
    def getObj(self) -> Constr:
        ...
    def getObjVal(self) -> float:
        ...
    def getSolStatus(self) -> SolStatus:
        ...
    def getSolText(self) -> str:
        ...
    def getStatus(self) -> Status:
        ...
    def getVarByName(self, name: str) -> Var:
        ...
    def getVars(self) -> list[Var]:
        ...
    def notifyEventHandlers(self, event: SolverEvent) -> None:
        ...
    def optimize(self) -> None:
        ...
    def optimize_async(self) -> None:
        ...
    def printSol(self) -> None:
        ...
    def printStats(self) -> None:
        ...
    def readMPS(self, filename: str) -> None:
        ...
    @typing.overload
    def remove(self, constr: Constr) -> None:
        ...
    @typing.overload
    def remove(self, var: Var) -> None:
        ...
    def reset(self, clearall: int = 0) -> None:
        ...
    def setInitalVal(self, var: Var, val: float) -> None:
        ...
    def setName(self, name: str) -> None:
        ...
    def setObj(self, expr: LinExpr, sense: str) -> Constr:
        ...
    def setSolStatus(self, solStatus: SolStatus) -> None:
        ...
    def setStatus(self, status: Status) -> None:
        ...
    def terminate(self) -> None:
        ...
    def wait(self) -> None:
        ...
    def writeMPS(self, filename: str) -> None:
        ...
class SolStatus:
    """
    Members:
    
      SOL_NOT_FOUND
    
      SOL_FOUND
    """
    SOL_FOUND: typing.ClassVar[SolStatus]  # value = <SolStatus.SOL_FOUND: 1>
    SOL_NOT_FOUND: typing.ClassVar[SolStatus]  # value = <SolStatus.SOL_NOT_FOUND: 0>
    __members__: typing.ClassVar[dict[str, SolStatus]]  # value = {'SOL_NOT_FOUND': <SolStatus.SOL_NOT_FOUND: 0>, 'SOL_FOUND': <SolStatus.SOL_FOUND: 1>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...

class SolverEvent:
    """
    Members:
    
      START_SOLVING
    
      NEW_SOL_FOUND
    
      BEST_SOL_FOUND
    
      INTERUPTED
    
      SOLVING_END
    """
    BEST_SOL_FOUND: typing.ClassVar[SolverEvent]  # value = <SolverEvent.BEST_SOL_FOUND: 2>
    INTERUPTED: typing.ClassVar[SolverEvent]  # value = <SolverEvent.INTERUPTED: 3>
    NEW_SOL_FOUND: typing.ClassVar[SolverEvent]  # value = <SolverEvent.NEW_SOL_FOUND: 1>
    SOLVING_END: typing.ClassVar[SolverEvent]  # value = <SolverEvent.SOLVING_END: 4>
    START_SOLVING: typing.ClassVar[SolverEvent]  # value = <SolverEvent.START_SOLVING: 0>
    __members__: typing.ClassVar[dict[str, SolverEvent]]  # value = {'START_SOLVING': <SolverEvent.START_SOLVING: 0>, 'NEW_SOL_FOUND': <SolverEvent.NEW_SOL_FOUND: 1>, 'BEST_SOL_FOUND': <SolverEvent.BEST_SOL_FOUND: 2>, 'INTERUPTED': <SolverEvent.INTERUPTED: 3>, 'SOLVING_END': <SolverEvent.SOLVING_END: 4>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...

class Status:
    """
    Members:
    
      INITIAL_STATE
    
      START_SOLVING
    
      NEW_SOL_FOUND
    
      BEST_SOL_FOUND
    
      INTERUPTED
    
      SOLVING_END
    """
    BEST_SOL_FOUND: typing.ClassVar[Status]  # value = <Status.BEST_SOL_FOUND: 3>
    INITIAL_STATE: typing.ClassVar[Status]  # value = <Status.INITIAL_STATE: 0>
    INTERUPTED: typing.ClassVar[Status]  # value = <Status.INTERUPTED: 4>
    NEW_SOL_FOUND: typing.ClassVar[Status]  # value = <Status.NEW_SOL_FOUND: 2>
    SOLVING_END: typing.ClassVar[Status]  # value = <Status.SOLVING_END: 5>
    START_SOLVING: typing.ClassVar[Status]  # value = <Status.START_SOLVING: 1>
    __members__: typing.ClassVar[dict[str, Status]]  # value = {'INITIAL_STATE': <Status.INITIAL_STATE: 0>, 'START_SOLVING': <Status.START_SOLVING: 1>, 'NEW_SOL_FOUND': <Status.NEW_SOL_FOUND: 2>, 'BEST_SOL_FOUND': <Status.BEST_SOL_FOUND: 3>, 'INTERUPTED': <Status.INTERUPTED: 4>, 'SOLVING_END': <Status.SOLVING_END: 5>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...

class TempConstr:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, tmp: TempConstr) -> None:
        ...
    def assign(self, tmp: TempConstr) -> TempConstr:
        ...

class VType:
    """
    Members:
    
      BINARY
    
      INTEGER
    
      REAL
    """
    BINARY: typing.ClassVar[VType]  # value = <VType.BINARY: 0>
    INTEGER: typing.ClassVar[VType]  # value = <VType.INTEGER: 1>
    REAL: typing.ClassVar[VType]  # value = <VType.REAL: 2>
    __members__: typing.ClassVar[dict[str, VType]]  # value = {'BINARY': <VType.BINARY: 0>, 'INTEGER': <VType.INTEGER: 1>, 'REAL': <VType.REAL: 2>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...

class Var:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, var: Var) -> LinExpr:
        ...
    @typing.overload
    def __add__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __add__(self, constant: float) -> LinExpr:
        ...
    @typing.overload
    def __eq__(self, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self: LinExpr, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __eq__(self: float, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self: LinExpr, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __ge__(self: float, var: Var) -> TempConstr:
        ...
    def __iadd__(self, expr: LinExpr) -> LinExpr:
        ...
    def __imul__(self, mult: float) -> LinExpr:
        ...
    def __isub__(self, expr: LinExpr) -> LinExpr:
        ...
    def __itruediv__(self, divisor: float) -> LinExpr:
        ...
    @typing.overload
    def __le__(self, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __le__(self, expr: LinExpr) -> TempConstr:
        ...
    @typing.overload
    def __le__(self, constant: float) -> TempConstr:
        ...
    @typing.overload
    def __le__(self: LinExpr, var: Var) -> TempConstr:
        ...
    @typing.overload
    def __le__(self: float, var: Var) -> TempConstr:
        ...
    def __lt__(self, var: Var) -> bool:
        ...
    def __mul__(self, mult: float) -> LinExpr:
        ...
    def __neg__(self) -> LinExpr:
        ...
    def __pos__(self) -> LinExpr:
        ...
    @typing.overload
    def __radd__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __radd__(self, constant: float) -> LinExpr:
        ...
    def __rmul__(self, mult: float) -> LinExpr:
        ...
    @typing.overload
    def __rsub__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __rsub__(self, constant: float) -> LinExpr:
        ...
    @typing.overload
    def __sub__(self, var: Var) -> LinExpr:
        ...
    @typing.overload
    def __sub__(self, expr: LinExpr) -> LinExpr:
        ...
    @typing.overload
    def __sub__(self, constant: float) -> LinExpr:
        ...
    def __truediv__(self, divisor: float) -> LinExpr:
        ...
    def fix(self, value: float) -> None:
        ...
    def isFixed(self) -> bool:
        ...
    def getLB(self) -> float:
        ...
    def getName(self) -> str:
        ...
    def getType(self) -> VType:
        ...
    def getUB(self) -> float:
        ...
    def getUserValue(self) -> float:
        ...
    def getVal(self) -> float:
        ...
    def sameAs(self, var: Var) -> bool:
        ...
    def setLB(self, value: float) -> None:
        ...
    def setName(self, name: str) -> None:
        ...
    def setType(self, type: VType) -> None:
        ...
    def setUB(self, value: float) -> None:
        ...
    def setUserValue(self, value: float) -> None:
        ...
    def setVal(self, value: float) -> None:
        ...
    def unfix(self) -> None:
        ...
BEST_SOL_FOUND: Status  # value = <Status.BEST_SOL_FOUND: 3>
BINARY: VType  # value = <VType.BINARY: 0>
DEFAULT_LB: float = 0.0
DEFAULT_UB: float = 1e+20
ERROR_BOOL_BOUND_WRONG: ErrorCode  # value = <ErrorCode.ERROR_BOOL_BOUND_WRONG: 3>
ERROR_BOUND_WRONG: ErrorCode  # value = <ErrorCode.ERROR_BOUND_WRONG: 1>
ERROR_INTERUPTED: ErrorCode  # value = <ErrorCode.ERROR_INTERUPTED: 16>
ERROR_INVALID_SENSE: ErrorCode  # value = <ErrorCode.ERROR_INVALID_SENSE: 8>
ERROR_LINEAR_EXPR_NO_SUCH_NAME: ErrorCode  # value = <ErrorCode.ERROR_LINEAR_EXPR_NO_SUCH_NAME: 11>
ERROR_LINEAR_QUANT_NOT_EQUL: ErrorCode  # value = <ErrorCode.ERROR_LINEAR_QUANT_NOT_EQUL: 14>
ERROR_MODEL_DEL_NO_SUCH_NAME: ErrorCode  # value = <ErrorCode.ERROR_MODEL_DEL_NO_SUCH_NAME: 12>
ERROR_NAME_CONFLICT: ErrorCode  # value = <ErrorCode.ERROR_NAME_CONFLICT: 2>
ERROR_NO_SOLUTION_YET: ErrorCode  # value = <ErrorCode.ERROR_NO_SOLUTION_YET: 18>
ERROR_NO_SUCH_NAME: ErrorCode  # value = <ErrorCode.ERROR_NO_SUCH_NAME: 4>
ERROR_NO_SUCH_TYPE: ErrorCode  # value = <ErrorCode.ERROR_NO_SUCH_TYPE: 5>
ERROR_NO_SUCH_VAR: ErrorCode  # value = <ErrorCode.ERROR_NO_SUCH_VAR: 6>
ERROR_OBJ_UNSET: ErrorCode  # value = <ErrorCode.ERROR_OBJ_UNSET: 10>
ERROR_QUANT_NOT_EQUAL: ErrorCode  # value = <ErrorCode.ERROR_QUANT_NOT_EQUAL: 7>
ERROR_READ_MPS_ERR: ErrorCode  # value = <ErrorCode.ERROR_READ_MPS_ERR: 15>
ERROR_REDUND_OPRT: ErrorCode  # value = <ErrorCode.ERROR_REDUND_OPRT: 9>
ERROR_SET_VAL_OUT_BOUND: ErrorCode  # value = <ErrorCode.ERROR_SET_VAL_OUT_BOUND: 13>
ERROR_SUCCESS: ErrorCode  # value = <ErrorCode.ERROR_SUCCESS: 0>
ERROR_VAR_ALREADY_FIXED: ErrorCode  # value = <ErrorCode.ERROR_VAR_ALREADY_FIXED: 19>
ERROR_VAR_NOT_IN_MODEL: ErrorCode  # value = <ErrorCode.ERROR_VAR_NOT_IN_MODEL: 17>
INITIAL_STATE: Status  # value = <Status.INITIAL_STATE: 0>
INTEGER: VType  # value = <VType.INTEGER: 1>
INTERUPTED: Status  # value = <Status.INTERUPTED: 4>
NEW_SOL_FOUND: Status  # value = <Status.NEW_SOL_FOUND: 2>
REAL: VType  # value = <VType.REAL: 2>
SOLVING_END: Status  # value = <Status.SOLVING_END: 5>
SOL_FOUND: SolStatus  # value = <SolStatus.SOL_FOUND: 1>
SOL_NOT_FOUND: SolStatus  # value = <SolStatus.SOL_NOT_FOUND: 0>
START_SOLVING: Status  # value = <Status.START_SOLVING: 1>
errorMessages: dict  # value = {<ErrorCode.ERROR_SUCCESS: 0>: 'No error', <ErrorCode.ERROR_BOUND_WRONG: 1>: 'The upper bound cannot be less than the lower bound', <ErrorCode.ERROR_NAME_CONFLICT: 2>: 'The var/constr name must be unique', <ErrorCode.ERROR_BOOL_BOUND_WRONG: 3>: 'Invalid bound for a bool var', <ErrorCode.ERROR_NO_SUCH_NAME: 4>: "The var/constr name doesn't exist", <ErrorCode.ERROR_NO_SUCH_TYPE: 5>: "The var type doesn't exist", <ErrorCode.ERROR_NO_SUCH_VAR: 6>: "The given var doesn't exist", <ErrorCode.ERROR_QUANT_NOT_EQUAL: 7>: 'Cnt must be equal to the array length', <ErrorCode.ERROR_INVALID_SENSE: 8>: '< and > are not allowed', <ErrorCode.ERROR_REDUND_OPRT: 9>: 'There are redundant operators in the linear expression', <ErrorCode.ERROR_OBJ_UNSET: 10>: 'The objective function must be set before optimizing', <ErrorCode.ERROR_LINEAR_EXPR_NO_SUCH_NAME: 11>: 'Cannot access this var in the linear expression', <ErrorCode.ERROR_MODEL_DEL_NO_SUCH_NAME: 12>: 'Cannot delete a var/constr not existing', <ErrorCode.ERROR_SET_VAL_OUT_BOUND: 13>: 'The set value must be in the bound', <ErrorCode.ERROR_LINEAR_QUANT_NOT_EQUL: 14>: 'Cnt must be equal to the number of terms', <ErrorCode.ERROR_INTERUPTED: 16>: 'The computation is interupted', <ErrorCode.ERROR_VAR_NOT_IN_MODEL: 17>: 'At least one var in the cons is not in the model', <ErrorCode.ERROR_NO_SOLUTION_YET: 18>: 'no solution available yet', <ErrorCode.ERROR_VAR_ALREADY_FIXED: 19>: 'The var is already fixed.'}

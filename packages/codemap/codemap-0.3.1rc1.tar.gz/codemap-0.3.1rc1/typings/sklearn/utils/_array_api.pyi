"""
This type stub file was generated by pyright.
"""

"""Tools to support array_api."""
_NUMPY_NAMESPACE_NAMES = ...
def yield_namespaces(include_numpy_namespaces=...): # -> Generator[str, Any, None]:
    """Yield supported namespace.

    This is meant to be used for testing purposes only.

    Parameters
    ----------
    include_numpy_namespaces : bool, default=True
        If True, also yield numpy namespaces.

    Returns
    -------
    array_namespace : str
        The name of the Array API namespace.
    """
    ...

def yield_namespace_device_dtype_combinations(include_numpy_namespaces=...): # -> Generator[tuple[Literal['torch'], Literal['cpu', 'cuda'], Literal['float64', 'float32']] | tuple[Literal['torch'], Literal['mps'], Literal['float32']] | tuple[str, None, None], Any, None]:
    """Yield supported namespace, device, dtype tuples for testing.

    Use this to test that an estimator works with all combinations.

    Parameters
    ----------
    include_numpy_namespaces : bool, default=True
        If True, also yield numpy namespaces.

    Returns
    -------
    array_namespace : str
        The name of the Array API namespace.

    device : str
        The name of the device on which to allocate the arrays. Can be None to
        indicate that the default value should be used.

    dtype_name : str
        The name of the data type to use for arrays. Can be None to indicate
        that the default value should be used.
    """
    ...

def device(*array_list, remove_none=..., remove_types=...): # -> None:
    """Hardware device where the array data resides on.

    If the hardware device is not the same for all arrays, an error is raised.

    Parameters
    ----------
    *array_list : arrays
        List of array instances from NumPy or an array API compatible library.

    remove_none : bool, default=True
        Whether to ignore None objects passed in array_list.

    remove_types : tuple or list, default=(str,)
        Types to ignore in array_list.

    Returns
    -------
    out : device
        `device` object (see the "Device Support" section of the array API spec).
    """
    ...

def size(x): # -> int:
    """Return the total number of elements of x.

    Parameters
    ----------
    x : array
        Array instance from NumPy or an array API compatible library.

    Returns
    -------
    out : int
        Total number of elements.
    """
    ...

def isdtype(dtype, kind, *, xp): # -> bool:
    """Returns a boolean indicating whether a provided dtype is of type "kind".

    Included in the v2022.12 of the Array API spec.
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
    """
    ...

def supported_float_dtypes(xp): # -> tuple[Any, Any, Any] | tuple[Any, Any]:
    """Supported floating point types for the namespace.

    Note: float16 is not officially part of the Array API spec at the
    time of writing but scikit-learn estimators and functions can choose
    to accept it when xp.float16 is defined.

    https://data-apis.org/array-api/latest/API_specification/data_types.html
    """
    ...

def ensure_common_namespace_device(reference, *arrays): # -> list[NDArray[Any] | Any] | tuple[Any, ...]:
    """Ensure that all arrays use the same namespace and device as reference.

    If necessary the arrays are moved to the same namespace and device as
    the reference array.

    Parameters
    ----------
    reference : array
        Reference array.

    *arrays : array
        Arrays to check.

    Returns
    -------
    arrays : list
        Arrays with the same namespace and device as reference.
    """
    ...

class _NumPyAPIWrapper:
    """Array API compat wrapper for any numpy version

    NumPy < 2 does not implement the namespace. NumPy 2 and later should
    progressively implement more an more of the latest Array API spec but this
    is still work in progress at this time.

    This wrapper makes it possible to write code that uses the standard Array
    API while working with any version of NumPy supported by scikit-learn.

    See the `get_namespace()` public function for more details.
    """
    _CREATION_FUNCS = ...
    _DTYPES = ...
    def __getattr__(self, name): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any] | dtype[Any] | Any:
        ...
    
    @property
    def bool(self): # -> bool_:
        ...
    
    def astype(self, x, dtype, *, copy=..., casting=...):
        ...
    
    def asarray(self, x, *, dtype=..., device=..., copy=...): # -> NDArray[Any]:
        ...
    
    def unique_inverse(self, x):
        ...
    
    def unique_counts(self, x):
        ...
    
    def unique_values(self, x):
        ...
    
    def unique_all(self, x): # -> tuple[NDArray[Any], NDArray[intp], NDArray[intp], NDArray[intp]]:
        ...
    
    def concat(self, arrays, *, axis=...): # -> NDArray[Any]:
        ...
    
    def reshape(self, x, shape, *, copy=...):
        """Gives a new shape to an array without changing its data.

        The Array API specification requires shape to be a tuple.
        https://data-apis.org/array-api/latest/API_specification/generated/array_api.reshape.html
        """
        ...
    
    def isdtype(self, dtype, kind): # -> bool:
        ...
    
    def pow(self, x1, x2): # -> Any:
        ...
    


_NUMPY_API_WRAPPER_INSTANCE = ...
def get_namespace(*arrays, remove_none=..., remove_types=..., xp=...): # -> tuple[Any, Literal[False]] | tuple[_NumPyAPIWrapper, Literal[False]] | tuple[Any, Literal[True]]:
    """Get namespace of arrays.

    Introspect `arrays` arguments and return their common Array API compatible
    namespace object, if any.

    Note that sparse arrays are filtered by default.

    See: https://numpy.org/neps/nep-0047-array-api-standard.html

    If `arrays` are regular numpy arrays, an instance of the `_NumPyAPIWrapper`
    compatibility wrapper is returned instead.

    Namespace support is not enabled by default. To enabled it call:

      sklearn.set_config(array_api_dispatch=True)

    or:

      with sklearn.config_context(array_api_dispatch=True):
          # your code here

    Otherwise an instance of the `_NumPyAPIWrapper` compatibility wrapper is
    always returned irrespective of the fact that arrays implement the
    `__array_namespace__` protocol or not.

    Note that if no arrays pass the set filters, ``_NUMPY_API_WRAPPER_INSTANCE, False``
    is returned.

    Parameters
    ----------
    *arrays : array objects
        Array objects.

    remove_none : bool, default=True
        Whether to ignore None objects passed in arrays.

    remove_types : tuple or list, default=(str,)
        Types to ignore in the arrays.

    xp : module, default=None
        Precomputed array namespace module. When passed, typically from a caller
        that has already performed inspection of its own inputs, skips array
        namespace inspection.

    Returns
    -------
    namespace : module
        Namespace shared by array objects. If any of the `arrays` are not arrays,
        the namespace defaults to NumPy.

    is_array_api_compliant : bool
        True if the arrays are containers that implement the Array API spec.
        Always False when array_api_dispatch=False.
    """
    ...

def get_namespace_and_device(*array_list, remove_none=..., remove_types=...): # -> tuple[_NumPyAPIWrapper | Any, Literal[True], Any | None] | tuple[_NumPyAPIWrapper | Any, Literal[False], Any | None]:
    """Combination into one single function of `get_namespace` and `device`.

    Parameters
    ----------
    *array_list : array objects
        Array objects.
    remove_none : bool, default=True
        Whether to ignore None objects passed in arrays.
    remove_types : tuple or list, default=(str,)
        Types to ignore in the arrays.

    Returns
    -------
    namespace : module
        Namespace shared by array objects. If any of the `arrays` are not arrays,
        the namespace defaults to NumPy.
    is_array_api_compliant : bool
        True if the arrays are containers that implement the Array API spec.
        Always False when array_api_dispatch=False.
    device : device
        `device` object (see the "Device Support" section of the array API spec).
    """
    ...

def indexing_dtype(xp):
    """Return a platform-specific integer dtype suitable for indexing.

    On 32-bit platforms, this will typically return int32 and int64 otherwise.

    Note: using dtype is recommended for indexing transient array
    datastructures. For long-lived arrays, such as the fitted attributes of
    estimators, it is instead recommended to use platform-independent int32 if
    we do not expect to index more 2B elements. Using fixed dtypes simplifies
    the handling of serialized models, e.g. to deploy a model fit on a 64-bit
    platform to a target 32-bit platform such as WASM/pyodide.
    """
    ...


<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.3">
<title>src.simple_sign.backend API documentation</title>
<meta name="description" content="Cardano handlers …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.simple_sign.backend</code></h1>
</header>
<section id="section-intro">
<p>Cardano handlers.</p>
<p>This is very much a work in progress aimed at a very small dApp where
the anticipated amount of data to be returned for a query is very
small. The concept of a backend is not really fleshed out either and
so remains unexported until an interface is implemented or some other
useful/interesting concept.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.simple_sign.backend.BackendContext"><code class="flex name class">
<span>class <span class="ident">BackendContext</span></span>
</code></dt>
<dd>
<div class="desc"><p>Backend interfaces.</p>
<p>NB. this will probably prove to be a naive implementation of this
sort of thing, but lets see. Learning from PyCardano.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackendContext:
    &#34;&#34;&#34;Backend interfaces.

    NB. this will probably prove to be a naive implementation of this
    sort of thing, but lets see. Learning from PyCardano.
    &#34;&#34;&#34;

    def _retrieve_unspent_utxos(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from the backend.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_staked_holders(self, token_policy: str) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_nft_holders(
        self, policy: str, deny_list: list, addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_metadata(
        self, value: int, policy: str, tag: str, callback: Optional[Callable | None]
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve metadata from the backend.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.simple_sign.backend.KupoContext" href="#src.simple_sign.backend.KupoContext">KupoContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.simple_sign.backend.BackendContext.retrieve_metadata"><code class="name flex">
<span>def <span class="ident">retrieve_metadata</span></span>(<span>self, value: int, policy: str, tag: str, callback: Callable | None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve metadata from the backend.</p></div>
</dd>
<dt id="src.simple_sign.backend.BackendContext.retrieve_nft_holders"><code class="name flex">
<span>def <span class="ident">retrieve_nft_holders</span></span>(<span>self, policy: str, deny_list: list, addr: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of NFT holders, e.g. a license to operate
a decentralized node.</p></div>
</dd>
<dt id="src.simple_sign.backend.BackendContext.retrieve_staked_holders"><code class="name flex">
<span>def <span class="ident">retrieve_staked_holders</span></span>(<span>self, token_policy: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of staked holders against a given CNT.</p></div>
</dd>
</dl>
</dd>
<dt id="src.simple_sign.backend.KupoContext"><code class="flex name class">
<span>class <span class="ident">KupoContext</span></span>
<span>(</span><span>base_url: str, port: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Kupo backend.</p>
<p>Initialize this thing&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KupoContext(BackendContext):
    &#34;&#34;&#34;Kupo backend.&#34;&#34;&#34;

    def __init__(
        self,
        base_url: str,
        port: int,
    ):
        &#34;&#34;&#34;Initialize this thing...&#34;&#34;&#34;
        self._base_url = base_url
        self._port = port

    @cachetools.func.ttl_cache(ttl=60)
    def _retrieve_unspent_utxos(self, addr: str = None) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from Kupo.

        NB. Kupo must be configured to capture sparingly, i.e. the
        policies and addresses it is watching and slot from which it is
        watching must be as specific as possible for this function to
        perform well.
        &#34;&#34;&#34;
        kupo_err: Final[str] = &#34;hint&#34;
        request_string = f&#34;{self._base_url}:{self._port}/matches?unspent&#34;
        if addr:
            request_string = f&#34;{self._base_url}:{self._port}/matches/{addr}?unspent&#34;
        logger.info(&#34;requesting unspent: &#39;%s&#39;&#34;, request_string)
        resp = requests.get(request_string, timeout=30)
        ret = resp.json()
        if kupo_err in ret:
            logger.error(&#34;unable to retrieve data due to Kupo request error: %s&#34;, ret)
            return []
        return ret

    def _retrieve_metadata(self, tag: str, tx_list: list[ValidTx]):
        &#34;&#34;&#34;Return metadata based on slot and transaction ID. This is
        very much a Kupo-centric approach. Metadata is not indexed
        locally and instead needs to be retrieved directly from
        a node.

        IMPORTANT: The metadata is modified here to provide information
        about the source address. This is so that the data remains
        accurately coupled with what is retrieved. We can&#39;t do this
        with Kupo easily otherwise.
        &#34;&#34;&#34;
        md_list = []
        for tx in tx_list:
            resp = requests.get(
                f&#34;{self._base_url}:{self._port}/metadata/{tx.slot}?transaction_id={tx.tx_id}&#34;,
                timeout=30,
            )
            if not resp.json():
                return md_list
            md_dict = resp.json()
            try:
                _ = md_dict[0][&#34;schema&#34;][tag]
            except (IndexError, KeyError):
                return md_list
            md_dict[0][&#34;address&#34;] = tx.address
            md_dict[0][&#34;staking&#34;] = tx.staking
            md_dict[0][&#34;transaction&#34;] = tx.tx_id
            md_list.append(md_dict[0])
        return md_list

    def retrieve_staked_holders(self, token_policy: str, addr: str = None) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        addresses_with_fact = {}
        for item in unspent:
            unspent_addr = item[&#34;address&#34;]
            if not _check_bech32_prefix(unspent_addr):
                continue
            unspent_staking = _get_staking_from_addr(unspent_addr)
            if addr and addr not in (unspent_addr, unspent_staking):
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            staking = unspent_staking
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, value in assets.items():
                if token_policy in key:
                    addresses_with_fact = _sum_dict(staking, value, addresses_with_fact)
        return addresses_with_fact

    def retrieve_nft_holders(
        self, policy: str, deny_list: list = None, addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.

        Filtering can be performed elsewhere, but a deny_list is used
        to remove some results that are unhelpful, e.g. the minting
        address if desired.
        &#34;&#34;&#34;
        if addr:
            unspent = self._retrieve_unspent_utxos(addr)
        else:
            unspent = self._retrieve_unspent_utxos()
        holders = {}
        for item in unspent:
            unspent_addr = item[&#34;address&#34;]
            if not _check_bech32_prefix(unspent_addr):
                continue
            unspent_staking = _get_staking_from_addr(unspent_addr)
            if addr and addr not in (unspent_addr, unspent_staking):
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            if deny_list and unspent_addr in deny_list:
                continue
            staking = unspent_staking
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, _ in assets.items():
                if not key.startswith(policy):
                    continue
                holders[key] = staking
        return holders

    @staticmethod
    def _get_valid_txs(unspent: list[dict], value: int, policy: str) -&gt; list[ValidTx]:
        &#34;&#34;&#34;Retrieve a list of valid transactions according to our
        policy rules.
        &#34;&#34;&#34;
        logger.info(&#34;getting valid txs for policy: &#39;%s&#39;&#34;, policy)
        valid_txs = []
        if not unspent:
            return valid_txs
        for item in unspent:
            coins = item[&#34;value&#34;][&#34;coins&#34;]
            if coins != value:
                continue
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for asset in assets:
                if policy not in asset:
                    continue
                slot = item[&#34;created_at&#34;][&#34;slot_no&#34;]
                tx_id = item[&#34;transaction_id&#34;]
                address = item[&#34;address&#34;]
                valid_tx = ValidTx(
                    slot=slot,
                    tx_id=tx_id,
                    address=address,
                    staking=_get_staking_from_addr(address),
                )
                valid_txs.append(valid_tx)
        return valid_txs

    @pydantic.validate_call()
    def retrieve_metadata(
        self,
        value: int,
        policy: str,
        tag: str,
        callback: Optional[Callable | None],
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of aliased signing addresses. An aliased
        signing address is an address that has been setup using a
        protocol that allows NFT holders to participate in a network
        without having the key to their primary wallets hot/live on the
        decentralized node that they are operating.

        Kupo queries involved:

        ```sh
            curl -s &#34;http://0.0.0.0:1442/matches?unspent&#34;
            curl -s &#34;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&#34;
        ```

        Strategy 1: Retrieve all aliased keys for a policy ID.
                    Capture all values that match.
                    Capture all slots and tx ids for those values.
                    Retrieve metadata for all those txs.
                    Augment metadata with address and staking address.
                    Optionally, use the callback to process the data
                    according to a set of rules.
                    Return the metadata or a list of processed values to
                    the caller.

        NB. the callback must return a list to satisfy the output of the
        primary function.

        NB. this function is not as generic as it could be.

        &#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        valid_txs = self._get_valid_txs(unspent, value, policy)
        if not valid_txs:
            return valid_txs
        md = self._retrieve_metadata(tag, valid_txs)
        if not callback:
            return md
        return callback(md)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.simple_sign.backend.KupoContext.retrieve_metadata"><code class="name flex">
<span>def <span class="ident">retrieve_metadata</span></span>(<span>self, value: int, policy: str, tag: str, callback: Callable | None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of aliased signing addresses. An aliased
signing address is an address that has been setup using a
protocol that allows NFT holders to participate in a network
without having the key to their primary wallets hot/live on the
decentralized node that they are operating.</p>
<p>Kupo queries involved:</p>
<pre><code class="language-sh">    curl -s &quot;http://0.0.0.0:1442/matches?unspent&quot;
    curl -s &quot;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&quot;
</code></pre>
<p>Strategy 1: Retrieve all aliased keys for a policy ID.
Capture all values that match.
Capture all slots and tx ids for those values.
Retrieve metadata for all those txs.
Augment metadata with address and staking address.
Optionally, use the callback to process the data
according to a set of rules.
Return the metadata or a list of processed values to
the caller.</p>
<p>NB. the callback must return a list to satisfy the output of the
primary function.</p>
<p>NB. this function is not as generic as it could be.</p></div>
</dd>
<dt id="src.simple_sign.backend.KupoContext.retrieve_nft_holders"><code class="name flex">
<span>def <span class="ident">retrieve_nft_holders</span></span>(<span>self, policy: str, deny_list: list = None, addr: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of NFT holders, e.g. a license to operate
a decentralized node.</p>
<p>Filtering can be performed elsewhere, but a deny_list is used
to remove some results that are unhelpful, e.g. the minting
address if desired.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></b></code>:
<ul class="hlist">
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_staked_holders" href="#src.simple_sign.backend.BackendContext.retrieve_staked_holders">retrieve_staked_holders</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.simple_sign.backend.ValidTx"><code class="flex name class">
<span>class <span class="ident">ValidTx</span></span>
<span>(</span><span>slot: int, tx_id: str, address: str, staking: str)</span>
</code></dt>
<dd>
<div class="desc"><p>ValidTx(slot: int, tx_id: str, address: str, staking: str)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ValidTx:
    slot: int
    tx_id: str
    address: str
    staking: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.simple_sign.backend.ValidTx.address"><code class="name">var <span class="ident">address</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.slot"><code class="name">var <span class="ident">slot</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.staking"><code class="name">var <span class="ident">staking</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.tx_id"><code class="name">var <span class="ident">tx_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.simple_sign" href="index.html">src.simple_sign</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_metadata" href="#src.simple_sign.backend.BackendContext.retrieve_metadata">retrieve_metadata</a></code></li>
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_nft_holders" href="#src.simple_sign.backend.BackendContext.retrieve_nft_holders">retrieve_nft_holders</a></code></li>
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_staked_holders" href="#src.simple_sign.backend.BackendContext.retrieve_staked_holders">retrieve_staked_holders</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.simple_sign.backend.KupoContext" href="#src.simple_sign.backend.KupoContext">KupoContext</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.KupoContext.retrieve_metadata" href="#src.simple_sign.backend.KupoContext.retrieve_metadata">retrieve_metadata</a></code></li>
<li><code><a title="src.simple_sign.backend.KupoContext.retrieve_nft_holders" href="#src.simple_sign.backend.KupoContext.retrieve_nft_holders">retrieve_nft_holders</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.simple_sign.backend.ValidTx" href="#src.simple_sign.backend.ValidTx">ValidTx</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.ValidTx.address" href="#src.simple_sign.backend.ValidTx.address">address</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.slot" href="#src.simple_sign.backend.ValidTx.slot">slot</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.staking" href="#src.simple_sign.backend.ValidTx.staking">staking</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.tx_id" href="#src.simple_sign.backend.ValidTx.tx_id">tx_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.3</a>.</p>
</footer>
</body>
</html>

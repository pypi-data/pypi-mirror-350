Index: src/jumpthegun/jumpthegunctl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import io\nimport os\nimport shlex\nimport signal\nimport socket\nimport sys\nimport time\nimport traceback\nfrom pathlib import Path\nfrom typing import Any, BinaryIO, Dict, Optional, Tuple, cast\n\nfrom .__version__ import __version__\nfrom .config import read_config\nfrom .env_vars import apply_env_with_diff, calc_env_diff\nfrom .io_redirect import SocketOutputRedirector, StdinWrapper\nfrom .runtime_dir import get_isolated_service_runtime_dir_for_tool\nfrom .tools import ToolExceptionBase, get_tool_entrypoint\nfrom .utils import pid_exists\n\n\nclass InvalidCommand(Exception):\n    def __init__(self, command: str):\n        super().__init__(command)\n        self.command = command\n\n\nclass DaemonAlreadyExistsError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" already exists.'\n        )\n\n\nclass DaemonDoesNotExistError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" does not exist.'\n        )\n\n\nclass StdinWrapper(io.RawIOBase):\n    \"\"\"TODO!\"\"\"\n\n    def __init__(self, sock: socket.socket) -> None:\n        self._sock = sock\n        self._buf = bytearray()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def readline(self, size: Optional[int] = -1) -> bytes:\n        # print(f\"readline({size=})\", file=sys.__stdout__)\n        if size is None:\n            size = -1\n        self._sock.sendall(b\"3\\n\")\n        buf = self._buf\n        while size:\n            chunk = self._sock.recv(size if size != -1 else 4096)\n            # print(f\"CHUNK {chunk}\", file=sys.__stdout__)\n            if not chunk:\n                self._buf = bytearray()\n                break\n            idx = chunk.find(10)  # ord(\"\\n\") == 10\n            if idx >= 0:\n                size = idx + 1\n            if len(chunk) >= size:\n                buf.extend(chunk[:size])\n                self._buf = bytearray(chunk[size:])\n                break\n            buf.extend(chunk)\n            size = size - len(chunk) if size != -1 else -1\n\n        return buf\n\n    read = readline\n\n    def fileno(self) -> Any:\n        return self._sock.fileno()\n\n\ndef get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:\n    service_runtime_dir_path = get_isolated_service_runtime_dir_for_tool(tool_name)\n    pid_file_path = service_runtime_dir_path / f\"{tool_name}.pid\"\n    port_file_path = service_runtime_dir_path / f\"{tool_name}.port\"\n    return pid_file_path, port_file_path\n\n\ndef remove_pid_and_port_files(tool_name: str) -> None:\n    for file_path in get_pid_and_port_file_paths(tool_name):\n        if file_path.exists():\n            try:\n                file_path.unlink()\n            except Exception:\n                pass\n\n\ndef daemon_teardown(\n    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path\n) -> None:\n    \"\"\"Close socket and remove pid and port files upon daemon shutdown.\"\"\"\n    sock.close()\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if file_pid == pid:\n            pid_file_path.unlink(missing_ok=True)\n            port_file_path.unlink(missing_ok=True)\n\n\ndef start(tool_name: str, daemonize: bool = True) -> None:\n    config = read_config()\n\n    # Import the tool and get its entrypoint function.\n    #\n    # Override sys.stdout and sys.stderr while loading the tool runner,\n    # so that any references to them kept during module imports (e.g for\n    # setting up logging) already reference the overrides.\n    output_redirector = SocketOutputRedirector()\n    with output_redirector.override_outputs_for_imports():\n        tool_entrypoint = get_tool_entrypoint(tool_name)\n        env_before = dict(os.environ)\n        tool_runner = tool_entrypoint.load()\n        env_after = dict(os.environ)\n        changed_env_vars = dict(set(env_after.items()) - set(env_before.items()))\n        deleted_env_vars = set(env_before) - set(env_after)\n\n    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)\n\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if pid_exists(file_pid):\n            raise DaemonAlreadyExistsError(tool_name=tool_name)\n\n    if daemonize:\n        # Do the double-fork dance to daemonize.\n        # See:\n        # * https://stackoverflow.com/a/5386753\n        # * https://www.win.tue.nl/~aeb/linux/lk/lk-10.html\n\n        pid = os.fork()\n        if pid > 0:\n            print(f'\"jumpthegun {tool_name}\" daemon process starting...')\n            return\n\n        os.setsid()\n\n        pid = os.fork()\n        if pid > 0:\n            sys.exit(0)\n\n        # redirect standard file descriptors\n        sys.__stdout__.flush()\n        sys.__stderr__.flush()\n        stdin = open(\"/dev/null\", \"rb\")\n        stdout = open(\"/dev/null\", \"ab\")\n        stderr = open(\"/dev/null\", \"ab\")\n        os.dup2(stdin.fileno(), sys.__stdin__.fileno())\n        os.dup2(stdout.fileno(), sys.__stdout__.fileno())\n        os.dup2(stderr.fileno(), sys.__stderr__.fileno())\n\n    # Write pid file.\n    pid = os.getpid()\n    pid_file_path.write_bytes(b\"%d\\n\" % pid)\n\n    # Open socket.\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"127.0.0.1\", 0))\n\n    # Write port file.\n    host, port = sock.getsockname()\n    port_file_path.write_bytes(b\"%d\\n\" % port)\n\n    # Listen for connections.\n    sock.listen()\n    print(f\"Listening on {host}:{port} (pid={pid}) ...\")\n    sock.settimeout(config.idle_timeout_seconds)\n    subproc_pids = set()\n    try:\n        while True:\n            conn, address = sock.accept()\n            print(f\"Got connection from: {address}\")\n            newpid = os.fork()\n            if newpid == 0:\n                break\n\n            # Avoid \"zombie\" processes: Reap completed sub-processes.\n            done_subproc_pids = {\n                x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0\n            }\n            subproc_pids -= done_subproc_pids\n            subproc_pids.add(newpid)\n    except BaseException as exc:\n        # Server is exiting: Clean up as needed.\n        sock.close()\n        if pid_file_path.exists():\n            file_pid = int(pid_file_path.read_text())\n            if file_pid == pid:\n                pid_file_path.unlink(missing_ok=True)\n                port_file_path.unlink(missing_ok=True)\n        if isinstance(exc, socket.timeout):\n            print(\n                f\"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds.\"\n            )\n            return\n        raise\n\n    # Send pid.\n    conn.sendall(b\"%d\\n\" % os.getpid())\n\n    rfile = conn.makefile(\"rb\", 0)\n\n    # Read and set argv\n    argv_bytes: bytes = rfile.read(int(rfile.readline()))\n    sys.argv[1:] = shlex.split(argv_bytes.decode())\n    sys.argv[0] = tool_name\n\n    # Read and set cwd\n    pwd: bytes = rfile.read(int(rfile.readline()))\n    os.chdir(pwd)\n\n    # Read and set env vars\n    env_vars_str: str = rfile.read(int(rfile.readline())).decode()\n    split_lines = (line.split(\"=\", 1) for line in env_vars_str.split(\"\\0\"))\n    env_vars: Dict[str, str] = dict(line for line in split_lines if len(line) == 2)\n    env_vars.pop(\"_\", None)\n    for var_name in deleted_env_vars:\n        env_vars.pop(var_name, None)\n    env_vars.update(changed_env_vars)\n    for env_var_name in set(os.environ) - set(env_vars):\n        del os.environ[env_var_name]\n    os.environ.update(env_vars)\n\n    sys.stdin.close()\n    sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))\n    output_redirector.set_socket(conn)\n\n    # start_time = time.monotonic()\n    try:\n        retval = tool_runner()\n    except BaseException as exc:\n        # end_time = time.monotonic()\n        # print(f\"Time: {end_time - start_time}\", file=sys.__stdout__)\n        # print(\"EXCEPTION\", str(exc), file=sys.__stderr__)\n        if isinstance(exc, SystemExit):\n            exit_code = exc.code\n        else:\n            traceback.print_exc()\n            exit_code = 1\n        # print(f\"{exit_code=}\", file=sys.__stdout__)\n        if isinstance(exit_code, bool):\n            exit_code = int(exit_code)\n        elif not isinstance(exit_code, int):\n            exit_code = 1\n    else:\n        if isinstance(retval, int):\n            exit_code = retval\n        else:\n            exit_code = 0\n    finally:\n        conn.sendall(b\"rc=%d\\n\" % exit_code)\n        # print(f\"Goodbye! rc={exit_code}\", file=sys.__stdout__)\n\n        sys.stdin.close()\n        sys.stdout.close()\n        sys.stderr.close()\n        conn.shutdown(socket.SHUT_WR)\n        sys.exit(0)\n\n\ndef stop(tool_name: str) -> None:\n    try:\n        get_tool_entrypoint(tool_name)\n    except ToolExceptionBase:\n        raise DaemonDoesNotExistError(tool_name)\n\n    try:\n        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)\n        if not pid_file_path.exists():\n            raise DaemonDoesNotExistError(tool_name)\n\n        file_pid = int(pid_file_path.read_text())\n        if not pid_exists(file_pid):\n            raise DaemonDoesNotExistError(tool_name)\n\n        os.kill(file_pid, signal.SIGTERM)\n        for _i in range(20):\n            time.sleep(0.05)\n            if not pid_exists(file_pid):\n                break\n        else:\n            os.kill(file_pid, signal.SIGKILL)\n\n        print(f'\"jumpthegun {tool_name}\" daemon process stopped.')\n\n    finally:\n        remove_pid_and_port_files(tool_name)\n\n\ndef print_usage() -> None:\n    \"\"\"Print a message about how to run jumpthegunctl.\"\"\"\n    print(f\"Usage: {sys.argv[0]} start|stop tool_name\")\n\n\ndef do_action(tool_name: str, action: str) -> None:\n    \"\"\"Apply an action (e.g. start or stop) for a given tool.\"\"\"\n    if action == \"start\":\n        start(tool_name)\n    elif action == \"stop\":\n        stop(tool_name)\n    elif action == \"restart\":\n        try:\n            stop(tool_name)\n        except DaemonDoesNotExistError:\n            pass\n        start(tool_name)\n    else:\n        raise InvalidCommand(action)\n\n\ndef main() -> None:\n    args = sys.argv[1:]\n\n    if any(arg == \"-h\" or arg == \"--help\" for arg in args):\n        print_usage()\n        sys.exit(0)\n\n    if len(args) == 1:\n        (cmd,) = args\n        if cmd == \"version\" or cmd == \"--version\":\n            print(f\"jumpthegun v{__version__}\")\n            sys.exit(0)\n    elif len(args) == 2:\n        (cmd, tool_name) = args\n        tool_name = tool_name.strip().lower()\n\n        try:\n            do_action(tool_name=tool_name, action=cmd)\n        except ToolExceptionBase as exc:\n            print(str(exc))\n            sys.exit(1)\n        except InvalidCommand as exc:\n            print(str(exc))\n        else:\n            sys.exit(0)\n\n    print_usage()\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpthegunctl.py b/src/jumpthegun/jumpthegunctl.py
--- a/src/jumpthegun/jumpthegunctl.py	(revision 1018b6726338570817cf023a0d23d48a10267ffb)
+++ b/src/jumpthegun/jumpthegunctl.py	(date 1692043110066)
@@ -11,7 +11,6 @@
 
 from .__version__ import __version__
 from .config import read_config
-from .env_vars import apply_env_with_diff, calc_env_diff
 from .io_redirect import SocketOutputRedirector, StdinWrapper
 from .runtime_dir import get_isolated_service_runtime_dir_for_tool
 from .tools import ToolExceptionBase, get_tool_entrypoint

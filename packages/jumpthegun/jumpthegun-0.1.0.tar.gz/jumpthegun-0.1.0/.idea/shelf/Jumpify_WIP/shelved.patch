Index: src/jumpthegun/jumpified.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpified.py b/src/jumpthegun/jumpified.py
new file mode 100644
--- /dev/null	(date 1684611546044)
+++ b/src/jumpthegun/jumpified.py	(date 1684611546044)
@@ -0,0 +1,11 @@
+import os
+
+
+def set_entrypoint_here():
+    if os.environ.get("_JUMPTHEGUN_JUMPIFIED"):
+        next(jumpified_start())
+
+
+def jumpified_start():
+    # TODO
+    yield
Index: src/jumpthegun/jumpthegunctl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\nimport io\nimport json\nimport os\nimport random\nimport shlex\nimport signal\nimport socket\nimport string\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, BinaryIO, Dict, Optional, Tuple, cast\n\nfrom .__version__ import __version__\nfrom ._vendor.filelock import FileLock\nfrom .output_redirect import SocketOutputRedirector\nfrom .tools import ToolExceptionBase, get_tool_entrypoint\nfrom .utils import pid_exists\n\n\nclass InvalidCommand(Exception):\n    def __init__(self, command: str):\n        super().__init__(command)\n        self.command = command\n\n\nclass DaemonAlreadyExistsError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" already exists.'\n        )\n\n\nclass DaemonDoesNotExistError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" does not exist.'\n        )\n\n\nclass StdinWrapper(io.RawIOBase):\n    \"\"\"TODO!\"\"\"\n\n    def __init__(self, sock: socket.socket) -> None:\n        self._sock = sock\n        self._buf = bytearray()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def readline(self, size: Optional[int] = -1) -> bytes:\n        # print(f\"readline({size=})\", file=sys.__stdout__)\n        if size is None:\n            size = -1\n        self._sock.sendall(b\"3\\n\")\n        buf = self._buf\n        while size:\n            chunk = self._sock.recv(size if size != -1 else 4096)\n            # print(f\"CHUNK {chunk}\", file=sys.__stdout__)\n            if not chunk:\n                self._buf = bytearray()\n                break\n            idx = chunk.find(10)  # ord(\"\\n\") == 10\n            if idx >= 0:\n                size = idx + 1\n            if len(chunk) >= size:\n                buf.extend(chunk[:size])\n                self._buf = bytearray(chunk[size:])\n                break\n            buf.extend(chunk)\n            size = size - len(chunk) if size != -1 else -1\n\n        return buf\n\n    read = readline\n\n    def fileno(self) -> Any:\n        return self._sock.fileno()\n\n\ndef get_xdg_config_dir() -> Path:\n    env_var = os.environ.get(\"XDG_CONFIG_HOME\")\n    if env_var:\n        return Path(env_var)\n    return Path.home() / \".config\"\n\n\n@dataclass(frozen=True)\nclass JumpTheGunConfig:\n    idle_timeout_seconds: Optional[int] = 4 * 60 * 60  # 4 hours\n\n    def __post_init__(self):\n        if self.idle_timeout_seconds is None:\n            pass\n        elif isinstance(self.idle_timeout_seconds, int):\n            if self.idle_timeout_seconds <= 0:\n                raise ValueError(\"idle_timeout_seconds must be positive.\")\n        else:\n            raise TypeError(\"idle_timeout_seconds must be an int or None.\")\n\n\ndef read_config() -> JumpTheGunConfig:\n    config_dir = get_xdg_config_dir()\n    if not config_dir.exists():\n        return JumpTheGunConfig()\n    config_file = config_dir / \"jumpthegun.json\"\n    if not config_file.exists():\n        return JumpTheGunConfig()\n    with config_file.open(encoding=\"utf-8\") as f:\n        config_data = json.load(f)\n    config = JumpTheGunConfig(**config_data)\n    return config\n\n\ndef get_service_runtime_dir_path() -> Path:\n    runtime_dir = os.getenv(\"XDG_RUNTIME_DIR\")\n    if runtime_dir:\n        service_runtime_dir = Path(runtime_dir) / \"jumpthegun\"\n        service_runtime_dir.mkdir(exist_ok=True, mode=0o700)\n        return service_runtime_dir\n\n    temp_dir_path = Path(tempfile.gettempdir())\n    service_runtime_dirs = list(\n        temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n    )\n    if service_runtime_dirs:\n        if len(service_runtime_dirs) > 1:\n            raise Exception(\"Error: Multiple service runtime dirs found.\")\n        return service_runtime_dirs[0]\n\n    lock = FileLock(temp_dir_path / f\"jumpthegun-{os.getenv('USER')}.lock\")\n    with lock:\n        service_runtime_dirs = list(\n            temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n        )\n        if service_runtime_dirs:\n            return service_runtime_dirs[0]\n\n        random_part = \"\".join([random.choice(string.ascii_letters) for _i in range(6)])\n        service_runtime_dir = (\n            temp_dir_path / f\"jumpthegun-{os.getenv('USER')}-{random_part}\"\n        )\n        service_runtime_dir.mkdir(exist_ok=False, mode=0o700)\n        return service_runtime_dir\n\n\ndef get_isolated_service_runtime_dir_path(tool_name) -> Path:\n    service_runtime_dir = get_service_runtime_dir_path()\n\n    tool_executable_path: bytes = subprocess.run(\n        f\"command -v {shlex.quote(tool_name)}\",\n        shell=True,\n        check=True,\n        capture_output=True,\n    ).stdout.strip()\n    tool_executable_dir_path: bytes = os.path.dirname(tool_executable_path)\n    isolation_hash: str = hashlib.sha256(tool_executable_dir_path).hexdigest()[:8]\n    isolated_path: Path = service_runtime_dir / isolation_hash\n\n    isolated_path.mkdir(exist_ok=True, mode=0o700)\n    return isolated_path\n\n\ndef get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:\n    service_runtime_dir_path = get_isolated_service_runtime_dir_path(tool_name)\n    pid_file_path = service_runtime_dir_path / f\"{tool_name}.pid\"\n    port_file_path = service_runtime_dir_path / f\"{tool_name}.port\"\n    return pid_file_path, port_file_path\n\n\ndef remove_pid_and_port_files(tool_name: str) -> None:\n    for file_path in get_pid_and_port_file_paths(tool_name):\n        if file_path.exists():\n            try:\n                file_path.unlink()\n            except Exception:\n                pass\n\n\ndef daemon_teardown(\n    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path\n) -> None:\n    \"\"\"Close socket and remove pid and port files upon daemon shutdown.\"\"\"\n    sock.close()\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if file_pid == pid:\n            pid_file_path.unlink(missing_ok=True)\n            port_file_path.unlink(missing_ok=True)\n\n\ndef start(tool_name: str, daemonize: bool = True) -> None:\n    config = read_config()\n\n    # Import the tool and get its entrypoint function.\n    #\n    # Override sys.stdout and sys.stderr while loading the tool runner,\n    # so that any references to them kept during module imports (e.g for\n    # setting up logging) already reference the overrides.\n    output_redirector = SocketOutputRedirector()\n    with output_redirector.override_outputs_for_imports():\n        tool_entrypoint = get_tool_entrypoint(tool_name)\n        env_before = dict(os.environ)\n        tool_runner = tool_entrypoint.load()\n        env_after = dict(os.environ)\n        changed_env_vars = dict(set(env_after.items()) - set(env_before.items()))\n        deleted_env_vars = set(env_before) - set(env_after)\n\n    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)\n\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if pid_exists(file_pid):\n            raise DaemonAlreadyExistsError(tool_name=tool_name)\n\n    if daemonize:\n        # Do the double-fork dance to daemonize.\n        # See:\n        # * https://stackoverflow.com/a/5386753\n        # * https://www.win.tue.nl/~aeb/linux/lk/lk-10.html\n\n        pid = os.fork()\n        if pid > 0:\n            print(f'\"jumpthegun {tool_name}\" daemon process starting...')\n            return\n\n        os.setsid()\n\n        pid = os.fork()\n        if pid > 0:\n            sys.exit(0)\n\n        # redirect standard file descriptors\n        sys.__stdout__.flush()\n        sys.__stderr__.flush()\n        stdin = open(\"/dev/null\", \"rb\")\n        stdout = open(\"/dev/null\", \"ab\")\n        stderr = open(\"/dev/null\", \"ab\")\n        os.dup2(stdin.fileno(), sys.__stdin__.fileno())\n        os.dup2(stdout.fileno(), sys.__stdout__.fileno())\n        os.dup2(stderr.fileno(), sys.__stderr__.fileno())\n\n    # Write pid file.\n    pid = os.getpid()\n    pid_file_path.write_bytes(b\"%d\\n\" % pid)\n\n    # Open socket.\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"127.0.0.1\", 0))\n\n    # Write port file.\n    host, port = sock.getsockname()\n    port_file_path.write_bytes(b\"%d\\n\" % port)\n\n    # Listen for connections.\n    sock.listen()\n    print(f\"Listening on {host}:{port} (pid={pid}) ...\")\n    sock.settimeout(config.idle_timeout_seconds)\n    subproc_pids = set()\n    try:\n        while True:\n            conn, address = sock.accept()\n            print(f\"Got connection from: {address}\")\n            newpid = os.fork()\n            if newpid == 0:\n                break\n\n            # Avoid \"zombie\" processes: Reap completed sub-processes.\n            done_subproc_pids = {\n                x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0\n            }\n            subproc_pids -= done_subproc_pids\n            subproc_pids.add(newpid)\n    except BaseException as exc:\n        # Server is exiting: Clean up as needed.\n        sock.close()\n        if pid_file_path.exists():\n            file_pid = int(pid_file_path.read_text())\n            if file_pid == pid:\n                pid_file_path.unlink(missing_ok=True)\n                port_file_path.unlink(missing_ok=True)\n        if isinstance(exc, socket.timeout):\n            print(\n                f\"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds.\"\n            )\n            return\n        raise\n\n    # Send pid.\n    conn.sendall(b\"%d\\n\" % os.getpid())\n\n    rfile = conn.makefile(\"rb\", 0)\n\n    # Read and set argv\n    argv_bytes: bytes = rfile.read(int(rfile.readline()))\n    sys.argv[1:] = shlex.split(argv_bytes.decode())\n    sys.argv[0] = tool_name\n\n    # Read and set cwd\n    pwd: bytes = rfile.read(int(rfile.readline()))\n    os.chdir(pwd)\n\n    # Read and set env vars\n    env_vars_str: str = rfile.read(int(rfile.readline())).decode()\n    split_lines = (line.split(\"=\", 1) for line in env_vars_str.split(\"\\0\"))\n    env_vars: Dict[str, str] = dict(line for line in split_lines if len(line) == 2)\n    env_vars.pop(\"_\", None)\n    for var_name in deleted_env_vars:\n        env_vars.pop(var_name, None)\n    env_vars.update(changed_env_vars)\n    for env_var_name in set(os.environ) - set(env_vars):\n        del os.environ[env_var_name]\n    os.environ.update(env_vars)\n\n    sys.stdin.close()\n    sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))\n    output_redirector.set_socket(conn)\n\n    # start_time = time.monotonic()\n    try:\n        retval = tool_runner()\n    except BaseException as exc:\n        # end_time = time.monotonic()\n        # print(f\"Time: {end_time - start_time}\", file=sys.__stdout__)\n        # print(\"EXCEPTION\", str(exc), file=sys.__stderr__)\n        if isinstance(exc, SystemExit):\n            exit_code = exc.code\n        else:\n            traceback.print_exc()\n            exit_code = 1\n        # print(f\"{exit_code=}\", file=sys.__stdout__)\n        if isinstance(exit_code, bool):\n            exit_code = int(exit_code)\n        elif not isinstance(exit_code, int):\n            exit_code = 1\n    else:\n        if isinstance(retval, int):\n            exit_code = retval\n        else:\n            exit_code = 0\n    finally:\n        conn.sendall(b\"rc=%d\\n\" % exit_code)\n        # print(f\"Goodbye! rc={exit_code}\", file=sys.__stdout__)\n\n        sys.stdin.close()\n        sys.stdout.close()\n        sys.stderr.close()\n        conn.shutdown(socket.SHUT_WR)\n        sys.exit(0)\n\n\ndef stop(tool_name: str) -> None:\n    try:\n        get_tool_entrypoint(tool_name)\n    except ToolExceptionBase:\n        raise DaemonDoesNotExistError(tool_name)\n\n    try:\n        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)\n        if not pid_file_path.exists():\n            raise DaemonDoesNotExistError(tool_name)\n\n        file_pid = int(pid_file_path.read_text())\n        if not pid_exists(file_pid):\n            raise DaemonDoesNotExistError(tool_name)\n\n        os.kill(file_pid, signal.SIGTERM)\n        for _i in range(20):\n            time.sleep(0.05)\n            if not pid_exists(file_pid):\n                break\n        else:\n            os.kill(file_pid, signal.SIGKILL)\n\n        print(f'\"jumpthegun {tool_name}\" daemon process stopped.')\n\n    finally:\n        remove_pid_and_port_files(tool_name)\n\n\ndef print_usage() -> None:\n    \"\"\"Print a message about how to run jumpthegunctl.\"\"\"\n    print(f\"Usage: {sys.argv[0]} start|stop tool_name\")\n\n\ndef do_action(tool_name: str, action: str) -> None:\n    \"\"\"Apply an action (e.g. start or stop) for a given tool.\"\"\"\n    if action == \"start\":\n        start(tool_name)\n    elif action == \"stop\":\n        stop(tool_name)\n    elif action == \"restart\":\n        try:\n            stop(tool_name)\n        except DaemonDoesNotExistError:\n            pass\n        start(tool_name)\n    else:\n        raise InvalidCommand(action)\n\n\ndef main() -> None:\n    args = sys.argv[1:]\n\n    if any(arg == \"-h\" or arg == \"--help\" for arg in args):\n        print_usage()\n        sys.exit(0)\n\n    if len(args) == 1:\n        (cmd,) = args\n        if cmd == \"version\" or cmd == \"--version\":\n            print(f\"jumpthegun v{__version__}\")\n            sys.exit(0)\n    elif len(args) == 2:\n        (cmd, tool_name) = args\n        tool_name = tool_name.strip().lower()\n\n        try:\n            do_action(tool_name=tool_name, action=cmd)\n        except ToolExceptionBase as exc:\n            print(str(exc))\n            sys.exit(1)\n        except InvalidCommand as exc:\n            print(str(exc))\n        else:\n            sys.exit(0)\n\n    print_usage()\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpthegunctl.py b/src/jumpthegun/jumpthegunctl.py
--- a/src/jumpthegun/jumpthegunctl.py	(revision a7c1a725a5427d6f14f7057c01b9dc3248b78c1b)
+++ b/src/jumpthegun/jumpthegunctl.py	(date 1684524797692)
@@ -197,7 +197,7 @@
             port_file_path.unlink(missing_ok=True)
 
 
-def start(tool_name: str, daemonize: bool = True) -> None:
+def start(tool_name: str, daemonize: bool = True, jumpified: bool = False) -> None:
     config = read_config()
 
     # Import the tool and get its entrypoint function.
@@ -209,7 +209,10 @@
     with output_redirector.override_outputs_for_imports():
         tool_entrypoint = get_tool_entrypoint(tool_name)
         env_before = dict(os.environ)
-        tool_runner = tool_entrypoint.load()
+        if jumpified:
+            pass  # TODO
+        else:
+            tool_runner = tool_entrypoint.load()
         env_after = dict(os.environ)
         changed_env_vars = dict(set(env_after.items()) - set(env_before.items()))
         deleted_env_vars = set(env_before) - set(env_after)
@@ -419,8 +422,11 @@
         if cmd == "version" or cmd == "--version":
             print(f"jumpthegun v{__version__}")
             sys.exit(0)
-    elif len(args) == 2:
-        (cmd, tool_name) = args
+    elif 2 <= len(args) <= 3:
+        (cmd, *flags, tool_name) = args
+        kwargs = {}
+        if cmd == "start" and flags == ("--jumpified"):
+            kwargs["jumpifed"] = True
         tool_name = tool_name.strip().lower()
 
         try:

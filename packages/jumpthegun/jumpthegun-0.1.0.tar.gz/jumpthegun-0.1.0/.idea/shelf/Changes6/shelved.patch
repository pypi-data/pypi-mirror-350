Index: src/jumpthegun/jumpthegunctl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\nimport io\nimport json\nimport os\nimport random\nimport shlex\nimport signal\nimport socket\nimport string\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, BinaryIO, Dict, Optional, Tuple, cast\n\nfrom .__version__ import __version__\nfrom ._vendor.filelock import FileLock\nfrom .output_redirect import SocketOutputRedirector\nfrom .tools import ToolExceptionBase, get_tool_entrypoint\nfrom .utils import pid_exists\n\n\nclass InvalidCommand(Exception):\n    def __init__(self, command: str):\n        super().__init__(command)\n        self.command = command\n\n\nclass DaemonAlreadyExistsError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" already exists.'\n        )\n\n\nclass DaemonDoesNotExistError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" does not exist.'\n        )\n\n\nclass StdinWrapper(io.RawIOBase):\n    \"\"\"TODO!\"\"\"\n\n    def __init__(self, sock: socket.socket) -> None:\n        self._sock = sock\n        self._buf = bytearray()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def readline(self, size: Optional[int] = -1) -> bytes:\n        # print(f\"readline({size=})\", file=sys.__stdout__)\n        if size is None:\n            size = -1\n        self._sock.sendall(b\"3\\n\")\n        buf = self._buf\n        while size:\n            chunk = self._sock.recv(size if size != -1 else 4096)\n            # print(f\"CHUNK {chunk}\", file=sys.__stdout__)\n            if not chunk:\n                self._buf = bytearray()\n                break\n            idx = chunk.find(10)  # ord(\"\\n\") == 10\n            if idx >= 0:\n                size = idx + 1\n            if len(chunk) >= size:\n                buf.extend(chunk[:size])\n                self._buf = bytearray(chunk[size:])\n                break\n            buf.extend(chunk)\n            size = size - len(chunk) if size != -1 else -1\n\n        return buf\n\n    read = readline\n\n    def fileno(self) -> Any:\n        return self._sock.fileno()\n\n\ndef get_xdg_config_dir() -> Path:\n    env_var = os.environ.get(\"XDG_CONFIG_HOME\")\n    if env_var:\n        return Path(env_var)\n    return Path.home() / \".config\"\n\n\n@dataclass(frozen=True)\nclass JumpTheGunConfig:\n    idle_timeout_seconds: Optional[int] = 4 * 60 * 60  # 4 hours\n\n    def __post_init__(self):\n        if self.idle_timeout_seconds is None:\n            pass\n        elif isinstance(self.idle_timeout_seconds, int):\n            if self.idle_timeout_seconds <= 0:\n                raise ValueError(\"idle_timeout_seconds must be positive.\")\n        else:\n            raise TypeError(\"idle_timeout_seconds must be an int or None.\")\n\n\ndef read_config() -> JumpTheGunConfig:\n    config_dir = get_xdg_config_dir()\n    if not config_dir.exists():\n        return JumpTheGunConfig()\n    config_file = config_dir / \"jumpthegun.json\"\n    if not config_file.exists():\n        return JumpTheGunConfig()\n    with config_file.open(encoding=\"utf-8\") as f:\n        config_data = json.load(f)\n    config = JumpTheGunConfig(**config_data)\n    return config\n\n\ndef get_service_runtime_dir_path() -> Path:\n    runtime_dir = os.getenv(\"XDG_RUNTIME_DIR\")\n    if runtime_dir:\n        service_runtime_dir = Path(runtime_dir) / \"jumpthegun\"\n        service_runtime_dir.mkdir(exist_ok=True, mode=0o700)\n        return service_runtime_dir\n\n    temp_dir_path = Path(tempfile.gettempdir())\n    service_runtime_dirs = list(\n        temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n    )\n    if service_runtime_dirs:\n        if len(service_runtime_dirs) > 1:\n            raise Exception(\"Error: Multiple service runtime dirs found.\")\n        return service_runtime_dirs[0]\n\n    lock = FileLock(temp_dir_path / f\"jumpthegun-{os.getenv('USER')}.lock\")\n    with lock:\n        service_runtime_dirs = list(\n            temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n        )\n        if service_runtime_dirs:\n            return service_runtime_dirs[0]\n\n        random_part = \"\".join([random.choice(string.ascii_letters) for _i in range(6)])\n        service_runtime_dir = (\n            temp_dir_path / f\"jumpthegun-{os.getenv('USER')}-{random_part}\"\n        )\n        service_runtime_dir.mkdir(exist_ok=False, mode=0o700)\n        return service_runtime_dir\n\n\ndef get_isolated_service_runtime_dir_path(tool_name) -> Path:\n    service_runtime_dir = get_service_runtime_dir_path()\n\n    tool_executable_path: bytes = subprocess.run(\n        f\"command -v {shlex.quote(tool_name)}\",\n        shell=True,\n        check=True,\n        capture_output=True,\n    ).stdout.strip()\n    tool_executable_dir_path: bytes = os.path.dirname(tool_executable_path)\n    isolation_hash: str = hashlib.sha256(tool_executable_dir_path).hexdigest()[:8]\n    isolated_path: Path = service_runtime_dir / isolation_hash\n\n    isolated_path.mkdir(exist_ok=True, mode=0o700)\n    return isolated_path\n\n\ndef get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:\n    service_runtime_dir_path = get_isolated_service_runtime_dir_path(tool_name)\n    pid_file_path = service_runtime_dir_path / f\"{tool_name}.pid\"\n    port_file_path = service_runtime_dir_path / f\"{tool_name}.port\"\n    return pid_file_path, port_file_path\n\n\ndef remove_pid_and_port_files(tool_name: str) -> None:\n    for file_path in get_pid_and_port_file_paths(tool_name):\n        if file_path.exists():\n            try:\n                file_path.unlink()\n            except Exception:\n                pass\n\n\ndef daemon_teardown(\n    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path\n) -> None:\n    \"\"\"Close socket and remove pid and port files upon daemon shutdown.\"\"\"\n    sock.close()\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if file_pid == pid:\n            pid_file_path.unlink(missing_ok=True)\n            port_file_path.unlink(missing_ok=True)\n\n\ndef start(tool_name: str, daemonize: bool = True) -> None:\n    config = read_config()\n\n    # Import the tool and get its entrypoint function.\n    #\n    # Override sys.stdout and sys.stderr while loading the tool runner,\n    # so that any references to them kept during module imports (e.g for\n    # setting up logging) already reference the overrides.\n    output_redirector = SocketOutputRedirector()\n    with output_redirector.override_outputs_for_imports():\n        tool_entrypoint = get_tool_entrypoint(tool_name)\n        env_before = dict(os.environ)\n        tool_runner = tool_entrypoint.load()\n        env_after = dict(os.environ)\n        changed_env_vars = dict(set(env_after.items()) - set(env_before.items()))\n        deleted_env_vars = set(env_before) - set(env_after)\n\n    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)\n\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if pid_exists(file_pid):\n            raise DaemonAlreadyExistsError(tool_name=tool_name)\n\n    if daemonize:\n        # Do the double-fork dance to daemonize.\n        # See:\n        # * https://stackoverflow.com/a/5386753\n        # * https://www.win.tue.nl/~aeb/linux/lk/lk-10.html\n\n        pid = os.fork()\n        if pid > 0:\n            print(f'\"jumpthegun {tool_name}\" daemon process starting...')\n            return\n\n        os.setsid()\n\n        pid = os.fork()\n        if pid > 0:\n            sys.exit(0)\n\n        # redirect standard file descriptors\n        sys.__stdout__.flush()\n        sys.__stderr__.flush()\n        stdin = open(\"/dev/null\", \"rb\")\n        stdout = open(\"/dev/null\", \"ab\")\n        stderr = open(\"/dev/null\", \"ab\")\n        os.dup2(stdin.fileno(), sys.__stdin__.fileno())\n        os.dup2(stdout.fileno(), sys.__stdout__.fileno())\n        os.dup2(stderr.fileno(), sys.__stderr__.fileno())\n\n    # Write pid file.\n    pid = os.getpid()\n    pid_file_path.write_bytes(b\"%d\\n\" % pid)\n\n    # Open socket.\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"127.0.0.1\", 0))\n\n    # Write port file.\n    host, port = sock.getsockname()\n    port_file_path.write_bytes(b\"%d\\n\" % port)\n\n    # Listen for connections.\n    sock.listen()\n    print(f\"Listening on {host}:{port} (pid={pid}) ...\")\n    sock.settimeout(config.idle_timeout_seconds)\n    subproc_pids = set()\n    try:\n        while True:\n            conn, address = sock.accept()\n            print(f\"Got connection from: {address}\")\n            newpid = os.fork()\n            if newpid == 0:\n                break\n\n            # Avoid \"zombie\" processes: Reap completed sub-processes.\n            done_subproc_pids = {\n                x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0\n            }\n            subproc_pids -= done_subproc_pids\n            subproc_pids.add(newpid)\n    except BaseException as exc:\n        # Server is exiting: Clean up as needed.\n        sock.close()\n        if pid_file_path.exists():\n            file_pid = int(pid_file_path.read_text())\n            if file_pid == pid:\n                pid_file_path.unlink(missing_ok=True)\n                port_file_path.unlink(missing_ok=True)\n        if isinstance(exc, socket.timeout):\n            print(\n                f\"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds.\"\n            )\n            return\n        raise\n\n    # Send pid.\n    conn.sendall(b\"%d\\n\" % os.getpid())\n\n    rfile = conn.makefile(\"rb\", 0)\n\n    # Read and set argv\n    argv_bytes: bytes = rfile.read(int(rfile.readline()))\n    sys.argv[1:] = shlex.split(argv_bytes.decode())\n    sys.argv[0] = tool_name\n\n    # Read and set cwd\n    pwd: bytes = rfile.read(int(rfile.readline()))\n    os.chdir(pwd)\n\n    # Read and set env vars\n    env_vars_str: str = rfile.read(int(rfile.readline())).decode()\n    split_lines = (line.split(\"=\", 1) for line in env_vars_str.split(\"\\0\"))\n    env_vars: Dict[str, str] = dict(line for line in split_lines if len(line) == 2)\n    env_vars.pop(\"_\", None)\n    for var_name in deleted_env_vars:\n        env_vars.pop(var_name, None)\n    env_vars.update(changed_env_vars)\n    for env_var_name in set(os.environ) - set(env_vars):\n        del os.environ[env_var_name]\n    os.environ.update(env_vars)\n\n    sys.stdin.close()\n    sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))\n    output_redirector.set_socket(conn)\n\n    # start_time = time.monotonic()\n    try:\n        retval = tool_runner()\n    except BaseException as exc:\n        # end_time = time.monotonic()\n        # print(f\"Time: {end_time - start_time}\", file=sys.__stdout__)\n        # print(\"EXCEPTION\", str(exc), file=sys.__stderr__)\n        if isinstance(exc, SystemExit):\n            exit_code = exc.code\n        else:\n            traceback.print_exc()\n            exit_code = 1\n        # print(f\"{exit_code=}\", file=sys.__stdout__)\n        if isinstance(exit_code, bool):\n            exit_code = int(exit_code)\n        elif not isinstance(exit_code, int):\n            exit_code = 1\n    else:\n        if isinstance(retval, int):\n            exit_code = retval\n        else:\n            exit_code = 0\n    finally:\n        conn.sendall(b\"rc=%d\\n\" % exit_code)\n        # print(f\"Goodbye! rc={exit_code}\", file=sys.__stdout__)\n\n        sys.stdin.close()\n        sys.stdout.close()\n        sys.stderr.close()\n        conn.shutdown(socket.SHUT_WR)\n        sys.exit(0)\n\n\ndef stop(tool_name: str) -> None:\n    try:\n        get_tool_entrypoint(tool_name)\n    except ToolExceptionBase:\n        raise DaemonDoesNotExistError(tool_name)\n\n    try:\n        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)\n        if not pid_file_path.exists():\n            raise DaemonDoesNotExistError(tool_name)\n\n        file_pid = int(pid_file_path.read_text())\n        if not pid_exists(file_pid):\n            raise DaemonDoesNotExistError(tool_name)\n\n        os.kill(file_pid, signal.SIGTERM)\n        for _i in range(20):\n            time.sleep(0.05)\n            if not pid_exists(file_pid):\n                break\n        else:\n            os.kill(file_pid, signal.SIGKILL)\n\n        print(f'\"jumpthegun {tool_name}\" daemon process stopped.')\n\n    finally:\n        remove_pid_and_port_files(tool_name)\n\n\ndef print_usage() -> None:\n    \"\"\"Print a message about how to run jumpthegunctl.\"\"\"\n    print(f\"Usage: {sys.argv[0]} start|stop tool_name\")\n\n\ndef do_action(tool_name: str, action: str) -> None:\n    \"\"\"Apply an action (e.g. start or stop) for a given tool.\"\"\"\n    if action == \"start\":\n        start(tool_name)\n    elif action == \"stop\":\n        stop(tool_name)\n    elif action == \"restart\":\n        try:\n            stop(tool_name)\n        except DaemonDoesNotExistError:\n            pass\n        start(tool_name)\n    else:\n        raise InvalidCommand(action)\n\n\ndef main() -> None:\n    args = sys.argv[1:]\n\n    if any(arg == \"-h\" or arg == \"--help\" for arg in args):\n        print_usage()\n        sys.exit(0)\n\n    if len(args) == 1:\n        (cmd,) = args\n        if cmd == \"version\" or cmd == \"--version\":\n            print(f\"jumpthegun v{__version__}\")\n            sys.exit(0)\n    elif len(args) == 2:\n        (cmd, tool_name) = args\n        tool_name = tool_name.strip().lower()\n\n        try:\n            do_action(tool_name=tool_name, action=cmd)\n        except ToolExceptionBase as exc:\n            print(str(exc))\n            sys.exit(1)\n        except InvalidCommand as exc:\n            print(str(exc))\n        else:\n            sys.exit(0)\n\n    print_usage()\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpthegunctl.py b/src/jumpthegun/jumpthegunctl.py
--- a/src/jumpthegun/jumpthegunctl.py	(revision a7c1a725a5427d6f14f7057c01b9dc3248b78c1b)
+++ b/src/jumpthegun/jumpthegunctl.py	(date 1684446187284)
@@ -162,8 +162,19 @@
         capture_output=True,
     ).stdout.strip()
     tool_executable_dir_path: bytes = os.path.dirname(tool_executable_path)
-    isolation_hash: str = hashlib.sha256(tool_executable_dir_path).hexdigest()[:8]
-    isolated_path: Path = service_runtime_dir / isolation_hash
+    # isolation_hash: str = hashlib.sha256(tool_executable_dir_path).hexdigest()[:8]
+    cksum_proc = subprocess.Popen(
+        ["cksum", "-"],
+        stdin=subprocess.PIPE,
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+    )
+    (cksum_output, _cksum_stderr) = cksum_proc.communicate(
+        tool_executable_dir_path + b"\n"
+    )
+    print(cksum_output.decode("ascii"))
+    isolation_hash: str = cksum_output.split(b" ", maxsplit=1)[0].decode("ascii")
+    isolated_path: Path = service_runtime_dir / Path(isolation_hash)
 
     isolated_path.mkdir(exist_ok=True, mode=0o700)
     return isolated_path
@@ -197,7 +208,8 @@
             port_file_path.unlink(missing_ok=True)
 
 
-def start(tool_name: str, daemonize: bool = True) -> None:
+# def start(tool_name: str, daemonize: bool = True) -> None:
+def start(tool_name: str, daemonize: bool = False) -> None:  # TODO
     config = read_config()
 
     # Import the tool and get its entrypoint function.
@@ -294,6 +306,8 @@
             return
         raise
 
+    print(f" 1   Time: {time.monotonic():0.6f}")
+
     # Send pid.
     conn.sendall(b"%d\n" % os.getpid())
 
@@ -304,26 +318,39 @@
     sys.argv[1:] = shlex.split(argv_bytes.decode())
     sys.argv[0] = tool_name
 
+    print(f" 2   Time: {time.monotonic():0.6f}")
+
     # Read and set cwd
     pwd: bytes = rfile.read(int(rfile.readline()))
     os.chdir(pwd)
 
+    print(f" 3   Time: {time.monotonic():0.6f}")
+
     # Read and set env vars
     env_vars_str: str = rfile.read(int(rfile.readline())).decode()
+    print(f" 3.1 Time: {time.monotonic():0.6f}")
     split_lines = (line.split("=", 1) for line in env_vars_str.split("\0"))
+    print(f" 3.2 Time: {time.monotonic():0.6f}")
     env_vars: Dict[str, str] = dict(line for line in split_lines if len(line) == 2)
+    print(f" 3.3 Time: {time.monotonic():0.6f}")
     env_vars.pop("_", None)
+    print(f" 3.4 Time: {time.monotonic():0.6f}")
     for var_name in deleted_env_vars:
         env_vars.pop(var_name, None)
+    print(f" 3.5 Time: {time.monotonic():0.6f}")
     env_vars.update(changed_env_vars)
     for env_var_name in set(os.environ) - set(env_vars):
         del os.environ[env_var_name]
+    print(f" 3.6 Time: {time.monotonic():0.6f}")
     os.environ.update(env_vars)
+    print(f" 3.7 Time: {time.monotonic():0.6f}")
 
     sys.stdin.close()
     sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))
     output_redirector.set_socket(conn)
 
+    print(f" 4   Time: {time.monotonic():0.6f}")
+
     # start_time = time.monotonic()
     try:
         retval = tool_runner()
Index: src/jumpthegun.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/bin/bash\nset -eEu -o pipefail\n\nfunction usage() {\n  echo \"Usage: $0 command tool_name ...\"\n  echo\n  echo \"Available commands:\"\n  echo\n  echo \"run tool_name [OPTIONS] [arg ...]    Run a CLI tool.\"\n  echo \"start tool_name                      Start a daemon for a CLI tool.\"\n  echo \"stop tool_name                       Stop a daemon for a CLI tool.\"\n  echo \"restart tool_name                    Restart a daemon for a CLI tool.\"\n  echo\n}\n\nfunction err_exit() {\n  err_msg=\"$1\"\n  echo \"$err_msg\" >&2\n  exit 1\n}\n\nfunction get_service_runtime_dir() {\n  runtime_dir=\"${XDG_RUNTIME_DIR:-}\"\n  if [ -n \"$runtime_dir\" ]; then\n    echo -n \"$runtime_dir/jumpthegun\"\n  else\n    temp_dir=\"${TMPDIR:-/tmp}\"\n    shopt -s nullglob\n    service_runtime_dirs=(\"$temp_dir/jumpthegun-$USER\"-??????)\n    shopt -u nullglob\n    if [[ ${#service_runtime_dirs[@]} -eq 1 ]]; then\n      echo -n \"${service_runtime_dirs[0]}\"\n    elif [[ ${#service_runtime_dirs[@]} -gt 1 ]]; then\n      err_exit \"Error: Multiple service runtime dirs found.\"\n    fi\n  fi\n}\n\nfunction hash_str() {\n  if [[ $OSTYPE == \"darwin\"* ]]; then\n    echo -n \"$1\" | shasum -a 256 - | head -c 8\n  else\n    echo -n \"$1\" | sha256sum - | head -c 8\n  fi\n}\n\nautorun=1\ncase \"${1:-}\" in\n-h|--help)\n  usage && exit 0 ;;\nstart|stop|restart|version|--version)\n  [[ \"$2\" =~ -h|--help ]] && usage && exit 0\n  tool_name=\"$2\"\n\n  # Find the tool's Python executable and check if it has JumpTheGun installed.\n  tool_path=\"$(command -v -- \"$tool_name\" 2>/dev/null)\" || err_exit \"Command not found: $tool_name\"\n  shebang=\"$(head -n 1 -- \"$tool_path\" 2>/dev/null)\"\n  [[ \"${shebang:0:2}\" == \"#!\" ]] || err_exit \"No shebang (#!) found in script: $tool_path\"\n  if ! python_executable=\"$(${shebang#\\#!} -c 'import sys; print(sys.executable); import jumpthegun' 2>/dev/null)\"; then\n    # Find JumpTheGun's code.\n    SCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\n    jumpthegunctl_path=\"$SCRIPT_DIR/jumpthegunctl\"\n    jumpthegunctl_shebang=\"$(head -n 1 -- \"$jumpthegunctl_path\")\"\n    jumpthegunctl_python_executable=\"$(${jumpthegunctl_shebang#\\#!} -c 'import sys; print(sys.executable)')\"\n    jumpthegun_lib_dir=\"$(\"$jumpthegunctl_python_executable\" -c 'import jumpthegun, os; print(os.path.dirname(jumpthegun.__file__))')\"\n\n    # Make a copy of this version of JumpTheGun's code in a cache directory.\n    dir_name=\"lib-$(hash_str \"$python_executable|$(head -n 1 \"$jumpthegun_lib_dir/__version__.py\")\")\"\n    cache_home=${XDG_CACHE_HOME:-\"$HOME/.cache\"}\n    cache_dir=\"$cache_home/jumpthegun/$dir_name\"\n    if [ ! -d \"$cache_dir\" ]; then\n      mkdir -p \"$cache_dir\"\n      cp -r -- \"$jumpthegun_lib_dir\" \"$cache_dir/jumpthegun\"\n      find \"$cache_dir/jumpthegun\" -type f -not -name '*.py' -exec rm {} +\n    fi\n\n    # Add the cache directory to PYTHONPATH.\n    if [[ -n \"${PYTHONPATH:-}\" ]]; then\n      export PYTHONPATH=\"$cache_dir:$PYTHONPATH\"\n    else\n      export PYTHONPATH=\"$cache_dir\"\n    fi\n  fi\n\n  # Run JumpTheGun.\n  set -f  # Disable filename expansion (globbing).\n  exec $python_executable -c \"from jumpthegun.jumpthegunctl import main; main()\" \"$@\"\n  ;;\nrun)\n  shift\n  [[ $# -eq 0 ]] && usage && exit 1\n  if [[ \"$1\" == \"--no-autorun\" ]]; then\n    autorun=0\n    shift\n  fi\n  [[ \"$1\" =~ -h|--help ]] && usage && exit 0\n  tool_name=\"$1\"\n  shift\n  ;;\n*)\n  usage && exit 1 ;;\nesac\n\n# Find service runtime directory.\nservice_runtime_dir=\"$(get_service_runtime_dir)\"\nif [[ -z \"$service_runtime_dir\" ]]; then\n  [[ autorun -eq 1 ]] && \"${BASH_SOURCE[0]}\" start \"$tool_name\" &>/dev/null &\n  exec \"$tool_name\" \"$@\"\nfi\n\n# Calculate the isolated path for pid and port files.\nisolated_root=\"$(dirname \"$(command -v -- \"$tool_name\")\")\"\nisolated_root_hash=\"$(hash_str \"$isolated_root\")\"\nisolated_path=\"$service_runtime_dir/$isolated_root_hash\"\n\n# Check that port file exists.\nif [[ ! -f \"$isolated_path/$tool_name.port\" ]]; then\n  [[ autorun -eq 1 ]] && \"${BASH_SOURCE[0]}\" start \"$tool_name\" &>/dev/null &\n  exec \"$tool_name\" \"$@\"\nfi\n\n# Read port from port file.\nIFS= read -r port <\"$isolated_path/$tool_name.port\"\n\n# Open TCP connection.\nexec 3<>\"/dev/tcp/127.0.0.1/$port\"\n\n# Close TCP connection upon exit.\nfunction close_connection {\n  exec 3<&-\n}\ntrap close_connection EXIT\n\n\n# Read companion process PID.\nread -r -u 3 pid\n\n# Forward some signals.\nfunction forward_signal() {\n  kill -s \"$1\" \"$pid\"\n}\nfor sig in INT TERM USR1 USR2; do\n  trap \"forward_signal $sig\" \"$sig\"\ndone\n\n# Send argv and cwd.\noLang=\"${LANG-}\" oLcAll=\"${LC_ALL-}\"\nLANG=C LC_ALL=C\n# Add an x in front to avoid special-casing having zero arguments.\nargv_str=$(printf ' %q' x \"$@\")\n# Remove the leading \" x \".\nargv_str=\"${argv_str:3}\"\nprintf '%d\\n%s%d\\n%s' \"${#argv_str}\" \"$argv_str\" \"${#PWD}\" \"$PWD\" >&3\nLANG=\"$oLang\" LC_ALL=\"$oLcAll\"\n\n# Send env vars.\nx=\"$(mktemp)\"\nenv -0 > \"$x\" 2>/dev/null\nif [[ $OSTYPE == \"darwin\"* ]]; then\n  stat -f %z \"$x\" >&3\nelse\n  stat -c %s \"$x\" >&3\nfi\ncat \"$x\" >&3\nrm \"$x\"\n\n\n# Read stdout and stderr from connection, line by line, and echo them.\nIFS=\nwhile read -r -u 3 line; do\n  case \"$line\" in\n    1*)\n      # stdout\n      n_newlines=\"${line:1}\"\n      for (( i=1; i <= n_newlines; i++ )); do\n        read -r -u 3 line\n        echo \"$line\"\n      done\n      read -r -u 3 line\n      echo -n \"$line\"\n      ;;\n    2*)\n      # stderr\n      n_newlines=\"${line:1}\"\n      for (( i=1; i <= n_newlines; i++ )); do\n        read -r -u 3 line\n        echo \"$line\" >&2\n      done\n      read -r -u 3 line\n      echo -n \"$line\" >&2\n      ;;\n    3*)\n      # stdin\n      read -r line2\n      echo \"$line2\" >&3\n      ;;\n    rc=*)\n      # exit\n      rc=\"${line:3}\"\n      exit \"$rc\"\n      ;;\n    *)\n      echo \"Error: Unexpected output from jumpthegun daemon.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun.sh b/src/jumpthegun.sh
--- a/src/jumpthegun.sh	(revision a7c1a725a5427d6f14f7057c01b9dc3248b78c1b)
+++ b/src/jumpthegun.sh	(date 1684446131992)
@@ -36,13 +36,18 @@
   fi
 }
 
-function hash_str() {
-  if [[ $OSTYPE == "darwin"* ]]; then
-    echo -n "$1" | shasum -a 256 - | head -c 8
-  else
-    echo -n "$1" | sha256sum - | head -c 8
-  fi
-}
+if [[ $OSTYPE == "darwin"* ]]; then
+  function hash_str() {
+    sum=$(shasum -a 256 - <<< "$1")
+    echo "${sum%% *}"
+  }
+else
+  function hash_str() {
+    cksum - <<< "$1" | cut -d" '"
+  }
+fi
+
+date +%s.%N
 
 autorun=1
 case "${1:-}" in
@@ -109,10 +114,12 @@
 fi
 
 # Calculate the isolated path for pid and port files.
-isolated_root="$(dirname "$(command -v -- "$tool_name")")"
-isolated_root_hash="$(hash_str "$isolated_root")"
+#isolated_root="$(dirname "$(command -v -- "$tool_name")")"
+#isolated_root_hash="$(hash_str "$isolated_root")"
+isolated_root_hash="$(dirname "$(command -v -- "$tool_name")" | cksum - | cut -d" " -f1)"
+echo "$isolated_root_hash"
 isolated_path="$service_runtime_dir/$isolated_root_hash"
-
+date +%s.%N
 # Check that port file exists.
 if [[ ! -f "$isolated_path/$tool_name.port" ]]; then
   [[ autorun -eq 1 ]] && "${BASH_SOURCE[0]}" start "$tool_name" &>/dev/null &
@@ -165,6 +172,8 @@
 rm "$x"
 
 
+date +%s.%N
+
 # Read stdout and stderr from connection, line by line, and echo them.
 IFS=
 while read -r -u 3 line; do

Index: tests/test_jumpthegun.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport re\nimport shutil\nimport signal\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nfrom pathlib import Path\n\nimport pytest\n\n\ndef get_bin_path(project_path: Path) -> Path:\n    return (\n        project_path.parent / \"venv\" / (\"Scripts\" if sys.platform == \"win32\" else \"bin\")\n    )\n\n\n# @pytest.fixture(scope=\"session\")\n# def setup_testproj() -> Path:\n#     with tempfile.TemporaryDirectory() as tmp_dir:\n#         proj_dir = Path(tmp_dir) / \"testproj\"\n#         shutil.copytree(Path(__file__).parent / \"testproj\", proj_dir)\n#         venv_path = proj_dir / \"venv\"\n#         subprocess.run([sys.executable, \"-mvenv\", str(venv_path)])\n#         bin_path = get_bin_path(proj_dir)\n#         subprocess.run([str(bin_path / \"pip\"), \"install\", \".\", \"black\", \"flake8\", \"isort\"], cwd=str(Path(__file__).parents[1]), check=True)\n#         yield proj_dir\n#\n#\n# @pytest.fixture\n# def testproj(setup_testproj, tmp_path) -> Path:\n#     proj_dir = Path(tmp_path) / \"testproj\"\n#     shutil.copytree(setup_testproj, proj_dir)\n#     yield proj_dir\n\n\n@pytest.fixture(scope=\"session\")\ndef testproj() -> Path:\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        proj_dir = Path(tmp_dir) / \"testproj\"\n        sources_dir = Path(__file__).parent / \"testproj\"\n        shutil.copytree(sources_dir, proj_dir)\n        venv_path = Path(tmp_dir) / \"venv\"\n        subprocess.run([sys.executable, \"-m\", \"venv\", str(venv_path)], check=True)\n        bin_path = get_bin_path(proj_dir)\n        subprocess.run(\n            [str(bin_path / \"pip\"), \"install\", \".\", \"black\", \"flake8\", \"isort\"],\n            cwd=str(Path(__file__).parents[1]),\n            check=True,\n        )\n        sleep_and_exit_on_signal_script = textwrap.dedent(\"\"\"\\\n            #!/usr/bin/env python\n            import jumpthegun.testutils\n            \n            jumpthegun.testutils.sleep_and_exit_on_signal()\n            \"\"\")\n        (bin_path / \"__test_sleep_and_exit_on_signal\").write_text(sleep_and_exit_on_signal_script)\n        yield proj_dir\n\n\n@pytest.mark.parametrize(\n    \"tool_cmd\",\n    [\n        [\"black\", \"--check\", \".\"],\n        [\"isort\", \"--check\", \".\"],\n        [\"flake8\"],\n    ],\n    ids=lambda tool_cmd: tool_cmd[0],\n)\ndef test_jumpthegun_start_run_stop(testproj, tool_cmd):\n    without_jumpthegun_proc = run(tool_cmd, proj_path=testproj)\n    assert without_jumpthegun_proc.returncode != 0\n\n    run([\"jumpthegun\", \"start\", tool_cmd[0]], proj_path=testproj, check=True)\n    try:\n        proc1 = run([\"jumpthegun\", \"run\", \"--no-autorun\", *tool_cmd], proj_path=testproj)\n        proc2 = run([\"jumpthegun\", \"run\", *tool_cmd], proj_path=testproj)\n    finally:\n        run([\"jumpthegun\", \"stop\", tool_cmd[0]], proj_path=testproj, check=True)\n\n    assert proc1.stdout == without_jumpthegun_proc.stdout\n    assert proc1.stderr == without_jumpthegun_proc.stderr\n    assert proc1.returncode == without_jumpthegun_proc.returncode\n\n    assert proc2.stdout == without_jumpthegun_proc.stdout\n    assert proc2.stderr == without_jumpthegun_proc.stderr\n    assert proc2.returncode == without_jumpthegun_proc.returncode\n\n\ndef test_jumpthegun_autorun(testproj):\n    tool_cmd = [\"flake8\"]\n\n    without_jumpthegun_proc = run(tool_cmd, proj_path=testproj)\n    assert without_jumpthegun_proc.returncode != 0\n\n    try:\n        proc1 = run([\"jumpthegun\", \"run\", \"--no-autorun\", *tool_cmd], proj_path=testproj)\n        proc2 = run([\"jumpthegun\", \"run\", *tool_cmd], proj_path=testproj)\n        proc3 = run([\"jumpthegun\", \"run\", \"--no-autorun\", *tool_cmd], proj_path=testproj)\n    finally:\n        run([\"jumpthegun\", \"stop\", tool_cmd[0]], proj_path=testproj, check=True)\n\n    assert proc1.stdout == without_jumpthegun_proc.stdout\n    assert proc1.stderr == without_jumpthegun_proc.stderr\n    assert proc1.returncode == without_jumpthegun_proc.returncode\n\n    assert proc2.stdout == without_jumpthegun_proc.stdout\n    assert proc2.stderr == without_jumpthegun_proc.stderr\n    assert proc2.returncode == without_jumpthegun_proc.returncode\n\n    assert proc3.stdout == without_jumpthegun_proc.stdout\n    assert proc3.stderr == without_jumpthegun_proc.stderr\n    assert proc3.returncode == without_jumpthegun_proc.returncode\n\n\n@pytest.mark.parametrize(\"signum\", [signal.SIGINT, signal.SIGTERM, signal.SIGUSR1, signal.SIGUSR2])\ndef test_signal_forwarding(testproj, signum):\n    subcmd = [\"__test_sleep_and_exit_on_signal\"]\n    run([\"jumpthegun\", \"start\", subcmd[0]], proj_path=testproj, check=True)\n    try:\n        proc: subprocess.Popen = run([\"jumpthegun\", \"run\", \"--no-autorun\", *subcmd], proj_path=testproj, background=True)\n        assert proc.stdout.readline() == b\"Sleeping...\\n\"\n        assert proc.poll() is None\n        proc.send_signal(signum)\n        proc.wait(2)\n        assert b\"Received signal\" in proc.stdout.read()\n    finally:\n        run([\"jumpthegun\", \"stop\", subcmd[0]], proj_path=testproj, check=True)\n\n\ndef run(cmd: list[str], proj_path: Path, background: bool = False, check: bool = False) -> subprocess.CompletedProcess[bytes] | subprocess.Popen:\n    if background and check:\n        raise ValueError(\"Must not set both background=True and check=True.\")\n\n    pass_through_env_vars = {\n        key: value\n        for key, value in os.environ.items()\n        if re.fullmatch(r\"TMPDIR|USER|XDG_.*\", key)\n    }\n\n    bin_path = get_bin_path(proj_path).resolve()\n    proc_kwargs = dict(\n        cwd=str(proj_path),\n        env={\n            **pass_through_env_vars,\n            \"PATH\": f\"{str(bin_path)}:{os.getenv('PATH', '')}\".strip(\":\"),\n            \"VIRTUAL_ENV\": str(bin_path.parent),\n        },\n        stdin=subprocess.DEVNULL,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    if background:\n        return subprocess.Popen(cmd, **proc_kwargs)\n    else:\n        try:\n            return subprocess.run(cmd, check=check, **proc_kwargs)\n        except subprocess.CalledProcessError as proc_exc:\n            if proc_exc.stdout:\n                print(\"Stdout:\")\n                print(proc_exc.stdout.decode())\n            if proc_exc.stdout:\n                print(\"Stderr:\")\n                print(proc_exc.stderr.decode())\n            raise\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/test_jumpthegun.py b/tests/test_jumpthegun.py
--- a/tests/test_jumpthegun.py	(revision d508d6011ec61548a5260dfebfa2d9630103329c)
+++ b/tests/test_jumpthegun.py	(date 1680205155914)
@@ -7,6 +7,7 @@
 import tempfile
 import textwrap
 from pathlib import Path
+from typing import List, Union
 
 import pytest
 
@@ -130,7 +131,7 @@
         run(["jumpthegun", "stop", subcmd[0]], proj_path=testproj, check=True)
 
 
-def run(cmd: list[str], proj_path: Path, background: bool = False, check: bool = False) -> subprocess.CompletedProcess[bytes] | subprocess.Popen:
+def run(cmd: List[str], proj_path: Path, background: bool = False, check: bool = False) -> Union[subprocess.CompletedProcess, subprocess.Popen]:
     if background and check:
         raise ValueError("Must not set both background=True and check=True.")
 
Index: src/jumpthegun/jumpthegunctl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\nimport io\nimport json\nimport os\nimport random\nimport shlex\nimport signal\nimport socket\nimport string\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, BinaryIO, Optional, Set, Tuple, Union, cast\n\nfrom jumpthegun.project import get_tool_names\nfrom vendor.filelock import FileLock\n\nfrom .__version__ import __version__\nfrom .tools import ToolExceptionBase, UnsupportedTool, get_tool_runner\nfrom .utils import pid_exists\n\n\nclass InvalidCommand(Exception):\n    def __init__(self, command: str):\n        super().__init__(command)\n        self.command = command\n\n\nclass DaemonAlreadyExistsError(ToolExceptionBase):\n    def __str__(self):\n        return f'Jump the Gun daemon process for tool \"{self.tool_name}\" already exists.'\n\n\nclass DaemonDoesNotExistError(ToolExceptionBase):\n    def __str__(self):\n        return f'Jump the Gun daemon process for tool \"{self.tool_name}\" does not exist.'\n\n\nclass _SocketWriter(io.RawIOBase):\n    \"\"\"TODO!\"\"\"\n\n    def __init__(self, sock: socket.socket, prefix: Union[bytes, bytearray]) -> None:\n        self._sock = sock\n        self._prefix = prefix\n\n    def readable(self) -> bool:\n        return False\n\n    def writable(self) -> bool:\n        return True\n\n    def write(self, b: Union[bytes, bytearray]) -> int:  # type: ignore[override]\n        n_newlines = b.count(10)\n        # print(b\"%b%d\\n%b\\n\" % (self._prefix, n_newlines, b), file=sys.__stderr__)\n        self._sock.sendall(b\"%b%d\\n%b\\n\" % (self._prefix, n_newlines, b))\n        # print(\"DONE WRITING\", file=sys.__stderr__)\n        with memoryview(b) as view:\n            return view.nbytes\n\n    def fileno(self) -> Any:\n        return self._sock.fileno()\n\n\nclass StdinWrapper(io.RawIOBase):\n    \"\"\"TODO!\"\"\"\n\n    def __init__(self, sock: socket.socket) -> None:\n        self._sock = sock\n        self._buf = bytearray()\n\n    def readable(self) -> bool:\n        return True\n\n    def writable(self) -> bool:\n        return False\n\n    def readline(self, size: Optional[int] = -1) -> bytes:\n        # print(f\"readline({size=})\", file=sys.__stdout__)\n        if size is None:\n            size = -1\n        self._sock.sendall(b\"3\\n\")\n        buf = self._buf\n        while size:\n            chunk = self._sock.recv(size if size != -1 else 4096)\n            # print(f\"CHUNK {chunk}\", file=sys.__stdout__)\n            if not chunk:\n                self._buf = bytearray()\n                break\n            idx = chunk.find(10)  # ord(\"\\n\") == 10\n            if idx >= 0:\n                size = idx + 1\n            if len(chunk) >= size:\n                buf.extend(chunk[:size])\n                self._buf = bytearray(chunk[size:])\n                break\n            buf.extend(chunk)\n            size = size - len(chunk) if size != -1 else -1\n\n        return buf\n\n    read = readline\n\n    def fileno(self) -> Any:\n        return self._sock.fileno()\n\n\ndef get_xdg_config_dir() -> Path:\n    env_var = os.environ.get('XDG_CONFIG_HOME')\n    if env_var:\n        return Path(env_var)\n    return Path.home() / '.config'\n\n\n@dataclass(frozen=True)\nclass JumpTheGunConfig:\n    idle_timeout_seconds: Optional[int] = 4 * 60 * 60  # 4 hours\n\n    def __post_init__(self):\n        if self.idle_timeout_seconds is None:\n            pass\n        elif isinstance(self.idle_timeout_seconds, int):\n            if self.idle_timeout_seconds <= 0:\n                raise ValueError(\"idle_timeout_seconds must be positive.\")\n        else:\n            raise TypeError(\"idle_timeout_seconds must be an int or None.\")\n\n\ndef read_config() -> JumpTheGunConfig:\n    config_dir = get_xdg_config_dir()\n    if not config_dir.exists():\n        return JumpTheGunConfig()\n    config_file = config_dir / \"jumpthegun.json\"\n    if not config_file.exists():\n        return JumpTheGunConfig()\n    with config_file.open(encoding=\"utf-8\") as f:\n        config_data = json.load(f)\n    config = JumpTheGunConfig(**config_data)\n    return config\n\n\ndef get_service_runtime_dir_path() -> Path:\n    runtime_dir = os.getenv(\"XDG_RUNTIME_DIR\")\n    if runtime_dir:\n        service_runtime_dir = Path(runtime_dir) / \"jumpthegun\"\n        service_runtime_dir.mkdir(exist_ok=True, mode=0o700)\n        return service_runtime_dir\n\n    temp_dir_path = Path(tempfile.gettempdir())\n    service_runtime_dirs = list(\n        temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n    )\n    if service_runtime_dirs:\n        if len(service_runtime_dirs) > 1:\n            raise Exception(\"Error: Multiple service runtime dirs found.\")\n        return service_runtime_dirs[0]\n\n    lock = FileLock(temp_dir_path / f\"jumpthegun-{os.getenv('USER')}.lock\")\n    with lock:\n        service_runtime_dirs = list(\n            temp_dir_path.glob(f\"jumpthegun-{os.getenv('USER')}-??????\")\n        )\n        if service_runtime_dirs:\n            return service_runtime_dirs[0]\n\n        random_part = \"\".join([random.choice(string.ascii_letters) for _i in range(6)])\n        service_runtime_dir = (\n            temp_dir_path / f\"jumpthegun-{os.getenv('USER')}-{random_part}\"\n        )\n        service_runtime_dir.mkdir(exist_ok=False, mode=0o700)\n        return service_runtime_dir\n\n\ndef get_isolated_service_runtime_dir_path(tool_name) -> Path:\n    service_runtime_dir = get_service_runtime_dir_path()\n\n    tool_executable_path: bytes = subprocess.run(\n        f\"command -v {shlex.quote(tool_name)}\",\n        shell=True,\n        check=True,\n        capture_output=True,\n    ).stdout.strip()\n    tool_executable_dir_path: bytes = os.path.dirname(tool_executable_path)\n    isolation_hash: str = hashlib.sha256(tool_executable_dir_path).hexdigest()[:8]\n    isolated_path: Path = service_runtime_dir / isolation_hash\n\n    isolated_path.mkdir(exist_ok=True, mode=0o700)\n    return isolated_path\n\n\ndef get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:\n    service_runtime_dir_path = get_isolated_service_runtime_dir_path(tool_name)\n    pid_file_path = service_runtime_dir_path / f\"{tool_name}.pid\"\n    port_file_path = service_runtime_dir_path / f\"{tool_name}.port\"\n    return pid_file_path, port_file_path\n\n\ndef remove_pid_and_port_files(tool_name: str) -> None:\n    for file_path in get_pid_and_port_file_paths(tool_name):\n        if file_path.exists():\n            try:\n                file_path.unlink()\n            except Exception:\n                pass\n\n\ndef daemon_teardown(\n    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path\n) -> None:\n    \"\"\"Close socket and remove pid and port files upon daemon shutdown.\"\"\"\n    sock.close()\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if file_pid == pid:\n            pid_file_path.unlink(missing_ok=True)\n            port_file_path.unlink(missing_ok=True)\n\n\ndef start(tool_name: str, daemonize: bool = True) -> None:\n    config = read_config()\n\n    tool_runner = get_tool_runner(tool_name)\n\n    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)\n\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if pid_exists(file_pid):\n            raise DaemonAlreadyExistsError(tool_name=tool_name)\n\n    if daemonize:\n        # Do the double-fork dance to daemonize.\n        # See:\n        # * https://stackoverflow.com/a/5386753\n        # * https://www.win.tue.nl/~aeb/linux/lk/lk-10.html\n\n        pid = os.fork()\n        if pid > 0:\n            print(f'\"jumpthegun {tool_name}\" daemon process starting...')\n            return\n\n        os.setsid()\n\n        pid = os.fork()\n        if pid > 0:\n            sys.exit(0)\n\n        # redirect standard file descriptors\n        sys.stdout.flush()\n        sys.stderr.flush()\n        stdin = open(\"/dev/null\", \"rb\")\n        stdout = open(\"/dev/null\", \"ab\")\n        stderr = open(\"/dev/null\", \"ab\")\n        os.dup2(stdin.fileno(), sys.stdin.fileno())\n        os.dup2(stdout.fileno(), sys.stdout.fileno())\n        os.dup2(stderr.fileno(), sys.stderr.fileno())\n\n    # Write pid file.\n    pid = os.getpid()\n    pid_file_path.write_bytes(b\"%d\\n\" % pid)\n\n    # Open socket.\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"127.0.0.1\", 0))\n\n    # Write port file.\n    host, port = sock.getsockname()\n    port_file_path.write_bytes(b\"%d\\n\" % port)\n\n    # Listen for connections.\n    sock.listen()\n    print(f\"Listening on {host}:{port} (pid={pid}) ...\")\n    sock.settimeout(config.idle_timeout_seconds)\n    subproc_pids = set()\n    try:\n        while True:\n            conn, address = sock.accept()\n            print(f\"Got connection from: {address}\")\n            newpid = os.fork()\n            if newpid == 0:\n                break\n\n            # Avoid \"zombie\" processes: Reap completed sub-processes.\n            done_subproc_pids = {x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0}\n            print(f\"{done_subproc_pids=}\")\n            subproc_pids -= done_subproc_pids\n            subproc_pids.add(newpid)\n    except BaseException as exc:\n        # Server is exiting: Clean up as needed.\n        sock.close()\n        if pid_file_path.exists():\n            file_pid = int(pid_file_path.read_text())\n            if file_pid == pid:\n                pid_file_path.unlink(missing_ok=True)\n                port_file_path.unlink(missing_ok=True)\n        if isinstance(exc, socket.timeout):\n            print(f\"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds.\")\n            return\n        raise\n\n    # Send pid.\n    conn.sendall(b\"%d\\n\" % os.getpid())\n\n    rfile = conn.makefile(\"rb\", 0)\n    sys.argv[1:] = shlex.split(rfile.readline().strip().decode())\n    sys.argv[0] = tool_name\n\n    sys.stdin.close()\n    sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))\n    sys.stdout = io.TextIOWrapper(\n        cast(BinaryIO, _SocketWriter(conn, b\"1\")), write_through=True\n    )\n    sys.stderr = io.TextIOWrapper(\n        cast(BinaryIO, _SocketWriter(conn, b\"2\")), write_through=True\n    )\n\n    # start_time = time.monotonic()\n    try:\n        retval = tool_runner()\n    except BaseException as exc:\n        # end_time = time.monotonic()\n        # print(f\"Time: {end_time - start_time}\", file=sys.__stdout__)\n        # print(\"EXCEPTION\", str(exc), file=sys.__stderr__)\n        if isinstance(exc, SystemExit):\n            exit_code = exc.code\n        else:\n            traceback.print_exc()\n            exit_code = 1\n        # print(f\"{exit_code=}\", file=sys.__stdout__)\n        if isinstance(exit_code, bool):\n            exit_code = int(exit_code)\n        elif not isinstance(exit_code, int):\n            exit_code = 1\n    else:\n        if isinstance(retval, int):\n            exit_code = retval\n        else:\n            exit_code = 0\n    finally:\n        conn.sendall(b\"rc=%d\\n\" % exit_code)\n        # print(f\"Goodbye! rc={exit_code}\", file=sys.__stdout__)\n\n        sys.stdin.close()\n        sys.stdout.close()\n        sys.stderr.close()\n        conn.shutdown(socket.SHUT_WR)\n        sys.exit(0)\n\n\ndef stop(tool_name: str) -> None:\n    try:\n        get_tool_runner(tool_name)\n    except UnsupportedTool:\n        raise DaemonDoesNotExistError(tool_name)\n\n    try:\n        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)\n        if not pid_file_path.exists():\n            raise DaemonDoesNotExistError(tool_name)\n\n        file_pid = int(pid_file_path.read_text())\n        if not pid_exists(file_pid):\n            raise DaemonDoesNotExistError(tool_name)\n\n        os.kill(file_pid, signal.SIGTERM)\n        for _i in range(20):\n            time.sleep(0.05)\n            if not pid_exists(file_pid):\n                break\n        else:\n            os.kill(file_pid, signal.SIGKILL)\n\n        print(f'\"jumpthegun {tool_name}\" daemon process stopped.')\n\n    finally:\n        remove_pid_and_port_files(tool_name)\n\n\ndef print_usage() -> None:\n    \"\"\"Print a message about how to run jumpthegunctl.\"\"\"\n    print(f\"Usage: {sys.argv[0]} start|stop tool_name\")\n\n\ndef do_action(tool_name: str, action: str) -> None:\n    \"\"\"Apply an action (e.g. start or stop) for a given tool.\"\"\"\n    if action == \"start\":\n        start(tool_name)\n    elif action == \"stop\":\n        stop(tool_name)\n    elif action == \"restart\":\n        try:\n            stop(tool_name)\n        except DaemonDoesNotExistError:\n            pass\n        start(tool_name)\n    else:\n        raise InvalidCommand(action)\n\n\ndef main() -> None:\n    args = sys.argv[1:]\n\n    if any(arg == \"-h\" or arg == \"--help\" for arg in args):\n        print_usage()\n        sys.exit(0)\n\n    if len(args) == 1:\n        (cmd,) = args\n        if cmd == \"version\" or cmd == \"--version\":\n            print(f\"jumpthegun v{__version__}\")\n            sys.exit(0)\n    elif len(args) == 2:\n        (cmd, tool_name) = args\n        tool_name = tool_name.strip().lower()\n\n        if tool_name == \"all\":\n            tool_names = get_tool_names(Path.cwd())\n            failed_for_tools: Set[str] = set()\n            for _tool_name in tool_names:\n                try:\n                    do_action(tool_name=_tool_name, action=cmd)\n                except ToolExceptionBase:\n                    failed_for_tools.add(_tool_name)\n\n            succeeded_for_tools = set(tool_names) - failed_for_tools\n            if cmd == \"restart\":\n                if succeeded_for_tools:\n                    print(\n                        \"Restarted jumpthegun daemons for tools:\",\n                        \", \".join(sorted(succeeded_for_tools)),\n                    )\n                    sys.exit(0)\n                if failed_for_tools:\n                    print(\n                        \"Failed to restart jumpthegun daemons for tools:\",\n                        \", \".join(sorted(failed_for_tools)),\n                    )\n                    sys.exit(1)\n            elif cmd == \"start\" or cmd == \"stop\":\n                if succeeded_for_tools:\n                    action_str = \"Stopped\" if cmd == \"stop\" else \"Started\"\n                    print(\n                        f\"{action_str} jumpthegun daemons for tools:\",\n                        \", \".join(sorted(succeeded_for_tools)),\n                    )\n                    sys.exit(0)\n                else:\n                    print(f\"No tools to {cmd} jumpthegun daemons for.\")\n                    sys.exit(0)\n        else:\n            try:\n                do_action(tool_name=tool_name, action=cmd)\n            except ToolExceptionBase as exc:\n                print(str(exc))\n                sys.exit(1)\n            except InvalidCommand as exc:\n                print(str(exc))\n            else:\n                sys.exit(0)\n\n    print_usage()\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpthegunctl.py b/src/jumpthegun/jumpthegunctl.py
--- a/src/jumpthegun/jumpthegunctl.py	(revision d508d6011ec61548a5260dfebfa2d9630103329c)
+++ b/src/jumpthegun/jumpthegunctl.py	(date 1680206416482)
@@ -285,7 +285,6 @@
 
             # Avoid "zombie" processes: Reap completed sub-processes.
             done_subproc_pids = {x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0}
-            print(f"{done_subproc_pids=}")
             subproc_pids -= done_subproc_pids
             subproc_pids.add(newpid)
     except BaseException as exc:
Index: src/jumpthegun/testutils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import signal\nimport sys\nimport time\n\n\ndef sleep_and_exit_on_signal():\n    def signal_handler(signum, frame):\n        print(f\"Received signal: {signum} ({signal.strsignal(signum)})\", flush=True)\n        sys.exit()\n\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    signal.signal(signal.SIGUSR1, signal_handler)\n    signal.signal(signal.SIGUSR2, signal_handler)\n\n    print(\"Sleeping...\", flush=True)\n    time.sleep(60.0)\n    print(\"Done.\", flush=True)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/testutils.py b/src/jumpthegun/testutils.py
--- a/src/jumpthegun/testutils.py	(revision d508d6011ec61548a5260dfebfa2d9630103329c)
+++ b/src/jumpthegun/testutils.py	(date 1680207420907)
@@ -5,7 +5,7 @@
 
 def sleep_and_exit_on_signal():
     def signal_handler(signum, frame):
-        print(f"Received signal: {signum} ({signal.strsignal(signum)})", flush=True)
+        print(f"Received signal: {signum}", flush=True)
         sys.exit()
 
     signal.signal(signal.SIGINT, signal_handler)

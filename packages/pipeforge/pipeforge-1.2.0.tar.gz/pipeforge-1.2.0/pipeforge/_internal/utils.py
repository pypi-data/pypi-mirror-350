# vim: colorcolumn=101 textwidth=100

import json
import datetime


####################################################################################################
# Internal globals
####################################################################################################

_channel           = "SHY"
_print_callback    = None
_include_timestamp = False



####################################################################################################
# API
####################################################################################################

def log_configure(channel, print_callback=lambda x: print(x, flush=True), include_timestamp=True):
    """
    Configure how and where messages generated by the pipeforge module will be displayed.
    Set the "channel" a call to "log()" must belong to in order for it not to be ignored.

    @param channel: Only messages that belong to this "channel" will be considered. Must be one of
        "DEBUG", "NORMAL", "SHY".
        You can enable several channels by using a "+". Example: "DEBUG+NORMAL"

    @param print_callback: Function to call every time a new message from the configured channel
        needs to be printed. If not specified, "print()" will be used.

    @param include_timestamp: If set to True, each message will contain a timestamp prefix
    """

    global _channel
    global _print_callback
    global _include_timestamp

    _channel           = channel
    _print_callback    = print_callback
    _include_timestamp = include_timestamp


def log(channel, x):
    """
    Send message to the log system if "channel" matches the currently globally configured one (which
    is set with "log_configure")

    In addition, it also accepts lists and dictionaries and will print them "line by line" (meaning
    each line will have the "logging" header).

    @param channel: Must be one of "DEBUG", "NORMAL", "SHY".
        It can also be "ERROR". In that case the message will not be filtered and always printed to
        stdout.
        You can enable send one message to multiple channels using a "+". Example: "DEBUG+NORMAL"

    @param x: Can be a string or a structure (list or dictionary). In the latter case it will be
        printed "line-by-line" (ie. N calls to the configured "print_callback" function)
    """

    global _channel
    global _print_callback
    global _include_timestamp

    channel = channel.split("+")

    if _channel not in channel and "ERROR" not in channel:
        return

    if _print_callback is None:
        if "ERROR" in channel:
            _print_callback = print
        else:
            return

    if _include_timestamp:
        prefix = str(datetime.datetime.now().strftime("%y-%m-%dT%H:%M:%S.%f")[:-4])+": "
    else:
        prefix = ""

    if "ERROR" in channel:
        prefix += "ERROR: "

    if isinstance(x, str):
        _print_callback(prefix + x)

    else:
        for line in json.dumps(x, indent=4).split('\n'):
            _print_callback(prefix + line)


def topological_sort(graph):
    """
    Return a list containing the nodes in @param graph sorted in topological order.

    @param graph: a dictionary where each key is the name of a node and each value is a list of
    names of other nodes the current one depends on. Example:

        graph = { "A" : [],
                  "B" : ["A"],
                  "C" : ["A", "B"],
                  "D" : ["C"]
                }
    """

    def aux(node, visited, stack, graph):
        visited[node] = True
        for neighbor in graph[node]:
            if not visited[neighbor]:
                aux(neighbor, visited, stack, graph)
        stack.append(node)

    visited = {node: False for node in graph}
    stack   = []

    for node in graph:
        if not visited[node]:
            aux(node, visited, stack, graph)

    return stack


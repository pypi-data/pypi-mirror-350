import numpy as np
from _typeshed import Incomplete
from dataclasses import dataclass
from enum import Enum
from numpy.typing import NDArray

__all__ = ['Magnitude', 'AngularFrequency', 'Wavelength', 'spectral_window', 'SellmeierCoefficientsSimple', 'SellmeierCoefficientsTemperatureDependent', 'SellmeierCoefficientsJundt', '_permittivity', '_n_0', '_n_i', 'Orientation', 'PhaseMatchingCondition', 'Photon', 'Crystal', 'calculate_grating_period', 'delta_k_matrix', 'phase_matching_function', 'phase_mismatch', 'joint_spectral_amplitude', 'PhotonType', 'calculate_marginal_spectrum', 'calculate_jsa_marginals', 'bandwidth_conversion', 'Time', 'Bunching', 'hom_interference_from_jsa', 'hong_ou_mandel_interference', 'spectral_purity', 'sibling_wavelength', 'wavelength_temperature_tuning']

class Magnitude(Enum):
    pico = -12
    nano = -9
    micro = -6
    milli = -3
    base = 0
    kilo = 3
    mega = 6
    giga = 9

@dataclass
class AngularFrequency:
    value: float | np.ndarray

@dataclass
class Wavelength:
    value: float | np.ndarray
    unit: Magnitude = ...
    def to_unit(self, new_unit: Magnitude) -> Wavelength: ...
    def to_absolute(self) -> Wavelength: ...
    def as_angular_frequency(self) -> AngularFrequency: ...
    def as_wavevector(self, refractive_index: float = 1.0) -> float | NDArray[np.floating]: ...
    def downconversion_result(self, downconversion: Wavelength) -> Wavelength: ...

def spectral_window(central_wavelength: Wavelength, spectral_width: Wavelength, steps: int, reverse: bool = False) -> Wavelength: ...

@dataclass(frozen=True)
class SellmeierCoefficientsSimple:
    coefficients: list[float] | NDArray[np.floating]
    temperature: float
    dn_dt: float | None = ...
    def refractive_index(self, wavelength: Wavelength, temperature: float | None = None): ...

@dataclass(frozen=True)
class SellmeierCoefficientsTemperatureDependent:
    first_order: list[float] | NDArray | None
    second_order: list[float] | NDArray | None
    temperature: float
    zeroth_order: list[float] | NDArray | None = ...
    def refractive_index(self, wavelength: Wavelength, temperature: float | None = None): ...

@dataclass(frozen=True)
class SellmeierCoefficientsJundt:
    a_terms: list[float] | NDArray[np.floating]
    b_terms: list[float] | NDArray[np.floating]
    temperature: float
    def __post_init__(self) -> None: ...
    def refractive_index(self, wavelength: Wavelength, temperature: float | None = None): ...

@dataclass(frozen=True)
class SellmeierCoefficientsBornAndWolf:
    coefficients: list[float] | NDArray[np.floating]
    temperature: float
    def __post_init__(self) -> None: ...
    def refractive_index(self, wavelength: Wavelength, temperature: float | None = None): ...

def _permittivity(sellmeier: list[float] | NDArray, wavelength_um: float | NDArray[np.floating]) -> float | NDArray[np.floating]: ...
def _n_0(sellmeier: list[float] | NDArray, wavelength_um: float | NDArray[np.floating]) -> float | NDArray[np.floating]: ...
def _n_i(sellmeier: list[float] | NDArray[np.floating], wavelength_um: float | NDArray[np.floating]) -> float | NDArray[np.floating]: ...

class Orientation(Enum):
    ordinary = 0
    extraordinary = 1

class PhaseMatchingCondition(Enum):
    type0_o = ...
    type0_e = ...
    type1 = ...
    type2_o = ...
    type2_e = ...

class Photon(Enum):
    pump = 0
    signal = 1
    idler = 2

class Crystal:
    name: Incomplete
    sellmeier_o: Incomplete
    sellmeier_e: Incomplete
    doi: Incomplete
    def __init__(self, name: str, sellmeier_o: SellmeierCoefficientsSimple | SellmeierCoefficientsTemperatureDependent | SellmeierCoefficientsJundt | SellmeierCoefficientsBornAndWolf, sellmeier_e: SellmeierCoefficientsSimple | SellmeierCoefficientsTemperatureDependent | SellmeierCoefficientsJundt | SellmeierCoefficientsBornAndWolf, phase_matching: PhaseMatchingCondition, doi: str = None) -> None: ...
    @property
    def phase_matching(self) -> PhaseMatchingCondition: ...
    @phase_matching.setter
    def phase_matching(self, condition: PhaseMatchingCondition): ...
    def refractive_index(self, wavelength: Wavelength, photon: Photon, temperature: float | None = None) -> float | NDArray[np.floating]: ...
    def refractive_indices(self, pump_wavelength: Wavelength, signal_wavelength: Wavelength, idler_wavelength: Wavelength, temperature: float | None = None) -> tuple[float | NDArray[np.floating], float | NDArray[np.floating], float | NDArray[np.floating]]: ...

def calculate_grating_period(lambda_p_central: Wavelength, lambda_s_central: Wavelength, lambda_i_central: Wavelength, crystal: Crystal, temperature: float = None) -> float | NDArray[np.floating]: ...
def delta_k_matrix(lambda_p: Wavelength, lambda_s: Wavelength, lambda_i: Wavelength, crystal: Crystal, temperature: float = None) -> float | NDArray[np.floating]: ...
def phase_mismatch(lambda_p: Wavelength, lambda_s: Wavelength, crystal: Crystal, temperature: float, grating_period: float): ...
def phase_matching_function(delta_k: np.ndarray, grating_period, crystal_length) -> np.ndarray: ...
def joint_spectral_amplitude(phase_mismatch_matrix: np.ndarray, pump_envelope_matrix: np.ndarray, normalisation: bool = True) -> np.ndarray: ...

class PhotonType(Enum):
    IDLER = 0
    SIGNAL = 1

def calculate_marginal_spectrum(jsa_matrix: np.ndarray, lambda_s: Wavelength, lambda_i: Wavelength, photon_type: PhotonType) -> tuple[np.ndarray, np.ndarray]: ...
def calculate_jsa_marginals(jsa_matrix: np.ndarray, lambda_s: Wavelength, lambda_i: Wavelength) -> dict: ...
def bandwidth_conversion(delta_lambda_FWHM: Wavelength, pump_wl: Wavelength) -> float: ...

@dataclass
class Time:
    value: float | np.ndarray
    unit: Magnitude = ...
    def count(self) -> int: ...
    def as_array(self) -> NDArray[np.floating]: ...
    def to_unit(self, new_unit: Magnitude) -> Time: ...
    def to_absolute(self) -> Time: ...

class Bunching(Enum):
    Bunching = -1
    AntiBunching = 1

def hom_interference_from_jsa(joint_spectral_amplitude: np.ndarray, wavelengths_signal: Wavelength, wavelengths_idler: Wavelength, time_delay: Time = ..., bunching: Bunching = ...) -> tuple[float, np.ndarray]: ...
def hong_ou_mandel_interference(jsa: np.ndarray, signal_wavelengths: np.ndarray, idler_wavelengths: np.ndarray, time_delays: Time = ..., bunching: Bunching = ...) -> np.ndarray: ...
def spectral_purity(jsa: np.ndarray) -> tuple[float, float, float]: ...
def sibling_wavelength(pump: Wavelength, target: Wavelength) -> Wavelength: ...
def wavelength_temperature_tuning(wavelength_pump: Wavelength, wavelength_target: Wavelength, poling_period: float, crystal: Crystal, temp_range: tuple, num_points: int = 50, crystal_length: float = 0.01) -> tuple: ...

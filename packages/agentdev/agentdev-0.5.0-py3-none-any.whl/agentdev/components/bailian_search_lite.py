# -*- coding: utf-8 -*-
import json
import os
import uuid
from typing import Any, Dict, List, Optional, Tuple

import requests
from pydantic import BaseModel, Field

from agentdev.base.component import Component
from agentdev.components.bailian_search import (
    SEARCH_PAGE,
    SEARCH_STRATEGY_SETTING,
    SEARCH_TIMEOUT,
    FieldValidator,
)
from agentdev.tracing import TraceType
from agentdev.tracing.wrapper import trace

SEARCH_URL = os.getenv(
    "SEARCH_URL",
    "https://dashscope.aliyuncs.com/api/v1/indices/plugin/mcp_search",
)
SEARCH_STRATEGY = os.getenv("SEARCH_STRATEGY", "pro_max")
DASHSCOPE_API_KEY = os.getenv("DASHSCOPE_API_KEY", None)
SEARCH_RULES = {
    "url": {
        "DROPOUT_ENTIRE_IF_MISSING": "DROPOUT_ENTIRE_IF_MISSING",
        "FILTER_ITEMS_FROM_LIST": [
            "uclink://www.uc.cn",
            "qklink://www.quark.cn",
            "https://page.sm.cn",
        ],
    },
    "title": "DROPOUT_ENTIRE_IF_MISSING",
}


class SearchLiteInput(BaseModel):
    """
    Search Input.
    """

    query: str = Field(..., description="user query in the format of string")
    count: int = Field(default=5, description="number of search results")


class SearchLiteOutput(BaseModel):
    """
    Search Output.
    """

    status: int = Field(
        ...,
        description="status code for success or failed, 0 is success",
    )
    pages: List[Dict[str, Any]] = Field(
        ...,
        description="Search results with url, title, etc,.",
    )
    tools: List[Dict[str, Any]] = Field(
        ...,
        description="The tool calling result during search",
    )
    request_id: Optional[str] = Field(
        default=None,
        title="Request ID",
        description="请求ID",
    )


class BailianSearchLite(Component[SearchLiteInput, SearchLiteOutput]):
    """
    Search Component that calling dashscope for llm search result.
    """

    description = "搜索可用于查询百科知识、时事新闻、天气等信息"
    name = "bailian_web_search"

    @trace(TraceType.SEARCH)
    async def _arun(
        self,
        args: SearchLiteInput,
        **kwargs: Any,
    ) -> SearchLiteOutput:
        """
        Run the search component with SearchLiteInput and return
        SearchLiteOutput.
        Args:
            args: in SearchLiteInput format that generated by from llm
            **kwargs: should include other arguments if needed,
            'trace_event' in kwargs can be used for tracing

        Returns:SearchLiteOutput

        """
        request_id = kwargs.get("request_id", str(uuid.uuid4()))
        if DASHSCOPE_API_KEY is None:
            raise ValueError(
                "DASHSCOPE_API_KEY is required for search component, "
                "please get your dashscope api-key on Bailian platform",
            )
        trace_event = kwargs.pop("trace_event", None)

        # call search engine to get search result
        payload = BailianSearchLite.generate_search_payload(
            search_input=args,
            request_id=request_id,
        )
        header = {
            "Content-Type": "application/json",
            "Accept-Encoding": "utf-8",
            "Authorization": "Bearer " + DASHSCOPE_API_KEY,
        }
        kwargs["context"] = {
            "payload": payload,
            "search_strategy": SEARCH_STRATEGY,
            "timeout": SEARCH_TIMEOUT,
        }
        try:
            search_result, extra_tool_info, status, result_message = (
                BailianSearchLite.dashscope_search_kernel(
                    url=SEARCH_URL,
                    payload=payload,
                    headers=header,
                    timeout=SEARCH_TIMEOUT,
                )
            )
            if trace_event:
                trace_event.on_log(
                    "",
                    **{
                        "step_suffix": "results",
                        "payload": {
                            "request_id": request_id,
                            "search_status": status,
                            "search_query_result": result_message,
                            "search_result": search_result,
                            "extra_tool_info": extra_tool_info,
                        },
                    },
                )

        except Exception as e:
            print(f"Error: {e}")
            return SearchLiteOutput(
                status=1,
                pages=[],
                tools=[],
                request_id=request_id,
            )

        # post process search results
        search_items, tool_items = (
            BailianSearchLite.post_process_search_detail(
                search_results=search_result,
                extra_tool_info=extra_tool_info,
            )
        )

        return SearchLiteOutput(
            status=0,
            pages=search_items,
            tools=tool_items,
            request_id=request_id,
        )

    @staticmethod
    def generate_search_payload(
        search_input: SearchLiteInput,
        request_id: str,
        **kwargs: Any,
    ) -> str:
        search_strategy = SEARCH_STRATEGY

        payload = {
            "scene": SEARCH_STRATEGY_SETTING[search_strategy]["scene"],
            "uq": search_input.query,
            "rid": request_id,
            "fields": [],
            "page": int(SEARCH_PAGE),
            "rows": search_input.count,
            "headers": {
                "__d_head_qto": SEARCH_STRATEGY_SETTING[search_strategy][
                    "timeout"
                ],
            },
        }
        result = json.dumps(payload)
        return result

    @staticmethod
    def dashscope_search_kernel(
        url: str,
        payload: str,
        headers: Dict,
        timeout: int,
        **kwargs: Any,
    ) -> Tuple[List, List, int, str]:

        extra_tool_info = []
        results_list = []
        results = {}
        try:
            r = requests.request(
                "post",
                url,
                headers=headers,
                data=payload,
                timeout=timeout,
            )
            results = r.json()
            result_message = results["message"]
            if results["status"] == 0:
                extra_tool_info = results["data"]["extras"].get(
                    "toolResult",
                    [],
                )
                results_list = results["data"]["docs"]
        except Exception as e:
            print(f"Error: {e}")
            raise RuntimeError(
                f"Unable to reach search source with error: {e} and result: "
                f"{results}",
            )

        return results_list, extra_tool_info, results["status"], result_message

    @staticmethod
    def post_process_search_detail(
        search_results: List,
        extra_tool_info: List,
        **kwargs: Any,
    ) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
        field_validator = FieldValidator(SEARCH_RULES)
        search_items = []
        tool_items = []

        try:
            for doc in search_results:
                tmp_search_result = {
                    "url": doc.get("url", "") or "",
                    "title": doc.get("title", "") or "",
                    "icon": doc.get("hostlogo", "") or "",
                    "site_name": doc.get("hostname", "") or "",
                    "image": doc.get("image", "") or "",
                }
                filtered_search_result = field_validator.validate(
                    tmp_search_result,
                )
                if filtered_search_result:
                    url = doc.get("url")
                    url = url.replace(" ", "%20").strip() or "expired_url"
                    url = url.replace(
                        "chatm6.sm.cn",
                        "quark.sm.cn",
                    )  # noqa E501
                    search_items.append(
                        {
                            "snippet": doc.get("snippet", ""),
                            "title": doc.get("title", ""),
                            "url": url,
                            "hostname": doc.get("hostname", ""),
                            "hostlogo": doc.get("hostlogo", ""),
                        },
                    )
            for item in extra_tool_info:
                if item.get("tool"):
                    tool_items.append(
                        {
                            "tool": item.get("tool"),
                            "result": item.get("result", ""),
                        },
                    )
        except Exception as e:
            print(f"Error: {e}")
            return [], []

        return search_items, tool_items


if __name__ == "__main__":

    import asyncio

    input_data = SearchLiteInput(query="魅族最新Flyme介绍", count=5)
    search_component = BailianSearchLite()

    async def main() -> None:
        image_gent_output = await search_component.arun(input_data)
        print(image_gent_output)

    asyncio.run(main())

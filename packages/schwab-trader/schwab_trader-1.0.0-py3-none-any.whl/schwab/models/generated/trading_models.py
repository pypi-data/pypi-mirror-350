# generated by datamodel-codegen:
#   filename:  trading.yaml

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Literal, Optional, Union, Any, Dict
import logging

from pydantic import BaseModel, Field, RootModel

logger = logging.getLogger(__name__)
# Allow model initialization using field names as well as aliases
BaseModel.model_config = {**BaseModel.model_config, 'populate_by_name': True}


class AccountNumberHash(BaseModel):
    account_number: Optional[str] = Field(None, alias='accountNumber')
    hash_value: Optional[str] = Field(None, alias='hashValue')


class Session(Enum):
    normal = 'NORMAL'
    am = 'AM'
    pm = 'PM'
    seamless = 'SEAMLESS'
    # Alias uppercase members for compatibility
    NORMAL = normal
    AM = am
    PM = pm
    SEAMLESS = seamless


class Duration(Enum):
    day = 'DAY'
    good_till_cancel = 'GOOD_TILL_CANCEL'
    fill_or_kill = 'FILL_OR_KILL'
    immediate_or_cancel = 'IMMEDIATE_OR_CANCEL'
    end_of_week = 'END_OF_WEEK'
    end_of_month = 'END_OF_MONTH'
    next_end_of_month = 'NEXT_END_OF_MONTH'
    unknown = 'UNKNOWN'
    # Alias uppercase members for compatibility
    DAY = day
    GOOD_TILL_CANCEL = good_till_cancel
    FILL_OR_KILL = fill_or_kill
    IMMEDIATE_OR_CANCEL = immediate_or_cancel
    END_OF_WEEK = end_of_week
    END_OF_MONTH = end_of_month
    NEXT_END_OF_MONTH = next_end_of_month
    UNKNOWN = unknown


class OrderType(Enum):
    market = 'MARKET'
    limit = 'LIMIT'
    stop = 'STOP'
    stop_limit = 'STOP_LIMIT'
    trailing_stop = 'TRAILING_STOP'
    cabinet = 'CABINET'
    non_marketable = 'NON_MARKETABLE'
    market_on_close = 'MARKET_ON_CLOSE'
    exercise = 'EXERCISE'
    trailing_stop_limit = 'TRAILING_STOP_LIMIT'
    net_debit = 'NET_DEBIT'
    net_credit = 'NET_CREDIT'
    net_zero = 'NET_ZERO'
    limit_on_close = 'LIMIT_ON_CLOSE'
    unknown = 'UNKNOWN'
    # Alias uppercase members for compatibility
    MARKET = market
    LIMIT = limit
    STOP = stop
    STOP_LIMIT = stop_limit
    TRAILING_STOP = trailing_stop
    CABINET = cabinet
    NON_MARKETABLE = non_marketable
    MARKET_ON_CLOSE = market_on_close
    EXERCISE = exercise
    TRAILING_STOP_LIMIT = trailing_stop_limit
    NET_DEBIT = net_debit
    NET_CREDIT = net_credit
    NET_ZERO = net_zero
    LIMIT_ON_CLOSE = limit_on_close
    UNKNOWN = unknown


class OrderTypeRequest(Enum):
    """
    Same as orderType, but does not have UNKNOWN since this type is not allowed as an input
    """

    market = 'MARKET'
    limit = 'LIMIT'
    stop = 'STOP'
    stop_limit = 'STOP_LIMIT'
    trailing_stop = 'TRAILING_STOP'
    cabinet = 'CABINET'
    non_marketable = 'NON_MARKETABLE'
    market_on_close = 'MARKET_ON_CLOSE'
    exercise = 'EXERCISE'
    trailing_stop_limit = 'TRAILING_STOP_LIMIT'
    net_debit = 'NET_DEBIT'
    net_credit = 'NET_CREDIT'
    net_zero = 'NET_ZERO'
    limit_on_close = 'LIMIT_ON_CLOSE'


class ComplexOrderStrategyType(Enum):
    none = 'NONE'
    covered = 'COVERED'
    vertical = 'VERTICAL'
    back_ratio = 'BACK_RATIO'
    calendar = 'CALENDAR'
    diagonal = 'DIAGONAL'
    straddle = 'STRADDLE'
    strangle = 'STRANGLE'
    collar_synthetic = 'COLLAR_SYNTHETIC'
    butterfly = 'BUTTERFLY'
    condor = 'CONDOR'
    iron_condor = 'IRON_CONDOR'
    vertical_roll = 'VERTICAL_ROLL'
    collar_with_stock = 'COLLAR_WITH_STOCK'
    double_diagonal = 'DOUBLE_DIAGONAL'
    unbalanced_butterfly = 'UNBALANCED_BUTTERFLY'
    unbalanced_condor = 'UNBALANCED_CONDOR'
    unbalanced_iron_condor = 'UNBALANCED_IRON_CONDOR'
    unbalanced_vertical_roll = 'UNBALANCED_VERTICAL_ROLL'
    mutual_fund_swap = 'MUTUAL_FUND_SWAP'
    custom = 'CUSTOM'
    # Alias uppercase members for compatibility
    NONE = none
    COVERED = covered
    VERTICAL = vertical
    BACK_RATIO = back_ratio
    CALENDAR = calendar
    DIAGONAL = diagonal
    STRADDLE = straddle
    STRANGLE = strangle
    COLLAR_SYNTHETIC = collar_synthetic
    BUTTERFLY = butterfly
    CONDOR = condor
    IRON_CONDOR = iron_condor
    VERTICAL_ROLL = vertical_roll
    COLLAR_WITH_STOCK = collar_with_stock
    DOUBLE_DIAGONAL = double_diagonal
    UNBALANCED_BUTTERFLY = unbalanced_butterfly
    UNBALANCED_CONDOR = unbalanced_condor
    UNBALANCED_IRON_CONDOR = unbalanced_iron_condor
    UNBALANCED_VERTICAL_ROLL = unbalanced_vertical_roll
    MUTUAL_FUND_SWAP = mutual_fund_swap
    CUSTOM = custom


class RequestedDestination(Enum):
    inet = 'INET'
    ecn_arca = 'ECN_ARCA'
    cboe = 'CBOE'
    amex = 'AMEX'
    phlx = 'PHLX'
    ise = 'ISE'
    box = 'BOX'
    nyse = 'NYSE'
    nasdaq = 'NASDAQ'
    bats = 'BATS'
    c2 = 'C2'
    auto = 'AUTO'
    # Alias uppercase members for compatibility
    INET = inet
    ECN_ARCA = ecn_arca
    CBOE = cboe
    AMEX = amex
    PHLX = phlx
    ISE = ise
    BOX = box
    NYSE = nyse
    NASDAQ = nasdaq
    BATS = bats
    C2 = c2
    AUTO = auto


class StopPriceLinkBasis(Enum):
    manual = 'MANUAL'
    base = 'BASE'
    trigger = 'TRIGGER'
    last = 'LAST'
    bid = 'BID'
    ask = 'ASK'
    ask_bid = 'ASK_BID'
    mark = 'MARK'
    average = 'AVERAGE'
    # Alias uppercase members for compatibility
    MANUAL = manual
    BASE = base
    TRIGGER = trigger
    LAST = last
    BID = bid
    ASK = ask
    ASK_BID = ask_bid
    MARK = mark
    AVERAGE = average


class StopPriceLinkType(Enum):
    value = 'VALUE'
    percent = 'PERCENT'
    tick = 'TICK'
    # Alias uppercase members for compatibility
    VALUE = value
    PERCENT = percent
    TICK = tick


class StopPriceOffset(RootModel[float]):
    root: float


class StopType(Enum):
    standard = 'STANDARD'
    bid = 'BID'
    ask = 'ASK'
    last = 'LAST'
    mark = 'MARK'
    # Alias uppercase members for compatibility
    STANDARD = standard
    BID = bid
    ASK = ask
    LAST = last
    MARK = mark


class TaxLotMethod(Enum):
    fifo = 'FIFO'
    lifo = 'LIFO'
    high_cost = 'HIGH_COST'
    low_cost = 'LOW_COST'
    average_cost = 'AVERAGE_COST'
    specific_lot = 'SPECIFIC_LOT'
    loss_harvester = 'LOSS_HARVESTER'
    # Alias uppercase members for compatibility
    FIFO = fifo
    LIFO = lifo
    HIGH_COST = high_cost
    LOW_COST = low_cost
    AVERAGE_COST = average_cost
    SPECIFIC_LOT = specific_lot
    LOSS_HARVESTER = loss_harvester


class SpecialInstruction(Enum):
    all_or_none = 'ALL_OR_NONE'
    do_not_reduce = 'DO_NOT_REDUCE'
    all_or_none_do_not_reduce = 'ALL_OR_NONE_DO_NOT_REDUCE'
    # Alias uppercase members for compatibility
    ALL_OR_NONE = all_or_none
    DO_NOT_REDUCE = do_not_reduce
    ALL_OR_NONE_DO_NOT_REDUCE = all_or_none_do_not_reduce


class OrderStrategyType(Enum):
    single = 'SINGLE'
    cancel = 'CANCEL'
    recall = 'RECALL'
    pair = 'PAIR'
    flatten = 'FLATTEN'
    two_day_swap = 'TWO_DAY_SWAP'
    blast_all = 'BLAST_ALL'
    oco = 'OCO'
    trigger = 'TRIGGER'
    # Alias uppercase members for compatibility
    SINGLE = single
    CANCEL = cancel
    RECALL = recall
    PAIR = pair
    FLATTEN = flatten
    TWO_DAY_SWAP = two_day_swap
    BLAST_ALL = blast_all
    OCO = oco
    TRIGGER = trigger


class Status(Enum):
    awaiting_parent_order = 'AWAITING_PARENT_ORDER'
    awaiting_condition = 'AWAITING_CONDITION'
    awaiting_stop_condition = 'AWAITING_STOP_CONDITION'
    awaiting_manual_review = 'AWAITING_MANUAL_REVIEW'
    accepted = 'ACCEPTED'
    awaiting_ur_out = 'AWAITING_UR_OUT'
    pending_activation = 'PENDING_ACTIVATION'
    queued = 'QUEUED'
    working = 'WORKING'
    rejected = 'REJECTED'
    pending_cancel = 'PENDING_CANCEL'
    canceled = 'CANCELED'
    pending_replace = 'PENDING_REPLACE'
    replaced = 'REPLACED'
    filled = 'FILLED'
    expired = 'EXPIRED'
    new = 'NEW'
    awaiting_release_time = 'AWAITING_RELEASE_TIME'
    pending_acknowledgement = 'PENDING_ACKNOWLEDGEMENT'
    pending_recall = 'PENDING_RECALL'
    unknown = 'UNKNOWN'
    # Alias uppercase members for compatibility
    AWAITING_PARENT_ORDER = awaiting_parent_order
    AWAITING_CONDITION = awaiting_condition
    AWAITING_STOP_CONDITION = awaiting_stop_condition
    AWAITING_MANUAL_REVIEW = awaiting_manual_review
    ACCEPTED = accepted
    AWAITING_UR_OUT = awaiting_ur_out
    PENDING_ACTIVATION = pending_activation
    QUEUED = queued
    WORKING = working
    REJECTED = rejected
    PENDING_CANCEL = pending_cancel
    CANCELED = canceled
    PENDING_REPLACE = pending_replace
    REPLACED = replaced
    FILLED = filled
    EXPIRED = expired
    NEW = new
    AWAITING_RELEASE_TIME = awaiting_release_time
    PENDING_ACKNOWLEDGEMENT = pending_acknowledgement
    PENDING_RECALL = pending_recall
    UNKNOWN = unknown


class AmountIndicator(Enum):
    dollars = 'DOLLARS'
    shares = 'SHARES'
    all_shares = 'ALL_SHARES'
    percentage = 'PERCENTAGE'
    unknown = 'UNKNOWN'


class SettlementInstruction(Enum):
    regular = 'REGULAR'
    cash = 'CASH'
    next_day = 'NEXT_DAY'
    unknown = 'UNKNOWN'


class AdvancedOrderType(Enum):
    none = 'NONE'
    oto = 'OTO'
    oco = 'OCO'
    otoco = 'OTOCO'
    ot2_oco = 'OT2OCO'
    ot3_oco = 'OT3OCO'
    blast_all = 'BLAST_ALL'
    ota = 'OTA'
    pair = 'PAIR'


class OrderBalance(BaseModel):
    order_value: Optional[float] = Field(None, alias='orderValue')
    projected_available_fund: Optional[float] = Field(
        None, alias='projectedAvailableFund'
    )
    projected_buying_power: Optional[float] = Field(None, alias='projectedBuyingPower')
    projected_commission: Optional[float] = Field(None, alias='projectedCommission')


class APIRuleAction(Enum):
    accept = 'ACCEPT'
    alert = 'ALERT'
    reject = 'REJECT'
    review = 'REVIEW'
    unknown = 'UNKNOWN'


class FeeType(Enum):
    commission = 'COMMISSION'
    sec_fee = 'SEC_FEE'
    str_fee = 'STR_FEE'
    r_fee = 'R_FEE'
    cdsc_fee = 'CDSC_FEE'
    opt_reg_fee = 'OPT_REG_FEE'
    additional_fee = 'ADDITIONAL_FEE'
    miscellaneous_fee = 'MISCELLANEOUS_FEE'
    ftt = 'FTT'
    futures_clearing_fee = 'FUTURES_CLEARING_FEE'
    futures_desk_office_fee = 'FUTURES_DESK_OFFICE_FEE'
    futures_exchange_fee = 'FUTURES_EXCHANGE_FEE'
    futures_globex_fee = 'FUTURES_GLOBEX_FEE'
    futures_nfa_fee = 'FUTURES_NFA_FEE'
    futures_pit_brokerage_fee = 'FUTURES_PIT_BROKERAGE_FEE'
    futures_transaction_fee = 'FUTURES_TRANSACTION_FEE'
    low_proceeds_commission = 'LOW_PROCEEDS_COMMISSION'
    base_charge = 'BASE_CHARGE'
    general_charge = 'GENERAL_CHARGE'
    gst_fee = 'GST_FEE'
    taf_fee = 'TAF_FEE'
    index_option_fee = 'INDEX_OPTION_FEE'
    tefra_tax = 'TEFRA_TAX'
    state_tax = 'STATE_TAX'
    unknown = 'UNKNOWN'


class DateParam(BaseModel):
    date: Optional[str] = Field(
        None,
        description="Valid ISO-8601 format is :<br> <code>yyyy-MM-dd'T'HH:mm:ss.SSSZ</code>",
    )


class ActivityType(Enum):
    execution = 'EXECUTION'
    order_action = 'ORDER_ACTION'


class ExecutionType(Enum):
    fill = 'FILL'


class ExecutionLeg(BaseModel):
    leg_id: Optional[int] = Field(None, alias='legId')
    price: Optional[float] = None
    quantity: Optional[float] = None
    mismarked_quantity: Optional[float] = Field(None, alias='mismarkedQuantity')
    instrument_id: Optional[int] = Field(None, alias='instrumentId')
    time: Optional[datetime] = None


class ServiceError(BaseModel):
    message: Optional[str] = None
    errors: Optional[List[str]] = None


class OrderLegType(Enum):
    equity = 'EQUITY'
    option = 'OPTION'
    index = 'INDEX'
    mutual_fund = 'MUTUAL_FUND'
    cash_equivalent = 'CASH_EQUIVALENT'
    fixed_income = 'FIXED_INCOME'
    currency = 'CURRENCY'
    collective_investment = 'COLLECTIVE_INVESTMENT'
    # Alias uppercase members for compatibility
    EQUITY = equity
    OPTION = option
    INDEX = index
    MUTUAL_FUND = mutual_fund
    CASH_EQUIVALENT = cash_equivalent
    FIXED_INCOME = fixed_income
    CURRENCY = currency
    COLLECTIVE_INVESTMENT = collective_investment


class PositionEffect(Enum):
    opening = 'OPENING'
    closing = 'CLOSING'
    automatic = 'AUTOMATIC'
    # Alias uppercase members for compatibility
    OPENING = opening
    CLOSING = closing
    AUTOMATIC = automatic


class QuantityType(Enum):
    all_shares = 'ALL_SHARES'
    dollars = 'DOLLARS'
    shares = 'SHARES'
    # Alias uppercase members for compatibility
    ALL_SHARES = all_shares
    DOLLARS = dollars
    SHARES = shares


class DivCapGains(Enum):
    reinvest = 'REINVEST'
    payout = 'PAYOUT'


class Type(Enum):
    cash = 'CASH'
    margin = 'MARGIN'


class MarginInitialBalance(BaseModel):
    accrued_interest: Optional[float] = Field(None, alias='accruedInterest')
    available_funds_non_marginable_trade: Optional[float] = Field(
        None, alias='availableFundsNonMarginableTrade'
    )
    bond_value: Optional[float] = Field(None, alias='bondValue')
    buying_power: Optional[float] = Field(None, alias='buyingPower')
    cash_balance: Optional[float] = Field(None, alias='cashBalance')
    cash_available_for_trading: Optional[float] = Field(
        None, alias='cashAvailableForTrading'
    )
    cash_receipts: Optional[float] = Field(None, alias='cashReceipts')
    day_trading_buying_power: Optional[float] = Field(
        None, alias='dayTradingBuyingPower'
    )
    day_trading_buying_power_call: Optional[float] = Field(
        None, alias='dayTradingBuyingPowerCall'
    )
    day_trading_equity_call: Optional[float] = Field(None, alias='dayTradingEquityCall')
    equity: Optional[float] = None
    equity_percentage: Optional[float] = Field(None, alias='equityPercentage')
    liquidation_value: Optional[float] = Field(None, alias='liquidationValue')
    long_margin_value: Optional[float] = Field(None, alias='longMarginValue')
    long_option_market_value: Optional[float] = Field(
        None, alias='longOptionMarketValue'
    )
    long_stock_value: Optional[float] = Field(None, alias='longStockValue')
    maintenance_call: Optional[float] = Field(None, alias='maintenanceCall')
    maintenance_requirement: Optional[float] = Field(
        None, alias='maintenanceRequirement'
    )
    margin: Optional[float] = None
    margin_equity: Optional[float] = Field(None, alias='marginEquity')
    money_market_fund: Optional[float] = Field(None, alias='moneyMarketFund')
    mutual_fund_value: Optional[float] = Field(None, alias='mutualFundValue')
    reg_t_call: Optional[float] = Field(None, alias='regTCall')
    short_margin_value: Optional[float] = Field(None, alias='shortMarginValue')
    short_option_market_value: Optional[float] = Field(
        None, alias='shortOptionMarketValue'
    )
    short_stock_value: Optional[float] = Field(None, alias='shortStockValue')
    total_cash: Optional[float] = Field(None, alias='totalCash')
    is_in_call: Optional[float] = Field(None, alias='isInCall')
    unsettled_cash: Optional[float] = Field(None, alias='unsettledCash')
    pending_deposits: Optional[float] = Field(None, alias='pendingDeposits')
    margin_balance: Optional[float] = Field(None, alias='marginBalance')
    short_balance: Optional[float] = Field(None, alias='shortBalance')
    account_value: Optional[float] = Field(None, alias='accountValue')


class MarginBalance(BaseModel):
    available_funds: Optional[float] = Field(None, alias='availableFunds')
    available_funds_non_marginable_trade: Optional[float] = Field(
        None, alias='availableFundsNonMarginableTrade'
    )
    buying_power: Optional[float] = Field(None, alias='buyingPower')
    buying_power_non_marginable_trade: Optional[float] = Field(
        None, alias='buyingPowerNonMarginableTrade'
    )
    day_trading_buying_power: Optional[float] = Field(
        None, alias='dayTradingBuyingPower'
    )
    day_trading_buying_power_call: Optional[float] = Field(
        None, alias='dayTradingBuyingPowerCall'
    )
    equity: Optional[float] = None
    equity_percentage: Optional[float] = Field(None, alias='equityPercentage')
    long_margin_value: Optional[float] = Field(None, alias='longMarginValue')
    maintenance_call: Optional[float] = Field(None, alias='maintenanceCall')
    maintenance_requirement: Optional[float] = Field(
        None, alias='maintenanceRequirement'
    )
    margin_balance: Optional[float] = Field(None, alias='marginBalance')
    reg_t_call: Optional[float] = Field(None, alias='regTCall')
    short_balance: Optional[float] = Field(None, alias='shortBalance')
    short_margin_value: Optional[float] = Field(None, alias='shortMarginValue')
    sma: Optional[float] = None
    is_in_call: Optional[float] = Field(None, alias='isInCall')
    stock_buying_power: Optional[float] = Field(None, alias='stockBuyingPower')
    option_buying_power: Optional[float] = Field(None, alias='optionBuyingPower')


class CashInitialBalance(BaseModel):
    accrued_interest: Optional[float] = Field(None, alias='accruedInterest')
    cash_available_for_trading: Optional[float] = Field(
        None, alias='cashAvailableForTrading'
    )
    cash_available_for_withdrawal: Optional[float] = Field(
        None, alias='cashAvailableForWithdrawal'
    )
    cash_balance: Optional[float] = Field(None, alias='cashBalance')
    bond_value: Optional[float] = Field(None, alias='bondValue')
    cash_receipts: Optional[float] = Field(None, alias='cashReceipts')
    liquidation_value: Optional[float] = Field(None, alias='liquidationValue')
    long_option_market_value: Optional[float] = Field(
        None, alias='longOptionMarketValue'
    )
    long_stock_value: Optional[float] = Field(None, alias='longStockValue')
    money_market_fund: Optional[float] = Field(None, alias='moneyMarketFund')
    mutual_fund_value: Optional[float] = Field(None, alias='mutualFundValue')
    short_option_market_value: Optional[float] = Field(
        None, alias='shortOptionMarketValue'
    )
    short_stock_value: Optional[float] = Field(None, alias='shortStockValue')
    is_in_call: Optional[float] = Field(None, alias='isInCall')
    unsettled_cash: Optional[float] = Field(None, alias='unsettledCash')
    cash_debit_call_value: Optional[float] = Field(None, alias='cashDebitCallValue')
    pending_deposits: Optional[float] = Field(None, alias='pendingDeposits')
    account_value: Optional[float] = Field(None, alias='accountValue')


class CashBalance(BaseModel):
    cash_available_for_trading: Optional[float] = Field(
        None, alias='cashAvailableForTrading'
    )
    cash_available_for_withdrawal: Optional[float] = Field(
        None, alias='cashAvailableForWithdrawal'
    )
    cash_call: Optional[float] = Field(None, alias='cashCall')
    long_non_marginable_market_value: Optional[float] = Field(
        None, alias='longNonMarginableMarketValue'
    )
    total_cash: Optional[float] = Field(None, alias='totalCash')
    cash_debit_call_value: Optional[float] = Field(None, alias='cashDebitCallValue')
    unsettled_cash: Optional[float] = Field(None, alias='unsettledCash')


class TransactionBaseInstrument(BaseModel):
    asset_type: OrderLegType = Field(..., alias='assetType')
    cusip: Optional[str] = None
    symbol: Optional[str] = None
    description: Optional[str] = None
    instrument_id: Optional[int] = Field(None, alias='instrumentId')
    net_change: Optional[float] = Field(None, alias='netChange')


AccountsBaseInstrument = TransactionBaseInstrument


class Type1(Enum):
    sweep_vehicle = 'SWEEP_VEHICLE'
    savings = 'SAVINGS'
    money_market_fund = 'MONEY_MARKET_FUND'
    unknown = 'UNKNOWN'


class TransactionCashEquivalent(TransactionBaseInstrument):
    type: Optional[Type1] = None
    asset_type: Literal['CASH_EQUIVALENT'] = Field(..., alias='assetType')


class Type2(Enum):
    unit_investment_trust = 'UNIT_INVESTMENT_TRUST'
    exchange_traded_fund = 'EXCHANGE_TRADED_FUND'
    closed_end_fund = 'CLOSED_END_FUND'
    index = 'INDEX'
    units = 'UNITS'


class CollectiveInvestment(TransactionBaseInstrument):
    type: Optional[Type2] = None
    asset_type: Literal['COLLECTIVE_INVESTMENT'] = Field(..., alias='assetType')


class Instruction(Enum):
    buy = 'BUY'
    sell = 'SELL'
    buy_to_cover = 'BUY_TO_COVER'
    sell_short = 'SELL_SHORT'
    buy_to_open = 'BUY_TO_OPEN'
    buy_to_close = 'BUY_TO_CLOSE'
    sell_to_open = 'SELL_TO_OPEN'
    sell_to_close = 'SELL_TO_CLOSE'
    exchange = 'EXCHANGE'
    sell_short_exempt = 'SELL_SHORT_EXEMPT'
    # Alias uppercase members for compatibility
    BUY = buy
    SELL = sell
    BUY_TO_COVER = buy_to_cover
    SELL_SHORT = sell_short
    BUY_TO_OPEN = buy_to_open
    BUY_TO_CLOSE = buy_to_close
    SELL_TO_OPEN = sell_to_open
    SELL_TO_CLOSE = sell_to_close
    EXCHANGE = exchange
    SELL_SHORT_EXEMPT = sell_short_exempt


class AssetType(Enum):
    equity = 'EQUITY'
    mutual_fund = 'MUTUAL_FUND'
    option = 'OPTION'
    future = 'FUTURE'
    forex = 'FOREX'
    index = 'INDEX'
    cash_equivalent = 'CASH_EQUIVALENT'
    fixed_income = 'FIXED_INCOME'
    product = 'PRODUCT'
    currency = 'CURRENCY'
    collective_investment = 'COLLECTIVE_INVESTMENT'


class Currency(TransactionBaseInstrument):
    asset_type: Literal['CURRENCY'] = Field(..., alias='assetType')


class Type3(Enum):
    common_stock = 'COMMON_STOCK'
    preferred_stock = 'PREFERRED_STOCK'
    depository_receipt = 'DEPOSITORY_RECEIPT'
    preferred_depository_receipt = 'PREFERRED_DEPOSITORY_RECEIPT'
    restricted_stock = 'RESTRICTED_STOCK'
    component_unit = 'COMPONENT_UNIT'
    right = 'RIGHT'
    warrant = 'WARRANT'
    convertible_preferred_stock = 'CONVERTIBLE_PREFERRED_STOCK'
    convertible_stock = 'CONVERTIBLE_STOCK'
    limited_partnership = 'LIMITED_PARTNERSHIP'
    when_issued = 'WHEN_ISSUED'
    unknown = 'UNKNOWN'


class TransactionEquity(TransactionBaseInstrument):
    type: Optional[Type3] = None
    asset_type: Literal['EQUITY'] = Field(..., alias='assetType')


class Type4(Enum):
    bond_unit = 'BOND_UNIT'
    certificate_of_deposit = 'CERTIFICATE_OF_DEPOSIT'
    convertible_bond = 'CONVERTIBLE_BOND'
    collateralized_mortgage_obligation = 'COLLATERALIZED_MORTGAGE_OBLIGATION'
    corporate_bond = 'CORPORATE_BOND'
    government_mortgage = 'GOVERNMENT_MORTGAGE'
    gnma_bonds = 'GNMA_BONDS'
    municipal_assessment_district = 'MUNICIPAL_ASSESSMENT_DISTRICT'
    municipal_bond = 'MUNICIPAL_BOND'
    other_government = 'OTHER_GOVERNMENT'
    short_term_paper = 'SHORT_TERM_PAPER'
    us_treasury_bond = 'US_TREASURY_BOND'
    us_treasury_bill = 'US_TREASURY_BILL'
    us_treasury_note = 'US_TREASURY_NOTE'
    us_treasury_zero_coupon = 'US_TREASURY_ZERO_COUPON'
    agency_bond = 'AGENCY_BOND'
    when_as_and_if_issued_bond = 'WHEN_AS_AND_IF_ISSUED_BOND'
    asset_backed_security = 'ASSET_BACKED_SECURITY'
    unknown = 'UNKNOWN'


class TransactionFixedIncome(TransactionBaseInstrument):
    type: Optional[Type4] = None
    maturity_date: Optional[datetime] = Field(None, alias='maturityDate')
    factor: Optional[float] = None
    multiplier: Optional[float] = None
    variable_rate: Optional[float] = Field(None, alias='variableRate')
    asset_type: Literal['FIXED_INCOME'] = Field(..., alias='assetType')


class Type5(Enum):
    standard = 'STANDARD'
    nbbo = 'NBBO'
    unknown = 'UNKNOWN'


class Forex(TransactionBaseInstrument):
    type: Optional[Type5] = None
    base_currency: Optional[Currency] = Field(None, alias='baseCurrency')
    counter_currency: Optional[Currency] = Field(None, alias='counterCurrency')
    asset_type: Literal['FOREX'] = Field(..., alias='assetType')


class Type6(Enum):
    standard = 'STANDARD'
    unknown = 'UNKNOWN'


class Type7(Enum):
    broad_based = 'BROAD_BASED'
    narrow_based = 'NARROW_BASED'
    unknown = 'UNKNOWN'


class Type8(Enum):
    not_applicable = 'NOT_APPLICABLE'
    open_end_non_taxable = 'OPEN_END_NON_TAXABLE'
    open_end_taxable = 'OPEN_END_TAXABLE'
    no_load_non_taxable = 'NO_LOAD_NON_TAXABLE'
    no_load_taxable = 'NO_LOAD_TAXABLE'
    unknown = 'UNKNOWN'


class TransactionMutualFund(TransactionBaseInstrument):
    fund_family_name: Optional[str] = Field(None, alias='fundFamilyName')
    fund_family_symbol: Optional[str] = Field(None, alias='fundFamilySymbol')
    fund_group: Optional[str] = Field(None, alias='fundGroup')
    type: Optional[Type8] = None
    exchange_cutoff_time: Optional[datetime] = Field(None, alias='exchangeCutoffTime')
    purchase_cutoff_time: Optional[datetime] = Field(None, alias='purchaseCutoffTime')
    redemption_cutoff_time: Optional[datetime] = Field(
        None, alias='redemptionCutoffTime'
    )
    asset_type: Literal['MUTUAL_FUND'] = Field(..., alias='assetType')


class PutCall(Enum):
    put = 'PUT'
    call = 'CALL'
    unknown = 'UNKNOWN'


class Type9(Enum):
    vanilla = 'VANILLA'
    binary = 'BINARY'
    barrier = 'BARRIER'
    unknown = 'UNKNOWN'


class Type10(Enum):
    tbd = 'TBD'
    unknown = 'UNKNOWN'


class Product(TransactionBaseInstrument):
    type: Optional[Type10] = None
    asset_type: Literal['PRODUCT'] = Field(..., alias='assetType')


class AccountsBaseInstrument(BaseModel):
    """Base model for account instruments."""
    cusip: Optional[str] = None
    symbol: Optional[str] = None
    description: Optional[str] = None
    exchange: Optional[str] = None
    currency: Optional[str] = None
    type: Optional[str] = None
    net_change: Optional[float] = Field(None, alias='netChange')
    last_price: Optional[float] = Field(None, alias='lastPrice')
    close_price: Optional[float] = Field(None, alias='closePrice')
    open_price: Optional[float] = Field(None, alias='openPrice')
    high_price: Optional[float] = Field(None, alias='highPrice')
    low_price: Optional[float] = Field(None, alias='lowPrice')
    bid: Optional[float] = None
    ask: Optional[float] = None
    bid_size: Optional[int] = Field(None, alias='bidSize')
    ask_size: Optional[int] = Field(None, alias='askSize')
    volume: Optional[int] = None
    asset_type: Optional[str] = Field(None, alias='assetType')


class AccountCashEquivalent(AccountsBaseInstrument):
    type: Optional[Type1] = None
    asset_type: Literal['CASH_EQUIVALENT'] = Field(..., alias='assetType')


class AccountEquity(AccountsBaseInstrument):
    asset_type: Literal['EQUITY'] = Field(..., alias='assetType')


class AccountFixedIncome(AccountsBaseInstrument):
    maturity_date: Optional[datetime] = Field(None, alias='maturityDate')
    factor: Optional[float] = None
    variable_rate: Optional[float] = Field(None, alias='variableRate')
    asset_type: Literal['FIXED_INCOME'] = Field(..., alias='assetType')


AccountMutualFund = AccountEquity


class ApiCurrencyType(Enum):
    usd = 'USD'
    cad = 'CAD'
    eur = 'EUR'
    jpy = 'JPY'


class AccountAPIOptionDeliverable(BaseModel):
    symbol: Optional[str] = None
    deliverable_units: Optional[float] = Field(None, alias='deliverableUnits')
    api_currency_type: Optional[ApiCurrencyType] = Field(None, alias='apiCurrencyType')
    asset_type: Optional[AssetType] = Field(None, alias='assetType')


class TransactionType(Enum):
    trade = 'TRADE'
    receive_and_deliver = 'RECEIVE_AND_DELIVER'
    dividend_or_interest = 'DIVIDEND_OR_INTEREST'
    ach_receipt = 'ACH_RECEIPT'
    ach_disbursement = 'ACH_DISBURSEMENT'
    cash_receipt = 'CASH_RECEIPT'
    cash_disbursement = 'CASH_DISBURSEMENT'
    electronic_fund = 'ELECTRONIC_FUND'
    wire_out = 'WIRE_OUT'
    wire_in = 'WIRE_IN'
    journal = 'JOURNAL'
    memorandum = 'MEMORANDUM'
    margin_call = 'MARGIN_CALL'
    money_market = 'MONEY_MARKET'
    sma_adjustment = 'SMA_ADJUSTMENT'


class Status1(Enum):
    valid = 'VALID'
    invalid = 'INVALID'
    pending = 'PENDING'
    unknown = 'UNKNOWN'


class SubAccount(Enum):
    cash = 'CASH'
    margin = 'MARGIN'
    short = 'SHORT'
    div = 'DIV'
    income = 'INCOME'
    unknown = 'UNKNOWN'


class ActivityType1(Enum):
    activity_correction = 'ACTIVITY_CORRECTION'
    execution = 'EXECUTION'
    order_action = 'ORDER_ACTION'
    transfer = 'TRANSFER'
    unknown = 'UNKNOWN'


class Type13(Enum):
    advisor_user = 'ADVISOR_USER'
    broker_user = 'BROKER_USER'
    client_user = 'CLIENT_USER'
    system_user = 'SYSTEM_USER'
    unknown = 'UNKNOWN'


class UserDetails(BaseModel):
    cd_domain_id: Optional[str] = Field(None, alias='cdDomainId')
    login: Optional[str] = None
    type: Optional[Type13] = None
    user_id: Optional[int] = Field(None, alias='userId')
    system_user_name: Optional[str] = Field(None, alias='systemUserName')
    first_name: Optional[str] = Field(None, alias='firstName')
    last_name: Optional[str] = Field(None, alias='lastName')
    broker_rep_code: Optional[str] = Field(None, alias='brokerRepCode')


class FeeType1(Enum):
    commission = 'COMMISSION'
    sec_fee = 'SEC_FEE'
    str_fee = 'STR_FEE'
    r_fee = 'R_FEE'
    cdsc_fee = 'CDSC_FEE'
    opt_reg_fee = 'OPT_REG_FEE'
    additional_fee = 'ADDITIONAL_FEE'
    miscellaneous_fee = 'MISCELLANEOUS_FEE'
    futures_exchange_fee = 'FUTURES_EXCHANGE_FEE'
    low_proceeds_commission = 'LOW_PROCEEDS_COMMISSION'
    base_charge = 'BASE_CHARGE'
    general_charge = 'GENERAL_CHARGE'
    gst_fee = 'GST_FEE'
    taf_fee = 'TAF_FEE'
    index_option_fee = 'INDEX_OPTION_FEE'
    unknown = 'UNKNOWN'


class PositionEffect1(Enum):
    opening = 'OPENING'
    closing = 'CLOSING'
    automatic = 'AUTOMATIC'
    unknown = 'UNKNOWN'


class UserPreferenceAccount(BaseModel):
    account_number: Optional[str] = Field(None, alias='accountNumber')
    primary_account: Optional[bool] = Field(False, alias='primaryAccount')
    type: Optional[str] = None
    nick_name: Optional[str] = Field(None, alias='nickName')
    account_color: Optional[str] = Field(
        None, alias='accountColor', description='Green | Blue'
    )
    display_acct_id: Optional[str] = Field(None, alias='displayAcctId')
    auto_position_effect: Optional[bool] = Field(False, alias='autoPositionEffect')


class StreamerInfo(BaseModel):
    streamer_socket_url: Optional[str] = Field(None, alias='streamerSocketUrl')
    schwab_client_customer_id: Optional[str] = Field(
        None, alias='schwabClientCustomerId'
    )
    schwab_client_correl_id: Optional[str] = Field(None, alias='schwabClientCorrelId')
    schwab_client_channel: Optional[str] = Field(None, alias='schwabClientChannel')
    schwab_client_function_id: Optional[str] = Field(
        None, alias='schwabClientFunctionId'
    )


class Offer(BaseModel):
    level2_permissions: Optional[bool] = Field(False, alias='level2Permissions')
    mkt_data_permission: Optional[str] = Field(None, alias='mktDataPermission')


class OrderLeg(BaseModel):
    ask_price: Optional[float] = Field(None, alias='askPrice')
    bid_price: Optional[float] = Field(None, alias='bidPrice')
    last_price: Optional[float] = Field(None, alias='lastPrice')
    mark_price: Optional[float] = Field(None, alias='markPrice')
    projected_commission: Optional[float] = Field(None, alias='projectedCommission')
    quantity: Optional[float] = None
    final_symbol: Optional[str] = Field(None, alias='finalSymbol')
    leg_id: Optional[float] = Field(None, alias='legId')
    asset_type: Optional[AssetType] = Field(None, alias='assetType')
    instruction: Optional[Instruction] = None


class OrderValidationDetail(BaseModel):
    validation_rule_name: Optional[str] = Field(None, alias='validationRuleName')
    message: Optional[str] = None
    activity_message: Optional[str] = Field(None, alias='activityMessage')
    original_severity: Optional[APIRuleAction] = Field(None, alias='originalSeverity')
    override_name: Optional[str] = Field(None, alias='overrideName')
    override_severity: Optional[APIRuleAction] = Field(None, alias='overrideSeverity')


class CommissionValue(BaseModel):
    value: Optional[float] = None
    type: Optional[FeeType] = None


FeeValue = CommissionValue


class OrderActivity(BaseModel):
    activity_type: Optional[ActivityType] = Field(None, alias='activityType')
    execution_type: Optional[ExecutionType] = Field(None, alias='executionType')
    quantity: Optional[float] = None
    order_remaining_quantity: Optional[float] = Field(
        None, alias='orderRemainingQuantity'
    )
    execution_legs: Optional[List[ExecutionLeg]] = Field(None, alias='executionLegs')


class AccountOption(AccountsBaseInstrument):
    option_deliverables: Optional[List[AccountAPIOptionDeliverable]] = Field(
        None, alias='optionDeliverables'
    )
    put_call: Optional[PutCall] = Field(None, alias='putCall')
    option_multiplier: Optional[int] = Field(None, alias='optionMultiplier')
    type: Optional[Type9] = None
    underlying_symbol: Optional[str] = Field(None, alias='underlyingSymbol')
    asset_type: Literal['OPTION'] = Field(..., alias='assetType')


class UserPreference(BaseModel):
    accounts: Optional[List[UserPreferenceAccount]] = None
    streamer_info: Optional[List[StreamerInfo]] = Field(None, alias='streamerInfo')
    offers: Optional[List[Offer]] = None


class OrderStrategy(BaseModel):
    account_number: Optional[str] = Field(None, alias='accountNumber')
    advanced_order_type: Optional[AdvancedOrderType] = Field(
        None, alias='advancedOrderType'
    )
    close_time: Optional[datetime] = Field(None, alias='closeTime')
    entered_time: Optional[datetime] = Field(None, alias='enteredTime')
    order_balance: Optional[OrderBalance] = Field(None, alias='orderBalance')
    order_strategy_type: Optional[OrderStrategyType] = Field(
        None, alias='orderStrategyType'
    )
    order_version: Optional[float] = Field(None, alias='orderVersion')
    session: Optional[Session] = None
    status: Optional[Status] = None
    all_or_none: Optional[bool] = Field(None, alias='allOrNone')
    discretionary: Optional[bool] = None
    duration: Optional[Duration] = None
    filled_quantity: Optional[float] = Field(None, alias='filledQuantity')
    order_type: Optional[OrderType] = Field(None, alias='orderType')
    order_value: Optional[float] = Field(None, alias='orderValue')
    price: Optional[float] = None
    quantity: Optional[float] = None
    remaining_quantity: Optional[float] = Field(None, alias='remainingQuantity')
    sell_non_marginable_first: Optional[bool] = Field(
        None, alias='sellNonMarginableFirst'
    )
    settlement_instruction: Optional[SettlementInstruction] = Field(
        None, alias='settlementInstruction'
    )
    strategy: Optional[ComplexOrderStrategyType] = None
    amount_indicator: Optional[AmountIndicator] = Field(None, alias='amountIndicator')
    order_legs: Optional[List[OrderLeg]] = Field(None, alias='orderLegs')


class OrderValidationResult(BaseModel):
    alerts: Optional[List[OrderValidationDetail]] = None
    accepts: Optional[List[OrderValidationDetail]] = None
    rejects: Optional[List[OrderValidationDetail]] = None
    reviews: Optional[List[OrderValidationDetail]] = None
    warns: Optional[List[OrderValidationDetail]] = None


class CommissionLeg(BaseModel):
    commission_values: Optional[List[CommissionValue]] = Field(
        None, alias='commissionValues'
    )


class FeeLeg(BaseModel):
    fee_values: Optional[List[FeeValue]] = Field(None, alias='feeValues')


class AccountsInstrument(
    RootModel[
        Union[
            AccountCashEquivalent,
            AccountEquity,
            AccountFixedIncome,
            AccountMutualFund,
            AccountOption,
        ]
    ]
):
    root: Union[
        AccountCashEquivalent,
        AccountEquity,
        AccountFixedIncome,
        AccountMutualFund,
        AccountOption,
    ] = Field(..., discriminator='asset_type')


class Commission(BaseModel):
    commission_legs: Optional[List[CommissionLeg]] = Field(None, alias='commissionLegs')


class Fees(BaseModel):
    fee_legs: Optional[List[FeeLeg]] = Field(None, alias='feeLegs')


class Position(BaseModel):
    short_quantity: Optional[float] = Field(None, alias='shortQuantity')
    average_price: Optional[float] = Field(None, alias='averagePrice')
    current_day_profit_loss: Optional[float] = Field(None, alias='currentDayProfitLoss')
    current_day_profit_loss_percentage: Optional[float] = Field(
        None, alias='currentDayProfitLossPercentage'
    )
    long_quantity: Optional[float] = Field(None, alias='longQuantity')
    settled_long_quantity: Optional[float] = Field(None, alias='settledLongQuantity')
    settled_short_quantity: Optional[float] = Field(None, alias='settledShortQuantity')
    aged_quantity: Optional[float] = Field(None, alias='agedQuantity')
    # Ensure instrument attribute exists for mock specs
    instrument = None  # type: ignore[assignment]
    instrument: Optional[Any] = None  # Can be dict or AccountsInstrument
    market_value: Optional[float] = Field(None, alias='marketValue')
    maintenance_requirement: Optional[float] = Field(
        None, alias='maintenanceRequirement'
    )
    average_long_price: Optional[float] = Field(None, alias='averageLongPrice')
    average_short_price: Optional[float] = Field(None, alias='averageShortPrice')
    tax_lot_average_long_price: Optional[float] = Field(
        None, alias='taxLotAverageLongPrice'
    )
    tax_lot_average_short_price: Optional[float] = Field(
        None, alias='taxLotAverageShortPrice'
    )
    long_open_profit_loss: Optional[float] = Field(None, alias='longOpenProfitLoss')
    short_open_profit_loss: Optional[float] = Field(None, alias='shortOpenProfitLoss')
    previous_session_long_quantity: Optional[float] = Field(
        None, alias='previousSessionLongQuantity'
    )
    previous_session_short_quantity: Optional[float] = Field(
        None, alias='previousSessionShortQuantity'
    )
    current_day_cost: Optional[float] = Field(None, alias='currentDayCost')
    
    def model_post_init(self, __context: Any) -> None:
        """Parse instrument data into proper model after initialization."""
        if isinstance(self.instrument, dict):
            inst_data = self.instrument
            asset_type = inst_data.get('assetType', inst_data.get('asset_type', ''))
            
            try:
                # Parse based on asset type
                if asset_type == 'EQUITY':
                    self.instrument = AccountEquity.model_validate(inst_data)
                elif asset_type == 'OPTION':
                    self.instrument = AccountOption.model_validate(inst_data)
                elif asset_type == 'MUTUAL_FUND':
                    self.instrument = AccountMutualFund.model_validate(inst_data)
                elif asset_type == 'FIXED_INCOME':
                    self.instrument = AccountFixedIncome.model_validate(inst_data)
                elif asset_type == 'CASH_EQUIVALENT':
                    self.instrument = AccountCashEquivalent.model_validate(inst_data)
                else:
                    # Try generic base instrument
                    self.instrument = AccountsBaseInstrument.model_validate(inst_data)
            except Exception as e:
                # If parsing fails, create a namespace for attribute access
                from types import SimpleNamespace
                logger.debug(f"Failed to parse instrument as Pydantic model: {e}")
                self.instrument = SimpleNamespace(**inst_data)
    
    @property
    def symbol(self) -> Optional[str]:
        """Get symbol from instrument."""
        if self.instrument:
            if hasattr(self.instrument, 'symbol'):
                return self.instrument.symbol
            elif isinstance(self.instrument, dict):
                return self.instrument.get('symbol')
        return None
    
    @property
    def quantity(self) -> float:
        """Get net quantity (long - short)."""
        return (self.long_quantity or 0) - (self.short_quantity or 0)
    
    @property
    def average_cost(self) -> float:
        """Get average cost per share."""
        if self.long_quantity and self.long_quantity > 0:
            return self.average_long_price or 0
        elif self.short_quantity and self.short_quantity > 0:
            return self.average_short_price or 0
        return 0
    
    @property
    def current_price(self) -> float:
        """Get current price from instrument."""
        if self.instrument:
            # Check for last_price attribute
            if hasattr(self.instrument, 'last_price'):
                return float(self.instrument.last_price or 0)
            # Check if it's a dict
            elif isinstance(self.instrument, dict):
                return float(self.instrument.get('lastPrice', self.instrument.get('last_price', 0)))
        # If no instrument or no price, try to calculate from market value and quantity
        if self.market_value and self.quantity and self.quantity != 0:
            return abs(self.market_value / self.quantity)
        return 0
    
    @property
    def unrealized_gain_loss(self) -> float:
        """Get unrealized gain/loss."""
        return (self.long_open_profit_loss or 0) - (self.short_open_profit_loss or 0)
    
    @property
    def unrealized_gain_loss_percent(self) -> float:
        """Get unrealized gain/loss percentage."""
        cost_basis = self.quantity * self.average_cost
        if cost_basis != 0:
            return (self.unrealized_gain_loss / abs(cost_basis)) * 100
        return 0


class OrderLegCollection(BaseModel):
    order_leg_type: Optional[OrderLegType] = Field(None, alias='orderLegType')
    leg_id: Optional[int] = Field(None, alias='legId')
    # Instrument may be a raw dict for orders; use Any to preserve dict structure
    instrument: Any = None
    instruction: Optional[Instruction] = None
    position_effect: Optional[PositionEffect] = Field(None, alias='positionEffect')
    quantity: Optional[float] = None
    quantity_type: Optional[QuantityType] = Field(None, alias='quantityType')
    div_cap_gains: Optional[DivCapGains] = Field(None, alias='divCapGains')
    to_symbol: Optional[str] = Field(None, alias='toSymbol')


class SecuritiesAccountBase(BaseModel):
    type: Optional[Type] = None
    account_number: Optional[str] = Field(None, alias='accountNumber')
    round_trips: Optional[int] = Field(None, alias='roundTrips')
    is_day_trader: Optional[bool] = Field(False, alias='isDayTrader')
    is_closing_only_restricted: Optional[bool] = Field(
        False, alias='isClosingOnlyRestricted'
    )
    pfcb_flag: Optional[bool] = Field(False, alias='pfcbFlag')
    positions: Optional[List[Position]] = None


class MarginAccount(SecuritiesAccountBase):
    initial_balances: Optional[MarginInitialBalance] = Field(
        None, alias='initialBalances'
    )
    current_balances: Optional[MarginBalance] = Field(None, alias='currentBalances')
    projected_balances: Optional[MarginBalance] = Field(None, alias='projectedBalances')
    type: Literal['MARGIN']


class CashAccount(SecuritiesAccountBase):
    initial_balances: Optional[CashInitialBalance] = Field(
        None, alias='initialBalances'
    )
    current_balances: Optional[CashBalance] = Field(None, alias='currentBalances')
    projected_balances: Optional[CashBalance] = Field(None, alias='projectedBalances')
    type: Literal['CASH']


class CommissionAndFee(BaseModel):
    commission: Optional[Commission] = None
    fee: Optional[Fees] = None
    true_commission: Optional[Commission] = Field(None, alias='trueCommission')


class Order(BaseModel):
    session: Optional[Session] = None
    duration: Optional[Duration] = None
    order_type: Optional[OrderType] = Field(None, alias='orderType')
    cancel_time: Optional[datetime] = Field(None, alias='cancelTime')
    complex_order_strategy_type: Optional[ComplexOrderStrategyType] = Field(
        None, alias='complexOrderStrategyType'
    )
    quantity: Optional[float] = None
    filled_quantity: Optional[float] = Field(None, alias='filledQuantity')
    remaining_quantity: Optional[float] = Field(None, alias='remainingQuantity')
    requested_destination: Optional[RequestedDestination] = Field(
        None, alias='requestedDestination'
    )
    destination_link_name: Optional[str] = Field(None, alias='destinationLinkName')
    release_time: Optional[datetime] = Field(None, alias='releaseTime')
    stop_price: Optional[float] = Field(None, alias='stopPrice')
    stop_price_link_basis: Optional[StopPriceLinkBasis] = Field(
        None, alias='stopPriceLinkBasis'
    )
    stop_price_link_type: Optional[StopPriceLinkType] = Field(
        None, alias='stopPriceLinkType'
    )
    stop_price_offset: Optional[float] = Field(None, alias='stopPriceOffset')
    stop_type: Optional[StopType] = Field(None, alias='stopType')
    price_link_basis: Optional[StopPriceLinkBasis] = Field(None, alias='priceLinkBasis')
    price_link_type: Optional[StopPriceLinkType] = Field(None, alias='priceLinkType')
    price: Optional[float] = None
    tax_lot_method: Optional[TaxLotMethod] = Field(None, alias='taxLotMethod')
    order_leg_collection: Optional[List[OrderLegCollection]] = Field(
        None, alias='orderLegCollection'
    )
    activation_price: Optional[float] = Field(None, alias='activationPrice')
    special_instruction: Optional[SpecialInstruction] = Field(
        None, alias='specialInstruction'
    )
    order_strategy_type: Optional[OrderStrategyType] = Field(
        None, alias='orderStrategyType'
    )
    order_id: Optional[int] = Field(None, alias='orderId')
    cancelable: Optional[bool] = False
    editable: Optional[bool] = False
    status: Optional[Status] = None
    entered_time: Optional[datetime] = Field(None, alias='enteredTime')
    close_time: Optional[datetime] = Field(None, alias='closeTime')
    tag: Optional[str] = None
    account_number: Optional[int] = Field(None, alias='accountNumber')
    order_activity_collection: Optional[List[OrderActivity]] = Field(
        None, alias='orderActivityCollection'
    )
    replacing_order_collection: Optional[List[Order]] = Field(
        None, alias='replacingOrderCollection'
    )
    child_order_strategies: Optional[List[Order]] = Field(
        None, alias='childOrderStrategies'
    )
    status_description: Optional[str] = Field(None, alias='statusDescription')


class OrderRequest(BaseModel):
    session: Optional[Session] = None
    duration: Optional[Duration] = None
    order_type: Optional[OrderTypeRequest] = Field(None, alias='orderType')
    cancel_time: Optional[datetime] = Field(None, alias='cancelTime')
    complex_order_strategy_type: Optional[ComplexOrderStrategyType] = Field(
        None, alias='complexOrderStrategyType'
    )
    quantity: Optional[float] = None
    filled_quantity: Optional[float] = Field(None, alias='filledQuantity')
    remaining_quantity: Optional[float] = Field(None, alias='remainingQuantity')
    destination_link_name: Optional[str] = Field(None, alias='destinationLinkName')
    release_time: Optional[datetime] = Field(None, alias='releaseTime')
    stop_price: Optional[float] = Field(None, alias='stopPrice')
    stop_price_link_basis: Optional[StopPriceLinkBasis] = Field(
        None, alias='stopPriceLinkBasis'
    )
    stop_price_link_type: Optional[StopPriceLinkType] = Field(
        None, alias='stopPriceLinkType'
    )
    stop_price_offset: Optional[float] = Field(None, alias='stopPriceOffset')
    stop_type: Optional[StopType] = Field(None, alias='stopType')
    price_link_basis: Optional[StopPriceLinkBasis] = Field(None, alias='priceLinkBasis')
    price_link_type: Optional[StopPriceLinkType] = Field(None, alias='priceLinkType')
    price: Optional[float] = None
    tax_lot_method: Optional[TaxLotMethod] = Field(None, alias='taxLotMethod')
    order_leg_collection: Optional[List[OrderLegCollection]] = Field(
        None, alias='orderLegCollection'
    )
    activation_price: Optional[float] = Field(None, alias='activationPrice')
    special_instruction: Optional[SpecialInstruction] = Field(
        None, alias='specialInstruction'
    )
    order_strategy_type: Optional[OrderStrategyType] = Field(
        None, alias='orderStrategyType'
    )
    order_id: Optional[int] = Field(None, alias='orderId')
    cancelable: Optional[bool] = False
    editable: Optional[bool] = False
    status: Optional[Status] = None
    entered_time: Optional[datetime] = Field(None, alias='enteredTime')
    close_time: Optional[datetime] = Field(None, alias='closeTime')
    account_number: Optional[int] = Field(None, alias='accountNumber')
    order_activity_collection: Optional[List[OrderActivity]] = Field(
        None, alias='orderActivityCollection'
    )
    replacing_order_collection: Optional[List[OrderRequest]] = Field(
        None, alias='replacingOrderCollection'
    )
    child_order_strategies: Optional[List[OrderRequest]] = Field(
        None, alias='childOrderStrategies'
    )
    status_description: Optional[str] = Field(None, alias='statusDescription')


class PreviewOrder(BaseModel):
    order_id: Optional[int] = Field(None, alias='orderId')
    order_strategy: Optional[OrderStrategy] = Field(None, alias='orderStrategy')
    order_validation_result: Optional[OrderValidationResult] = Field(
        None, alias='orderValidationResult'
    )
    commission_and_fee: Optional[CommissionAndFee] = Field(
        None, alias='commissionAndFee'
    )


class SecuritiesAccount(RootModel[Union[MarginAccount, CashAccount]]):
    root: Union[MarginAccount, CashAccount] = Field(..., discriminator='type')


class Account(BaseModel):
    # Define securities_account attribute for spec and flexible nested data
    securities_account = None  # type: ignore[assignment]
    # Use Any for securities_account to allow nested account data without discriminator
    securities_account: Optional[Any] = Field(
        None, alias='securitiesAccount'
    )
    
    def model_post_init(self, __context: Any) -> None:
        """Parse securities_account data into proper Pydantic models after initialization."""
        if isinstance(self.securities_account, dict):
            sec_data = self.securities_account
            account_type = sec_data.get('type', '')
            
            try:
                # Parse based on account type
                if account_type == 'MARGIN':
                    self.securities_account = MarginAccount.model_validate(sec_data)
                elif account_type == 'CASH':
                    self.securities_account = CashAccount.model_validate(sec_data)
                else:
                    # If no type or unknown type, try to determine from structure
                    if 'marginBalance' in sec_data.get('currentBalances', {}):
                        self.securities_account = MarginAccount.model_validate(sec_data)
                    else:
                        self.securities_account = CashAccount.model_validate(sec_data)
            except Exception as e:
                # If parsing fails, create a fallback structure with parsed positions
                from types import SimpleNamespace
                logger.warning(f"Failed to parse securities_account as Pydantic model: {e}")
                
                # At least try to parse positions properly
                if 'positions' in sec_data and isinstance(sec_data['positions'], list):
                    parsed_positions = []
                    for pos_data in sec_data['positions']:
                        if isinstance(pos_data, dict):
                            try:
                                position_obj = Position.model_validate(pos_data)
                                parsed_positions.append(position_obj)
                            except Exception:
                                # Keep as dict if parsing fails
                                parsed_positions.append(pos_data)
                        else:
                            parsed_positions.append(pos_data)
                    sec_data['positions'] = parsed_positions
                
                # Convert to namespace for attribute access
                self.securities_account = self._dict_to_namespace(sec_data)
    
    def _dict_to_namespace(self, data: dict) -> Any:
        """Recursively convert dict to SimpleNamespace for attribute access."""
        from types import SimpleNamespace
        
        if isinstance(data, dict):
            # Convert nested dicts recursively
            for key, value in data.items():
                if isinstance(value, dict):
                    data[key] = self._dict_to_namespace(value)
                elif isinstance(value, list):
                    data[key] = [self._dict_to_namespace(item) if isinstance(item, dict) else item for item in value]
            return SimpleNamespace(**data)
        return data
    
    @property
    def buying_power(self) -> float:
        """Get buying power from current balances using proper Pydantic models."""
        try:
            if hasattr(self, 'securities_account') and self.securities_account:
                sec_acct = self.securities_account
                
                # Check account type
                if hasattr(sec_acct, 'type') and hasattr(sec_acct, 'current_balances') and sec_acct.current_balances:
                    if sec_acct.type == 'MARGIN':
                        # MarginBalance has buying_power field
                        if hasattr(sec_acct.current_balances, 'buying_power') and sec_acct.current_balances.buying_power is not None:
                            return float(sec_acct.current_balances.buying_power)
                    elif sec_acct.type == 'CASH':
                        # CashBalance uses cash_available_for_trading as buying power
                        if hasattr(sec_acct.current_balances, 'cash_available_for_trading') and sec_acct.current_balances.cash_available_for_trading is not None:
                            return float(sec_acct.current_balances.cash_available_for_trading)
            return 0.0
        except Exception as e:
            logger.debug(f"Error getting buying power: {e}")
            return 0.0
    
    @property
    def positions(self) -> Dict[str, Any]:
        """Get positions as a dictionary keyed by symbol."""
        positions_dict = {}
        try:
            if hasattr(self, 'securities_account') and self.securities_account:
                if hasattr(self.securities_account, 'positions'):
                    for position in self.securities_account.positions:
                        symbol = None
                        if hasattr(position, 'instrument'):
                            if hasattr(position.instrument, 'symbol'):
                                symbol = position.instrument.symbol
                            elif hasattr(position.instrument, 'root') and hasattr(position.instrument.root, 'symbol'):
                                symbol = position.instrument.root.symbol
                        if symbol:
                            positions_dict[symbol] = position
        except Exception:
            pass
        return positions_dict

# Ensure securities_account attribute exists on Account class for mock specs
Account.securities_account = None  # type: ignore[assignment]


# Add the missing Future class definition
class Future(TransactionBaseInstrument):
    """Future instrument model."""
    asset_type: Literal['FUTURE'] = Field(..., alias='assetType')

# Add the missing Index class definition
class Index(TransactionBaseInstrument):
    """Index instrument model."""
    asset_type: Literal['INDEX'] = Field(..., alias='assetType')

# Define TransactionAPIOptionDeliverable first since it's referenced in TransactionOption
class TransactionAPIOptionDeliverable(BaseModel):
    """Transaction API option deliverable model."""
    symbol: Optional[str] = None
    deliverable_units: Optional[float] = Field(None, alias='deliverableUnits')
    api_currency_type: Optional[ApiCurrencyType] = Field(None, alias='apiCurrencyType')
    asset_type: Optional[AssetType] = Field(None, alias='assetType')

# Forward declaration of TransactionInstrument for use in TransactionOption
TransactionInstrumentType = Any  # Will be properly defined later

# Define TransactionOption before it's used in TransactionInstrument
class TransactionOption(TransactionBaseInstrument):
    """Transaction Option instrument model."""
    expiration_date: Optional[datetime] = Field(None, alias='expirationDate')
    option_deliverables: Optional[List[TransactionAPIOptionDeliverable]] = Field(
        None, alias='optionDeliverables'
    )
    option_premium_multiplier: Optional[int] = Field(
        None, alias='optionPremiumMultiplier'
    )
    put_call: Optional[PutCall] = Field(None, alias='putCall')
    strike_price: Optional[float] = Field(None, alias='strikePrice')
    type: Optional[Type9] = None
    underlying_symbol: Optional[str] = Field(None, alias='underlyingSymbol')
    underlying_cusip: Optional[str] = Field(None, alias='underlyingCusip')
    deliverable: Optional[TransactionInstrumentType] = None  # Use forward declaration
    asset_type: Literal['OPTION'] = Field(..., alias='assetType')

# Now define TransactionInstrument after all the types it references
class TransactionInstrument(
    RootModel[
        Union[
            TransactionCashEquivalent,
            CollectiveInvestment,
            Currency,
            TransactionEquity,
            TransactionFixedIncome,
            Forex,
            Future,
            Index,
            TransactionMutualFund,
            TransactionOption,
            Product,
        ]
    ]
):
    root: Union[
        TransactionCashEquivalent,
        CollectiveInvestment,
        Currency,
        TransactionEquity,
        TransactionFixedIncome,
        Forex,
        Future,
        Index,
        TransactionMutualFund,
        TransactionOption,
        Product,
    ] = Field(..., discriminator='asset_type')


class Transaction(BaseModel):
    activity_id: Optional[int] = Field(None, alias='activityId')
    time: Optional[datetime] = None
    user: Optional[UserDetails] = None
    description: Optional[str] = None
    account_number: Optional[str] = Field(None, alias='accountNumber')
    type: Optional[TransactionType] = None
    status: Optional[Status1] = None
    sub_account: Optional[SubAccount] = Field(None, alias='subAccount')
    trade_date: Optional[datetime] = Field(None, alias='tradeDate')
    settlement_date: Optional[datetime] = Field(None, alias='settlementDate')
    position_id: Optional[int] = Field(None, alias='positionId')
    order_id: Optional[int] = Field(None, alias='orderId')
    net_amount: Optional[float] = Field(None, alias='netAmount')
    activity_type: Optional[ActivityType1] = Field(None, alias='activityType')
    transfer_items: Optional[List[TransferItem]] = Field(None, alias='transferItems')


class TransferItem(BaseModel):
    instrument: Optional[TransactionInstrument] = None
    amount: Optional[float] = None
    cost: Optional[float] = None
    price: Optional[float] = None
    fee_type: Optional[FeeType1] = Field(None, alias='feeType')
    position_effect: Optional[PositionEffect1] = Field(None, alias='positionEffect')


class Future(BaseModel):
    active_contract: Optional[bool] = Field(False, alias='activeContract')
    type: Optional[Type6] = None
    expiration_date: Optional[datetime] = Field(None, alias='expirationDate')
    last_trading_date: Optional[datetime] = Field(None, alias='lastTradingDate')
    first_notice_date: Optional[datetime] = Field(None, alias='firstNoticeDate')
    multiplier: Optional[float] = None
    asset_type: Literal['FUTURE'] = Field(..., alias='assetType')


class Index(BaseModel):
    active_contract: Optional[bool] = Field(False, alias='activeContract')
    type: Optional[Type7] = None
    asset_type: Literal['INDEX'] = Field(..., alias='assetType')


Order.model_rebuild()
OrderRequest.model_rebuild()
TransactionInstrument.model_rebuild()
TransactionOption.model_rebuild()
Transaction.model_rebuild()
Future.model_rebuild()
Index.model_rebuild()

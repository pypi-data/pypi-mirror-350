<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grscheller.datastructures.stack API documentation</title>
<meta name="description" content="LIFO stack â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grscheller.datastructures.stack</code></h1>
</header>
<section id="section-intro">
<p>LIFO stack</p>
<p>Module implementing a LIFO stack using a singularly linked linear tree of nodes.
The nodes can be safely shared between different Stack instances. Pushing to,
popping from, and getting the length of the stack are all O(1) operations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2023 Geoffrey R. Scheller
# 
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;LIFO stack

Module implementing a LIFO stack using a singularly linked linear tree of nodes.
The nodes can be safely shared between different Stack instances. Pushing to,
popping from, and getting the length of the stack are all O(1) operations.
&#34;&#34;&#34;
__all__ = [&#39;Stack&#39;]
__author__ = &#34;Geoffrey R. Scheller&#34;
__copyright__ = &#34;Copyright (c) 2023 Geoffrey R. Scheller&#34;
__license__ = &#34;Appache License 2.0&#34;

class _Node:
    &#34;&#34;&#34;Node that contains data and the next node.&#34;&#34;&#34;
    def __init__(self, datum, nodeNext=None):
        self._data = datum
        self._next = nodeNext

class Stack:
    &#34;&#34;&#34;Last In, First Out (LIFO) stack datastructure. The stack is implemented
    as a singularly linked list of nodes. The stack points to either the first
    node in the list, or to None to indicate an empty stack.

    Exceptions
    ----------
    Does not throw exceptions. The Stack class consistently uses None to
    represent the absence of a value.
    &#34;&#34;&#34;
    def __init__(self, *data):
        &#34;&#34;&#34;
        Parameters
        ----------
            *data : &#39;any&#39;
                Any data to prepopulate the stack.
                The data is pushed onto the stack left to right.
        &#34;&#34;&#34;
        self._head = None
        self._count = 0
        for datum in data:
            node = _Node(datum, self._head)
            self._head = node
            self._count += 1

    def __eq__(self, other):
        &#34;&#34;&#34;
        Returns True if all the data stored on the two stacks are the same.
        Worst case is O(n) behavior which happens when all the corresponding
        data elements on the two stacks are equal, in whatever sense they
        define equality, and none of the nodes are shared.

        Parameters
        ----------
            other : &#39;any&#39;
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False

        if self._count != other._count:
            return False

        left = self
        right = other
        nn = self._count
        while nn &gt; 0:
            if left._head is right._head:
                return True
            if left.head() != right.head():
                return False
            left = left.tail()
            right = right.tail()
            nn -= 1
        return True

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack.&#34;&#34;&#34;
        dataListStrs = []
        for data in self:
            dataListStrs.append(repr(data))
        dataListStrs.append(&#34;None&#34;)
        return &#34;[ &#34; + &#34; -&gt; &#34;.join(dataListStrs) + &#34; ]&#34;

    def __len__(self):
        &#34;&#34;&#34;Returns current number of values on the stack&#34;&#34;&#34;
        return self._count

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data stored in the stack, does not consume data.&#34;&#34;&#34;
        node = self._head
        while node is not None:
            assert node is not None
            yield node._data
            node = node._next

    def push(self, data):
        &#34;&#34;&#34;Push data onto top of stack, return data pushed.&#34;&#34;&#34;
        node = _Node(data, self._head)
        self._head = node
        self._count += 1
        return self

    def pop(self):
        &#34;&#34;&#34;Pop data off of top of stack.&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head = self._head._next
            self._count -= 1
            return data

    def head(self):
        &#34;&#34;&#34;Get data at head of stack without consuming it. Returns &#39;None&#39; if
        the stack is empty. Care should be taken if None &#34;values&#34; are pushed
        on the stack.

        Returns
        -------
        data : &#39;any&#39; | &#39;None&#39;
        &#34;&#34;&#34;
        if self._head is not None:
            return self._head._data
        else:
            return None

    def tail(self):
        &#34;&#34;&#34;Get the tail of the stack. In the case of an empty stack,
        return an empty stack in lieu of None. This will allow the returned
        value to be used as an iterator.

        Returns
        -------
        stack : &#39;Stack&#39;
        &#34;&#34;&#34;
        stack = Stack()
        if self._head is not None:
            stack._head = self._head._next
            stack._count = self._count - 1
        return stack

    def cons(self, data):
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        Returns
        -------
        stack : &#39;stack&#39;
        &#34;&#34;&#34;
        stack = Stack()
        stack._head = _Node(data, self._head)
        stack._count = self._count + 1
        return stack

    def copy(self):
        &#34;&#34;&#34;Return a shallow copy of the stack&#34;&#34;&#34;
        stack = Stack()
        stack._head = self._head
        stack._count = self._count
        return stack

    def isEmpty(self):
        &#34;&#34;&#34;Test if stack is empty&#34;&#34;&#34;
        return self._count == 0

if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grscheller.datastructures.stack.Stack"><code class="flex name class">
<span>class <span class="ident">Stack</span></span>
<span>(</span><span>*data)</span>
</code></dt>
<dd>
<div class="desc"><p>Last In, First Out (LIFO) stack datastructure. The stack is implemented
as a singularly linked list of nodes. The stack points to either the first
node in the list, or to None to indicate an empty stack.</p>
<h2 id="exceptions">Exceptions</h2>
<p>Does not throw exceptions. The Stack class consistently uses None to
represent the absence of a value.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>*data : 'any'
    Any data to prepopulate the stack.
    The data is pushed onto the stack left to right.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stack:
    &#34;&#34;&#34;Last In, First Out (LIFO) stack datastructure. The stack is implemented
    as a singularly linked list of nodes. The stack points to either the first
    node in the list, or to None to indicate an empty stack.

    Exceptions
    ----------
    Does not throw exceptions. The Stack class consistently uses None to
    represent the absence of a value.
    &#34;&#34;&#34;
    def __init__(self, *data):
        &#34;&#34;&#34;
        Parameters
        ----------
            *data : &#39;any&#39;
                Any data to prepopulate the stack.
                The data is pushed onto the stack left to right.
        &#34;&#34;&#34;
        self._head = None
        self._count = 0
        for datum in data:
            node = _Node(datum, self._head)
            self._head = node
            self._count += 1

    def __eq__(self, other):
        &#34;&#34;&#34;
        Returns True if all the data stored on the two stacks are the same.
        Worst case is O(n) behavior which happens when all the corresponding
        data elements on the two stacks are equal, in whatever sense they
        define equality, and none of the nodes are shared.

        Parameters
        ----------
            other : &#39;any&#39;
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False

        if self._count != other._count:
            return False

        left = self
        right = other
        nn = self._count
        while nn &gt; 0:
            if left._head is right._head:
                return True
            if left.head() != right.head():
                return False
            left = left.tail()
            right = right.tail()
            nn -= 1
        return True

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack.&#34;&#34;&#34;
        dataListStrs = []
        for data in self:
            dataListStrs.append(repr(data))
        dataListStrs.append(&#34;None&#34;)
        return &#34;[ &#34; + &#34; -&gt; &#34;.join(dataListStrs) + &#34; ]&#34;

    def __len__(self):
        &#34;&#34;&#34;Returns current number of values on the stack&#34;&#34;&#34;
        return self._count

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data stored in the stack, does not consume data.&#34;&#34;&#34;
        node = self._head
        while node is not None:
            assert node is not None
            yield node._data
            node = node._next

    def push(self, data):
        &#34;&#34;&#34;Push data onto top of stack, return data pushed.&#34;&#34;&#34;
        node = _Node(data, self._head)
        self._head = node
        self._count += 1
        return self

    def pop(self):
        &#34;&#34;&#34;Pop data off of top of stack.&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head = self._head._next
            self._count -= 1
            return data

    def head(self):
        &#34;&#34;&#34;Get data at head of stack without consuming it. Returns &#39;None&#39; if
        the stack is empty. Care should be taken if None &#34;values&#34; are pushed
        on the stack.

        Returns
        -------
        data : &#39;any&#39; | &#39;None&#39;
        &#34;&#34;&#34;
        if self._head is not None:
            return self._head._data
        else:
            return None

    def tail(self):
        &#34;&#34;&#34;Get the tail of the stack. In the case of an empty stack,
        return an empty stack in lieu of None. This will allow the returned
        value to be used as an iterator.

        Returns
        -------
        stack : &#39;Stack&#39;
        &#34;&#34;&#34;
        stack = Stack()
        if self._head is not None:
            stack._head = self._head._next
            stack._count = self._count - 1
        return stack

    def cons(self, data):
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        Returns
        -------
        stack : &#39;stack&#39;
        &#34;&#34;&#34;
        stack = Stack()
        stack._head = _Node(data, self._head)
        stack._count = self._count + 1
        return stack

    def copy(self):
        &#34;&#34;&#34;Return a shallow copy of the stack&#34;&#34;&#34;
        stack = Stack()
        stack._head = self._head
        stack._count = self._count
        return stack

    def isEmpty(self):
        &#34;&#34;&#34;Test if stack is empty&#34;&#34;&#34;
        return self._count == 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.stack.Stack.cons"><code class="name flex">
<span>def <span class="ident">cons</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new stack with data as head and self as tail.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stack</code></strong> :&ensp;<code>'stack'</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cons(self, data):
    &#34;&#34;&#34;Return a new stack with data as head and self as tail.

    Returns
    -------
    stack : &#39;stack&#39;
    &#34;&#34;&#34;
    stack = Stack()
    stack._head = _Node(data, self._head)
    stack._count = self._count + 1
    return stack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy of the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Return a shallow copy of the stack&#34;&#34;&#34;
    stack = Stack()
    stack._head = self._head
    stack._count = self._count
    return stack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data at head of stack without consuming it. Returns 'None' if
the stack is empty. Care should be taken if None "values" are pushed
on the stack.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>'any' | 'None'</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self):
    &#34;&#34;&#34;Get data at head of stack without consuming it. Returns &#39;None&#39; if
    the stack is empty. Care should be taken if None &#34;values&#34; are pushed
    on the stack.

    Returns
    -------
    data : &#39;any&#39; | &#39;None&#39;
    &#34;&#34;&#34;
    if self._head is not None:
        return self._head._data
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.isEmpty"><code class="name flex">
<span>def <span class="ident">isEmpty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Test if stack is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isEmpty(self):
    &#34;&#34;&#34;Test if stack is empty&#34;&#34;&#34;
    return self._count == 0</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off of top of stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self):
    &#34;&#34;&#34;Pop data off of top of stack.&#34;&#34;&#34;
    if self._head is None:
        return None
    else:
        data = self._head._data
        self._head = self._head._next
        self._count -= 1
        return data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Push data onto top of stack, return data pushed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, data):
    &#34;&#34;&#34;Push data onto top of stack, return data pushed.&#34;&#34;&#34;
    node = _Node(data, self._head)
    self._head = node
    self._count += 1
    return self</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tail of the stack. In the case of an empty stack,
return an empty stack in lieu of None. This will allow the returned
value to be used as an iterator.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stack</code></strong> :&ensp;<code>'Stack'</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self):
    &#34;&#34;&#34;Get the tail of the stack. In the case of an empty stack,
    return an empty stack in lieu of None. This will allow the returned
    value to be used as an iterator.

    Returns
    -------
    stack : &#39;Stack&#39;
    &#34;&#34;&#34;
    stack = Stack()
    if self._head is not None:
        stack._head = self._head._next
        stack._count = self._count - 1
    return stack</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grscheller.datastructures" href="index.html">grscheller.datastructures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grscheller.datastructures.stack.Stack" href="#grscheller.datastructures.stack.Stack">Stack</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.stack.Stack.cons" href="#grscheller.datastructures.stack.Stack.cons">cons</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.copy" href="#grscheller.datastructures.stack.Stack.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.head" href="#grscheller.datastructures.stack.Stack.head">head</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.isEmpty" href="#grscheller.datastructures.stack.Stack.isEmpty">isEmpty</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.pop" href="#grscheller.datastructures.stack.Stack.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.push" href="#grscheller.datastructures.stack.Stack.push">push</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.tail" href="#grscheller.datastructures.stack.Stack.tail">tail</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
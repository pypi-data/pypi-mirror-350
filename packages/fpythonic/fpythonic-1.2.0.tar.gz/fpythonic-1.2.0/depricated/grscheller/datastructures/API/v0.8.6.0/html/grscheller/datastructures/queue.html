<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grscheller.datastructures.queue API documentation</title>
<meta name="description" content="Module grscheller.datastructure.queue - queue based datastructures â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grscheller.datastructures.queue</code></h1>
</header>
<section id="section-intro">
<p>Module grscheller.datastructure.queue - queue based datastructures</p>
<p>Module implementing stateful FIFO data structures with amortized O(1) pushing
&amp; popping from the queue. Obtaining length (number of elements) of a queue is
also a O(1) operation. Implemented with a Python List based circular array.
Does not store None as a value.</p>
<h2 id="classes">Classes</h2>
<p>grscheller.datastructure.queue
- Single sided FIFO queue
grscheller.datastructure.dqueue - Double sided FIFO/LIFO queue</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Module grscheller.datastructure.queue - queue based datastructures

Module implementing stateful FIFO data structures with amortized O(1) pushing
&amp; popping from the queue. Obtaining length (number of elements) of a queue is
also a O(1) operation. Implemented with a Python List based circular array.
Does not store None as a value.

Classes:
  grscheller.datastructure.queue  - Single sided FIFO queue
  grscheller.datastructure.dqueue - Double sided FIFO/LIFO queue
&#34;&#34;&#34;

from __future__ import annotations

__all__ = [&#39;SQueue&#39;, &#39;DQueue&#39;]
__author__ = &#34;Geoffrey R. Scheller&#34;
__copyright__ = &#34;Copyright (c) 2023 Geoffrey R. Scheller&#34;
__license__ = &#34;Appache License 2.0&#34;

from typing import Any, Callable
from itertools import chain
from .core.iterlib import merge, exhaust
from .core.carray import CArray

class Queue():
    &#34;&#34;&#34;Abstract base class for the purposes of DRY inheritance of classes
    implementing queue type data structures with a list based circular array.
    Each queue object &#34;has-a&#34; (contains) a circular array to store its data. The
    circular array used will resize itself as needed. Each Queue subclass most
    ensure that None values do not get pushed onto the circular array.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a queue data structure.

        Null values will be culled from the intial data from ds.
        &#34;&#34;&#34;
        self._carray = CArray()
        for d in ds:
            if d is not None:
                self._carray.pushR(d)

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if queue is not empty.&#34;&#34;&#34;
        return len(self._carray) &gt; 0

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Returns current number of values in queue.&#34;&#34;&#34;
        return len(self._carray)

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data currently stored in queue. Data yielded in
        natural FIFO order.
        &#34;&#34;&#34;
        currCarray = self._carray.copy()
        for pos in range(len(currCarray)):
            yield currCarray[pos]

    def __reversed__(self):
        &#34;&#34;&#34;Reverse iterate over the current state of the queue.&#34;&#34;&#34;
        for data in reversed(self._carray.copy()):
            yield data

    def __eq__(self, other):
        &#34;&#34;&#34;Returns True if all the data stored in both compare as equal.
        Worst case is O(n) behavior for the true case.
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False
        return self._carray == other._carray

    def copy(self) -&gt; Any:
        &#34;&#34;&#34;Return shallow copy of the queue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        # Since types are objects, why can&#39;t Python match on Types???
        match repr(type(self)):
            case &#34;&lt;class &#39;grscheller.datastructures.queue.SQueue&#39;&gt;&#34;:
                queue = SQueue()
            case &#34;&lt;class &#39;grscheller.datastructures.queue.DQueue&#39;&gt;&#34;:
                queue = DQueue()
            case _:
                msg = f&#39;{repr(type(self))} is not a supported class &#39;
                msg += &#39;derived from the Stack base class.&#39;
                raise NotImplementedError(msg)
        queue._carray = self._carray.copy()
        return queue


class SQueue(Queue):
    &#34;&#34;&#34;Single sided queue datastructure.

    Will resize itself as needed.

    None represents the absence of a value and are ignored if pushed on the
    queue. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a FIFO queue data structure.&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display data in queue.&#34;&#34;&#34;
        return &#34;&lt;&lt; &#34; + &#34; &lt; &#34;.join(map(lambda x: repr(x), iter(self))) + &#34; &lt;&lt;&#34;

    def copy(self):
        squeue = SQueue()
        squeue._carray = self._carray.copy()
        return squeue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of queue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushR(d)

    def pop(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off front of queue.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popL()
        else:
            return None

    def peakLastIn(self) -&gt; Any|None:
        &#34;&#34;&#34;Return last element pushed to queue without consuming it.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[-1]
        else:
            return None

    def peakNextOut(self) -&gt; Any|None:
        &#34;&#34;&#34;Return next element ready to pop from queue without consuming it.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[0]
        else:
            return None

    def map(self, f: Callable[[Any], Any], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over Queue contents. If mut=True (the default) mutate
        the Queue &amp; don&#39;t return anything. Othersise, return a new Queue leaving
        the original unchanged. Suppress any None Values returned by f.
        &#34;&#34;&#34;
        queue  = SQueue(*map(f, iter(self)))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def flatMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the queue&#39;s contents and flatten result merging
        the queues produced sequentially front-to-back. If mut=True (default)
        mutate the Queue &amp; don&#39;t return anything. Othersise, return a new Queue
        leaving the original unchanged. Suppress any None Values contained in
        any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*chain(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def mergeMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
        robin merging until one of the first Queues produced by f is exhausted.
        If mut=True (default) mutate the Queue &amp; don&#39;t return anything.
        Othersise, return a new Queue leaving the original unchanged. Suppress
        any None Values contained in any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*merge(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def exhaustMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
        robin merging until all the Queues produced by f are exhausted. If
        mut=True (default) mutate the Queue &amp; don&#39;t return anything. Othersise,
        return a new Queue leaving the original unchanged. Suppress any None
        Values contained in any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*exhaust(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue


class DQueue(Queue):
    &#34;&#34;&#34;Double sided queue datastructure.

    Will resize itself as needed.

    None represents the absence of a value and are ignored if pushed on the
    queue. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a FIFO queue data structure.&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display data in dqueue.&#34;&#34;&#34;
        return &#34;&gt;&lt; &#34; + &#34; | &#34;.join(map(lambda x: repr(x), iter(self))) + &#34; &gt;&lt;&#34;

    def copy(self):
        dqueue = DQueue()
        dqueue._carray = self._carray.copy()
        return dqueue

    def pushR(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto rear of dqueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushR(d)

    def pushL(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto front of dqueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushL(d)

    def popR(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off rear of dqueue&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popR()
        else:
            return None

    def popL(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off front of dqueue&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popL()
        else:
            return None

    def peakR(self) -&gt; Any|None:
        &#34;&#34;&#34;Return right-most element of dqueue if it exists.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[-1]
        else:
            return None

    def peakL(self) -&gt; Any|None:
        &#34;&#34;&#34;Return left-most element of dqueue if it exists.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[0]
        else:
            return None

    def map(self, f: Callable[[Any], Any], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over DQueue contents. If mut=True (the default) mutate
        the DQueue &amp; don&#39;t return anything. Othersise, return a new DQueue
        leaving the original unchanged. Suppress any None Values returned by f.
        &#34;&#34;&#34;
        dqueue  = DQueue(*map(f, iter(self)))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def flatMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result merging
        the DQueues produced sequentially front-to-back. If mut=True (default)
        mutate the DQueue &amp; don&#39;t return anything. Othersise, return a new
        DQueue leaving the original unchanged. Suppress any None Values
        contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*chain(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def mergeMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
        robin merging until one of the first DQueues produced by f is exhausted.
        If mut=True (default) mutate the DQueue &amp; don&#39;t return anything.
        Othersise, return a new DQueue leaving the original unchanged. Suppress
        any None Values contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*merge(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def exhaustMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
        robin merging until all the DQueues produced by f are exhausted. If
        mut=True (default) mutate the DQueue &amp; don&#39;t return anything. Othersise,
        return a new DQueue leaving the original unchanged. Suppress any None
        Values contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*exhaust(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grscheller.datastructures.queue.DQueue"><code class="flex name class">
<span>class <span class="ident">DQueue</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Double sided queue datastructure.</p>
<p>Will resize itself as needed.</p>
<p>None represents the absence of a value and are ignored if pushed on the
queue. Use another object, like an empty tuple (), as a sentinal values.</p>
<p>Construct a FIFO queue data structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DQueue(Queue):
    &#34;&#34;&#34;Double sided queue datastructure.

    Will resize itself as needed.

    None represents the absence of a value and are ignored if pushed on the
    queue. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a FIFO queue data structure.&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display data in dqueue.&#34;&#34;&#34;
        return &#34;&gt;&lt; &#34; + &#34; | &#34;.join(map(lambda x: repr(x), iter(self))) + &#34; &gt;&lt;&#34;

    def copy(self):
        dqueue = DQueue()
        dqueue._carray = self._carray.copy()
        return dqueue

    def pushR(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto rear of dqueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushR(d)

    def pushL(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto front of dqueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushL(d)

    def popR(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off rear of dqueue&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popR()
        else:
            return None

    def popL(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off front of dqueue&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popL()
        else:
            return None

    def peakR(self) -&gt; Any|None:
        &#34;&#34;&#34;Return right-most element of dqueue if it exists.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[-1]
        else:
            return None

    def peakL(self) -&gt; Any|None:
        &#34;&#34;&#34;Return left-most element of dqueue if it exists.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[0]
        else:
            return None

    def map(self, f: Callable[[Any], Any], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over DQueue contents. If mut=True (the default) mutate
        the DQueue &amp; don&#39;t return anything. Othersise, return a new DQueue
        leaving the original unchanged. Suppress any None Values returned by f.
        &#34;&#34;&#34;
        dqueue  = DQueue(*map(f, iter(self)))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def flatMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result merging
        the DQueues produced sequentially front-to-back. If mut=True (default)
        mutate the DQueue &amp; don&#39;t return anything. Othersise, return a new
        DQueue leaving the original unchanged. Suppress any None Values
        contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*chain(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def mergeMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
        robin merging until one of the first DQueues produced by f is exhausted.
        If mut=True (default) mutate the DQueue &amp; don&#39;t return anything.
        Othersise, return a new DQueue leaving the original unchanged. Suppress
        any None Values contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*merge(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue

    def exhaustMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
        &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
        robin merging until all the DQueues produced by f are exhausted. If
        mut=True (default) mutate the DQueue &amp; don&#39;t return anything. Othersise,
        return a new DQueue leaving the original unchanged. Suppress any None
        Values contained in any of the DQueues returned by f.
        &#34;&#34;&#34;
        dqueue = DQueue(*exhaust(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = dqueue._carray
            return None
        return dqueue</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.queue.Queue</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.queue.DQueue.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of the queue in O(n) time &amp; space complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    dqueue = DQueue()
    dqueue._carray = self._carray.copy()
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.exhaustMap"><code class="name flex">
<span>def <span class="ident">exhaustMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>], mut:Â boolÂ =Â False) â€‘>Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the DQueue's contents and flatten result by round
robin merging until all the DQueues produced by f are exhausted. If
mut=True (default) mutate the DQueue &amp; don't return anything. Othersise,
return a new DQueue leaving the original unchanged. Suppress any None
Values contained in any of the DQueues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exhaustMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
    &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
    robin merging until all the DQueues produced by f are exhausted. If
    mut=True (default) mutate the DQueue &amp; don&#39;t return anything. Othersise,
    return a new DQueue leaving the original unchanged. Suppress any None
    Values contained in any of the DQueues returned by f.
    &#34;&#34;&#34;
    dqueue = DQueue(*exhaust(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = dqueue._carray
        return None
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.flatMap"><code class="name flex">
<span>def <span class="ident">flatMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>], mut:Â boolÂ =Â False) â€‘>Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the DQueue's contents and flatten result merging
the DQueues produced sequentially front-to-back. If mut=True (default)
mutate the DQueue &amp; don't return anything. Othersise, return a new
DQueue leaving the original unchanged. Suppress any None Values
contained in any of the DQueues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
    &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result merging
    the DQueues produced sequentially front-to-back. If mut=True (default)
    mutate the DQueue &amp; don&#39;t return anything. Othersise, return a new
    DQueue leaving the original unchanged. Suppress any None Values
    contained in any of the DQueues returned by f.
    &#34;&#34;&#34;
    dqueue = DQueue(*chain(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = dqueue._carray
        return None
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f:Â Callable[[Any],Â Any], mut:Â boolÂ =Â False) â€‘>Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over DQueue contents. If mut=True (the default) mutate
the DQueue &amp; don't return anything. Othersise, return a new DQueue
leaving the original unchanged. Suppress any None Values returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[Any], Any], mut: bool=False) -&gt; DQueue|None:
    &#34;&#34;&#34;Apply function over DQueue contents. If mut=True (the default) mutate
    the DQueue &amp; don&#39;t return anything. Othersise, return a new DQueue
    leaving the original unchanged. Suppress any None Values returned by f.
    &#34;&#34;&#34;
    dqueue  = DQueue(*map(f, iter(self)))
    if mut:
        self._carray = dqueue._carray
        return None
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.mergeMap"><code class="name flex">
<span>def <span class="ident">mergeMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>], mut:Â boolÂ =Â False) â€‘>Â <a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the DQueue's contents and flatten result by round
robin merging until one of the first DQueues produced by f is exhausted.
If mut=True (default) mutate the DQueue &amp; don't return anything.
Othersise, return a new DQueue leaving the original unchanged. Suppress
any None Values contained in any of the DQueues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeMap(self, f: Callable[[Any], DQueue], mut: bool=False) -&gt; DQueue|None:
    &#34;&#34;&#34;Apply function over the DQueue&#39;s contents and flatten result by round
    robin merging until one of the first DQueues produced by f is exhausted.
    If mut=True (default) mutate the DQueue &amp; don&#39;t return anything.
    Othersise, return a new DQueue leaving the original unchanged. Suppress
    any None Values contained in any of the DQueues returned by f.
    &#34;&#34;&#34;
    dqueue = DQueue(*merge(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = dqueue._carray
        return None
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.peakL"><code class="name flex">
<span>def <span class="ident">peakL</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return left-most element of dqueue if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakL(self) -&gt; Any|None:
    &#34;&#34;&#34;Return left-most element of dqueue if it exists.&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.peakR"><code class="name flex">
<span>def <span class="ident">peakR</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return right-most element of dqueue if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakR(self) -&gt; Any|None:
    &#34;&#34;&#34;Return right-most element of dqueue if it exists.&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray[-1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.popL"><code class="name flex">
<span>def <span class="ident">popL</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off front of dqueue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popL(self) -&gt; Any|None:
    &#34;&#34;&#34;Pop data off front of dqueue&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray.popL()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.popR"><code class="name flex">
<span>def <span class="ident">popR</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off rear of dqueue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popR(self) -&gt; Any|None:
    &#34;&#34;&#34;Pop data off rear of dqueue&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray.popR()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.pushL"><code class="name flex">
<span>def <span class="ident">pushL</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data left to right onto front of dqueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pushL(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data left to right onto front of dqueue.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._carray.pushL(d)</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.DQueue.pushR"><code class="name flex">
<span>def <span class="ident">pushR</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data left to right onto rear of dqueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pushR(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data left to right onto rear of dqueue.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._carray.pushR(d)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grscheller.datastructures.queue.SQueue"><code class="flex name class">
<span>class <span class="ident">SQueue</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Single sided queue datastructure.</p>
<p>Will resize itself as needed.</p>
<p>None represents the absence of a value and are ignored if pushed on the
queue. Use another object, like an empty tuple (), as a sentinal values.</p>
<p>Construct a FIFO queue data structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQueue(Queue):
    &#34;&#34;&#34;Single sided queue datastructure.

    Will resize itself as needed.

    None represents the absence of a value and are ignored if pushed on the
    queue. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a FIFO queue data structure.&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display data in queue.&#34;&#34;&#34;
        return &#34;&lt;&lt; &#34; + &#34; &lt; &#34;.join(map(lambda x: repr(x), iter(self))) + &#34; &lt;&lt;&#34;

    def copy(self):
        squeue = SQueue()
        squeue._carray = self._carray.copy()
        return squeue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of queue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._carray.pushR(d)

    def pop(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off front of queue.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray.popL()
        else:
            return None

    def peakLastIn(self) -&gt; Any|None:
        &#34;&#34;&#34;Return last element pushed to queue without consuming it.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[-1]
        else:
            return None

    def peakNextOut(self) -&gt; Any|None:
        &#34;&#34;&#34;Return next element ready to pop from queue without consuming it.&#34;&#34;&#34;
        if len(self._carray) &gt; 0:
            return self._carray[0]
        else:
            return None

    def map(self, f: Callable[[Any], Any], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over Queue contents. If mut=True (the default) mutate
        the Queue &amp; don&#39;t return anything. Othersise, return a new Queue leaving
        the original unchanged. Suppress any None Values returned by f.
        &#34;&#34;&#34;
        queue  = SQueue(*map(f, iter(self)))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def flatMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the queue&#39;s contents and flatten result merging
        the queues produced sequentially front-to-back. If mut=True (default)
        mutate the Queue &amp; don&#39;t return anything. Othersise, return a new Queue
        leaving the original unchanged. Suppress any None Values contained in
        any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*chain(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def mergeMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
        robin merging until one of the first Queues produced by f is exhausted.
        If mut=True (default) mutate the Queue &amp; don&#39;t return anything.
        Othersise, return a new Queue leaving the original unchanged. Suppress
        any None Values contained in any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*merge(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue

    def exhaustMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
        &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
        robin merging until all the Queues produced by f are exhausted. If
        mut=True (default) mutate the Queue &amp; don&#39;t return anything. Othersise,
        return a new Queue leaving the original unchanged. Suppress any None
        Values contained in any of the Queues returned by f.
        &#34;&#34;&#34;
        queue = SQueue(*exhaust(
            *map(lambda x: iter(x), map(f, iter(self)))
        ))
        if mut:
            self._carray = queue._carray
            return None
        return queue</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.queue.Queue</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.queue.SQueue.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of the queue in O(n) time &amp; space complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    squeue = SQueue()
    squeue._carray = self._carray.copy()
    return squeue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.exhaustMap"><code class="name flex">
<span>def <span class="ident">exhaustMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>], mut:Â boolÂ =Â True) â€‘>Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the Queue's contents and flatten result by round
robin merging until all the Queues produced by f are exhausted. If
mut=True (default) mutate the Queue &amp; don't return anything. Othersise,
return a new Queue leaving the original unchanged. Suppress any None
Values contained in any of the Queues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exhaustMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
    &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
    robin merging until all the Queues produced by f are exhausted. If
    mut=True (default) mutate the Queue &amp; don&#39;t return anything. Othersise,
    return a new Queue leaving the original unchanged. Suppress any None
    Values contained in any of the Queues returned by f.
    &#34;&#34;&#34;
    queue = SQueue(*exhaust(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = queue._carray
        return None
    return queue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.flatMap"><code class="name flex">
<span>def <span class="ident">flatMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>], mut:Â boolÂ =Â True) â€‘>Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the queue's contents and flatten result merging
the queues produced sequentially front-to-back. If mut=True (default)
mutate the Queue &amp; don't return anything. Othersise, return a new Queue
leaving the original unchanged. Suppress any None Values contained in
any of the Queues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
    &#34;&#34;&#34;Apply function over the queue&#39;s contents and flatten result merging
    the queues produced sequentially front-to-back. If mut=True (default)
    mutate the Queue &amp; don&#39;t return anything. Othersise, return a new Queue
    leaving the original unchanged. Suppress any None Values contained in
    any of the Queues returned by f.
    &#34;&#34;&#34;
    queue = SQueue(*chain(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = queue._carray
        return None
    return queue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f:Â Callable[[Any],Â Any], mut:Â boolÂ =Â True) â€‘>Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over Queue contents. If mut=True (the default) mutate
the Queue &amp; don't return anything. Othersise, return a new Queue leaving
the original unchanged. Suppress any None Values returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[Any], Any], mut: bool=True) -&gt; SQueue|None:
    &#34;&#34;&#34;Apply function over Queue contents. If mut=True (the default) mutate
    the Queue &amp; don&#39;t return anything. Othersise, return a new Queue leaving
    the original unchanged. Suppress any None Values returned by f.
    &#34;&#34;&#34;
    queue  = SQueue(*map(f, iter(self)))
    if mut:
        self._carray = queue._carray
        return None
    return queue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.mergeMap"><code class="name flex">
<span>def <span class="ident">mergeMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>], mut:Â boolÂ =Â True) â€‘>Â <a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function over the Queue's contents and flatten result by round
robin merging until one of the first Queues produced by f is exhausted.
If mut=True (default) mutate the Queue &amp; don't return anything.
Othersise, return a new Queue leaving the original unchanged. Suppress
any None Values contained in any of the Queues returned by f.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeMap(self, f: Callable[[Any], SQueue], mut: bool=True) -&gt; SQueue|None:
    &#34;&#34;&#34;Apply function over the Queue&#39;s contents and flatten result by round
    robin merging until one of the first Queues produced by f is exhausted.
    If mut=True (default) mutate the Queue &amp; don&#39;t return anything.
    Othersise, return a new Queue leaving the original unchanged. Suppress
    any None Values contained in any of the Queues returned by f.
    &#34;&#34;&#34;
    queue = SQueue(*merge(
        *map(lambda x: iter(x), map(f, iter(self)))
    ))
    if mut:
        self._carray = queue._carray
        return None
    return queue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.peakLastIn"><code class="name flex">
<span>def <span class="ident">peakLastIn</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return last element pushed to queue without consuming it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakLastIn(self) -&gt; Any|None:
    &#34;&#34;&#34;Return last element pushed to queue without consuming it.&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray[-1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.peakNextOut"><code class="name flex">
<span>def <span class="ident">peakNextOut</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return next element ready to pop from queue without consuming it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakNextOut(self) -&gt; Any|None:
    &#34;&#34;&#34;Return next element ready to pop from queue without consuming it.&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off front of queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; Any|None:
    &#34;&#34;&#34;Pop data off front of queue.&#34;&#34;&#34;
    if len(self._carray) &gt; 0:
        return self._carray.popL()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queue.SQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data on rear of queue &amp; no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data on rear of queue &amp; no return value.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._carray.pushR(d)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grscheller.datastructures" href="index.html">grscheller.datastructures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grscheller.datastructures.queue.DQueue" href="#grscheller.datastructures.queue.DQueue">DQueue</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.queue.DQueue.copy" href="#grscheller.datastructures.queue.DQueue.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.exhaustMap" href="#grscheller.datastructures.queue.DQueue.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.flatMap" href="#grscheller.datastructures.queue.DQueue.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.map" href="#grscheller.datastructures.queue.DQueue.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.mergeMap" href="#grscheller.datastructures.queue.DQueue.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.peakL" href="#grscheller.datastructures.queue.DQueue.peakL">peakL</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.peakR" href="#grscheller.datastructures.queue.DQueue.peakR">peakR</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.popL" href="#grscheller.datastructures.queue.DQueue.popL">popL</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.popR" href="#grscheller.datastructures.queue.DQueue.popR">popR</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.pushL" href="#grscheller.datastructures.queue.DQueue.pushL">pushL</a></code></li>
<li><code><a title="grscheller.datastructures.queue.DQueue.pushR" href="#grscheller.datastructures.queue.DQueue.pushR">pushR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grscheller.datastructures.queue.SQueue" href="#grscheller.datastructures.queue.SQueue">SQueue</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.queue.SQueue.copy" href="#grscheller.datastructures.queue.SQueue.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.exhaustMap" href="#grscheller.datastructures.queue.SQueue.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.flatMap" href="#grscheller.datastructures.queue.SQueue.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.map" href="#grscheller.datastructures.queue.SQueue.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.mergeMap" href="#grscheller.datastructures.queue.SQueue.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.peakLastIn" href="#grscheller.datastructures.queue.SQueue.peakLastIn">peakLastIn</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.peakNextOut" href="#grscheller.datastructures.queue.SQueue.peakNextOut">peakNextOut</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.pop" href="#grscheller.datastructures.queue.SQueue.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.queue.SQueue.push" href="#grscheller.datastructures.queue.SQueue.push">push</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grscheller.datastructures.queues API documentation</title>
<meta name="description" content="Module grscheller.datastructure.queues - queue based datastructures â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grscheller.datastructures.queues</code></h1>
</header>
<section id="section-intro">
<p>Module grscheller.datastructure.queues - queue based datastructures</p>
<p>Module implementing stateful queue data structures with amortized O(1) pushing and
popping from the queue. Obtaining length (number of elements) of a queue is an O(1)
operation. Implemented with a Python List based circular array, these data structures
will resize themselves as needed. Does not store None as a value.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2023-2024 Geoffrey R. Scheller
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Module grscheller.datastructure.queues - queue based datastructures

Module implementing stateful queue data structures with amortized O(1) pushing and
popping from the queue. Obtaining length (number of elements) of a queue is an O(1)
operation. Implemented with a Python List based circular array, these data structures
will resize themselves as needed. Does not store None as a value.
&#34;&#34;&#34;

from __future__ import annotations

__all__ = [&#39;DoubleQueue&#39;, &#39;FIFOQueue&#39;, &#39;LIFOQueue&#39;]
__author__ = &#34;Geoffrey R. Scheller&#34;
__copyright__ = &#34;Copyright (c) 2023-2024 Geoffrey R. Scheller&#34;
__license__ = &#34;Apache License 2.0&#34;

from typing import Any, Callable
from .core.fp import FP
from grscheller.circular_array import CircularArray

class QueueBase():
    &#34;&#34;&#34;Abstract base class for the purposes of DRY inheritance of classes
    implementing queue type data structures with a list based circular array.
    Each queue object &#34;has-a&#34; (contains) a circular array to store its data. The
    circular array used will resize itself as needed. Each QueueBase subclass
    must ensure that None values do not get pushed onto the circular array.
    &#34;&#34;&#34;
    __slots__ = &#39;_ca&#39;,

    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a queue data structure. Cull None values.&#34;&#34;&#34;
        self._ca = CircularArray()
        for d in ds:
            if d is not None:
                self._ca.pushR(d)

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data currently stored in queue. Data yielded in
        natural FIFO order.
        &#34;&#34;&#34;
        cached = self._ca.copy()
        for pos in range(len(cached)):
            yield cached[pos]

    def __reversed__(self):
        &#34;&#34;&#34;Reverse iterate over the current state of the queue.&#34;&#34;&#34;
        cached = self._ca.copy()
        for pos in range(len(cached)-1, -1, -1):
            yield cached[pos]

    def __repr__(self):
        return f&#39;{self.__class__.__name__}(&#39; + &#39;, &#39;.join(map(repr, self)) + &#39;)&#39;

    def __bool__(self):
        &#34;&#34;&#34;Returns true if queue is not empty.&#34;&#34;&#34;
        return len(self._ca) &gt; 0

    def __len__(self):
        &#34;&#34;&#34;Returns current number of values in queue.&#34;&#34;&#34;
        return len(self._ca)

    def __eq__(self, other):
        &#34;&#34;&#34;Returns True if all the data stored in both compare as equal.
        Worst case is O(n) behavior for the true case.
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False
        return self._ca == other._ca

    def map(self, f: Callable[[Any], Any]) -&gt; None:
        &#34;&#34;&#34;Apply function over the queue&#39;s contents. Suppress any None values
        returned by f.
        &#34;&#34;&#34;
        self._ca = QueueBase(*map(f, self))._ca

    def reverse(self):
        &#34;&#34;&#34;Reverse the elements in the Queue&#34;&#34;&#34;
        self._ca = self._ca.reverse()

class FIFOQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful single sided FIFO data structure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto an FIFOQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;&lt;&lt; &#34; + &#34; &lt; &#34;.join(map(str, self)) + &#34; &lt;&lt;&#34;

    def copy(self) -&gt; FIFOQueue:
        &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        fifoqueue = FIFOQueue()
        fifoqueue._ca = self._ca.copy()
        return fifoqueue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of the FIFOQueue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off front of the FIFOQueue.&#34;&#34;&#34;
        return self._ca.popL()

    def peakLastIn(self) -&gt; Any:
        &#34;&#34;&#34;Return last element pushed to the FIFOQueue without consuming it&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None

    def peakNextOut(self) -&gt; Any:
        &#34;&#34;&#34;Return next element ready to pop from the FIFOQueue.&#34;&#34;&#34;
        if self._ca:
            return self._ca[0]
        else:
            return None

class LIFOQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful single sided LIFO data structure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto an FIFOQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;|| &#34; + &#34; &gt; &#34;.join(map(str, self)) + &#34; &gt;&lt;&#34;

    def copy(self) -&gt; LIFOQueue:
        &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        lifoqueue = LIFOQueue()
        lifoqueue._ca = self._ca.copy()
        return lifoqueue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of the LIFOQueue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off rear of the LIFOQueue.&#34;&#34;&#34;
        return self._ca.popR()

    def peak(self) -&gt; Any:
        &#34;&#34;&#34;Return last element pushed to the LIFOQueue without consuming it&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None

class DoubleQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful double sided queue datastructure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto a DoubleQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;&gt;&lt; &#34; + &#34; | &#34;.join(map(str, self)) + &#34; &gt;&lt;&#34;

    def copy(self) -&gt; DoubleQueue:
        &#34;&#34;&#34;Return shallow copy of the DoubleQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        dqueue = DoubleQueue()
        dqueue._ca = self._ca.copy()
        return dqueue

    def pushR(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto rear of the DoubleQueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pushL(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto front of DoubleQueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushL(d)

    def popR(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off rear of the DoubleQueue&#34;&#34;&#34;
        return self._ca.popR()

    def popL(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off front of the DoubleQueue&#34;&#34;&#34;
        return self._ca.popL()

    def peakR(self) -&gt; Any:
        &#34;&#34;&#34;Return right-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None

    def peakL(self) -&gt; Any:
        &#34;&#34;&#34;Return left-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
        if self._ca:
            return self._ca[0]
        else:
            return None

    def __getitem__(self, index: int) -&gt; Any:
        return self._ca[index]

    def __setitem__(self, index: int, value):
        self._ca[index] = value

if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grscheller.datastructures.queues.DoubleQueue"><code class="flex name class">
<span>class <span class="ident">DoubleQueue</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Stateful double sided queue datastructure. Will resize itself as needed.
None represents the absence of a value and ignored if pushed onto a DoubleQueue.</p>
<p>Construct a queue data structure. Cull None values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DoubleQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful double sided queue datastructure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto a DoubleQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;&gt;&lt; &#34; + &#34; | &#34;.join(map(str, self)) + &#34; &gt;&lt;&#34;

    def copy(self) -&gt; DoubleQueue:
        &#34;&#34;&#34;Return shallow copy of the DoubleQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        dqueue = DoubleQueue()
        dqueue._ca = self._ca.copy()
        return dqueue

    def pushR(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto rear of the DoubleQueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pushL(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data left to right onto front of DoubleQueue.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushL(d)

    def popR(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off rear of the DoubleQueue&#34;&#34;&#34;
        return self._ca.popR()

    def popL(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off front of the DoubleQueue&#34;&#34;&#34;
        return self._ca.popL()

    def peakR(self) -&gt; Any:
        &#34;&#34;&#34;Return right-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None

    def peakL(self) -&gt; Any:
        &#34;&#34;&#34;Return left-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
        if self._ca:
            return self._ca[0]
        else:
            return None

    def __getitem__(self, index: int) -&gt; Any:
        return self._ca[index]

    def __setitem__(self, index: int, value):
        self._ca[index] = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.queues.QueueBase</li>
<li><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.queues.DoubleQueue.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="grscheller.datastructures.queues.DoubleQueue" href="#grscheller.datastructures.queues.DoubleQueue">DoubleQueue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of the DoubleQueue in O(n) time &amp; space complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; DoubleQueue:
    &#34;&#34;&#34;Return shallow copy of the DoubleQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
    dqueue = DoubleQueue()
    dqueue._ca = self._ca.copy()
    return dqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.peakL"><code class="name flex">
<span>def <span class="ident">peakL</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Return left-most element of the DoubleQueue if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakL(self) -&gt; Any:
    &#34;&#34;&#34;Return left-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
    if self._ca:
        return self._ca[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.peakR"><code class="name flex">
<span>def <span class="ident">peakR</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Return right-most element of the DoubleQueue if it exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakR(self) -&gt; Any:
    &#34;&#34;&#34;Return right-most element of the DoubleQueue if it exists.&#34;&#34;&#34;
    if self._ca:
        return self._ca[-1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.popL"><code class="name flex">
<span>def <span class="ident">popL</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off front of the DoubleQueue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popL(self) -&gt; Any:
    &#34;&#34;&#34;Pop data off front of the DoubleQueue&#34;&#34;&#34;
    return self._ca.popL()</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.popR"><code class="name flex">
<span>def <span class="ident">popR</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off rear of the DoubleQueue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popR(self) -&gt; Any:
    &#34;&#34;&#34;Pop data off rear of the DoubleQueue&#34;&#34;&#34;
    return self._ca.popR()</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.pushL"><code class="name flex">
<span>def <span class="ident">pushL</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data left to right onto front of DoubleQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pushL(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data left to right onto front of DoubleQueue.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._ca.pushL(d)</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.DoubleQueue.pushR"><code class="name flex">
<span>def <span class="ident">pushR</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data left to right onto rear of the DoubleQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pushR(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data left to right onto rear of the DoubleQueue.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._ca.pushR(d)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></b></code>:
<ul class="hlist">
<li><code><a title="grscheller.datastructures.core.fp.FP.accummulate" href="core/fp.html#grscheller.datastructures.core.fp.FP.accummulate">accummulate</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.exhaustMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.flatMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.foldL" href="core/fp.html#grscheller.datastructures.core.fp.FP.foldL">foldL</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.map" href="core/fp.html#grscheller.datastructures.core.fp.FP.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.mergeMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.reduce" href="core/fp.html#grscheller.datastructures.core.fp.FP.reduce">reduce</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grscheller.datastructures.queues.FIFOQueue"><code class="flex name class">
<span>class <span class="ident">FIFOQueue</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Stateful single sided FIFO data structure. Will resize itself as needed.
None represents the absence of a value and ignored if pushed onto an FIFOQueue.</p>
<p>Construct a queue data structure. Cull None values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FIFOQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful single sided FIFO data structure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto an FIFOQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;&lt;&lt; &#34; + &#34; &lt; &#34;.join(map(str, self)) + &#34; &lt;&lt;&#34;

    def copy(self) -&gt; FIFOQueue:
        &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        fifoqueue = FIFOQueue()
        fifoqueue._ca = self._ca.copy()
        return fifoqueue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of the FIFOQueue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off front of the FIFOQueue.&#34;&#34;&#34;
        return self._ca.popL()

    def peakLastIn(self) -&gt; Any:
        &#34;&#34;&#34;Return last element pushed to the FIFOQueue without consuming it&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None

    def peakNextOut(self) -&gt; Any:
        &#34;&#34;&#34;Return next element ready to pop from the FIFOQueue.&#34;&#34;&#34;
        if self._ca:
            return self._ca[0]
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.queues.QueueBase</li>
<li><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.queues.FIFOQueue.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="grscheller.datastructures.queues.FIFOQueue" href="#grscheller.datastructures.queues.FIFOQueue">FIFOQueue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; FIFOQueue:
    &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
    fifoqueue = FIFOQueue()
    fifoqueue._ca = self._ca.copy()
    return fifoqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.FIFOQueue.peakLastIn"><code class="name flex">
<span>def <span class="ident">peakLastIn</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Return last element pushed to the FIFOQueue without consuming it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakLastIn(self) -&gt; Any:
    &#34;&#34;&#34;Return last element pushed to the FIFOQueue without consuming it&#34;&#34;&#34;
    if self._ca:
        return self._ca[-1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.FIFOQueue.peakNextOut"><code class="name flex">
<span>def <span class="ident">peakNextOut</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Return next element ready to pop from the FIFOQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakNextOut(self) -&gt; Any:
    &#34;&#34;&#34;Return next element ready to pop from the FIFOQueue.&#34;&#34;&#34;
    if self._ca:
        return self._ca[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.FIFOQueue.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off front of the FIFOQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; Any:
    &#34;&#34;&#34;Pop data off front of the FIFOQueue.&#34;&#34;&#34;
    return self._ca.popL()</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.FIFOQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data on rear of the FIFOQueue &amp; no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data on rear of the FIFOQueue &amp; no return value.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._ca.pushR(d)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></b></code>:
<ul class="hlist">
<li><code><a title="grscheller.datastructures.core.fp.FP.accummulate" href="core/fp.html#grscheller.datastructures.core.fp.FP.accummulate">accummulate</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.exhaustMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.flatMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.foldL" href="core/fp.html#grscheller.datastructures.core.fp.FP.foldL">foldL</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.map" href="core/fp.html#grscheller.datastructures.core.fp.FP.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.mergeMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.reduce" href="core/fp.html#grscheller.datastructures.core.fp.FP.reduce">reduce</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grscheller.datastructures.queues.LIFOQueue"><code class="flex name class">
<span>class <span class="ident">LIFOQueue</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Stateful single sided LIFO data structure. Will resize itself as needed.
None represents the absence of a value and ignored if pushed onto an FIFOQueue.</p>
<p>Construct a queue data structure. Cull None values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LIFOQueue(QueueBase, FP):
    &#34;&#34;&#34;Stateful single sided LIFO data structure. Will resize itself as needed.
    None represents the absence of a value and ignored if pushed onto an FIFOQueue.
    &#34;&#34;&#34;
    __slots__ = ()

    def __str__(self):
        return &#34;|| &#34; + &#34; &gt; &#34;.join(map(str, self)) + &#34; &gt;&lt;&#34;

    def copy(self) -&gt; LIFOQueue:
        &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
        lifoqueue = LIFOQueue()
        lifoqueue._ca = self._ca.copy()
        return lifoqueue

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data on rear of the LIFOQueue &amp; no return value.&#34;&#34;&#34;
        for d in ds:
            if d != None:
                self._ca.pushR(d)

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off rear of the LIFOQueue.&#34;&#34;&#34;
        return self._ca.popR()

    def peak(self) -&gt; Any:
        &#34;&#34;&#34;Return last element pushed to the LIFOQueue without consuming it&#34;&#34;&#34;
        if self._ca:
            return self._ca[-1]
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.queues.QueueBase</li>
<li><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.queues.LIFOQueue.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="grscheller.datastructures.queues.LIFOQueue" href="#grscheller.datastructures.queues.LIFOQueue">LIFOQueue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; LIFOQueue:
    &#34;&#34;&#34;Return shallow copy of the FIFOQueue in O(n) time &amp; space complexity.&#34;&#34;&#34;
    lifoqueue = LIFOQueue()
    lifoqueue._ca = self._ca.copy()
    return lifoqueue</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.LIFOQueue.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Return last element pushed to the LIFOQueue without consuming it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak(self) -&gt; Any:
    &#34;&#34;&#34;Return last element pushed to the LIFOQueue without consuming it&#34;&#34;&#34;
    if self._ca:
        return self._ca[-1]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.LIFOQueue.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off rear of the LIFOQueue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; Any:
    &#34;&#34;&#34;Pop data off rear of the LIFOQueue.&#34;&#34;&#34;
    return self._ca.popR()</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.queues.LIFOQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, *ds:Â Any) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data on rear of the LIFOQueue &amp; no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data on rear of the LIFOQueue &amp; no return value.&#34;&#34;&#34;
    for d in ds:
        if d != None:
            self._ca.pushR(d)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grscheller.datastructures.core.fp.FP" href="core/fp.html#grscheller.datastructures.core.fp.FP">FP</a></b></code>:
<ul class="hlist">
<li><code><a title="grscheller.datastructures.core.fp.FP.accummulate" href="core/fp.html#grscheller.datastructures.core.fp.FP.accummulate">accummulate</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.exhaustMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.flatMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.foldL" href="core/fp.html#grscheller.datastructures.core.fp.FP.foldL">foldL</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.map" href="core/fp.html#grscheller.datastructures.core.fp.FP.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.mergeMap" href="core/fp.html#grscheller.datastructures.core.fp.FP.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP.reduce" href="core/fp.html#grscheller.datastructures.core.fp.FP.reduce">reduce</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grscheller.datastructures" href="index.html">grscheller.datastructures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grscheller.datastructures.queues.DoubleQueue" href="#grscheller.datastructures.queues.DoubleQueue">DoubleQueue</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.copy" href="#grscheller.datastructures.queues.DoubleQueue.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.peakL" href="#grscheller.datastructures.queues.DoubleQueue.peakL">peakL</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.peakR" href="#grscheller.datastructures.queues.DoubleQueue.peakR">peakR</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.popL" href="#grscheller.datastructures.queues.DoubleQueue.popL">popL</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.popR" href="#grscheller.datastructures.queues.DoubleQueue.popR">popR</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.pushL" href="#grscheller.datastructures.queues.DoubleQueue.pushL">pushL</a></code></li>
<li><code><a title="grscheller.datastructures.queues.DoubleQueue.pushR" href="#grscheller.datastructures.queues.DoubleQueue.pushR">pushR</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grscheller.datastructures.queues.FIFOQueue" href="#grscheller.datastructures.queues.FIFOQueue">FIFOQueue</a></code></h4>
<ul class="">
<li><code><a title="grscheller.datastructures.queues.FIFOQueue.copy" href="#grscheller.datastructures.queues.FIFOQueue.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.queues.FIFOQueue.peakLastIn" href="#grscheller.datastructures.queues.FIFOQueue.peakLastIn">peakLastIn</a></code></li>
<li><code><a title="grscheller.datastructures.queues.FIFOQueue.peakNextOut" href="#grscheller.datastructures.queues.FIFOQueue.peakNextOut">peakNextOut</a></code></li>
<li><code><a title="grscheller.datastructures.queues.FIFOQueue.pop" href="#grscheller.datastructures.queues.FIFOQueue.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.queues.FIFOQueue.push" href="#grscheller.datastructures.queues.FIFOQueue.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grscheller.datastructures.queues.LIFOQueue" href="#grscheller.datastructures.queues.LIFOQueue">LIFOQueue</a></code></h4>
<ul class="">
<li><code><a title="grscheller.datastructures.queues.LIFOQueue.copy" href="#grscheller.datastructures.queues.LIFOQueue.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.queues.LIFOQueue.peak" href="#grscheller.datastructures.queues.LIFOQueue.peak">peak</a></code></li>
<li><code><a title="grscheller.datastructures.queues.LIFOQueue.pop" href="#grscheller.datastructures.queues.LIFOQueue.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.queues.LIFOQueue.push" href="#grscheller.datastructures.queues.LIFOQueue.push">push</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
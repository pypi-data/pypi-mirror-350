<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grscheller.datastructures.stack API documentation</title>
<meta name="description" content="Module grscheller.datastructure.stack - Stateful &amp; Functional LIFO stacks: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grscheller.datastructures.stack</code></h1>
</header>
<section id="section-intro">
<p>Module grscheller.datastructure.stack - Stateful &amp; Functional LIFO stacks:</p>
<p>Module implementing a LIFO stacks using singularly linked linear trees of
nodes. The nodes can be safely shared between different stack instances and
are an implementation detail hidden from client code.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2023 Geoffrey R. Scheller
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Module grscheller.datastructure.stack - Stateful &amp; Functional LIFO stacks:

   Module implementing a LIFO stacks using singularly linked linear trees of
   nodes. The nodes can be safely shared between different stack instances and
   are an implementation detail hidden from client code.
&#34;&#34;&#34;

from __future__ import annotations

__all__ = [&#39;Stack&#39;, &#39;FStack&#39;]
__author__ = &#34;Geoffrey R. Scheller&#34;
__copyright__ = &#34;Copyright (c) 2023 Geoffrey R. Scheller&#34;
__license__ = &#34;Appache License 2.0&#34;

from typing import Any, Callable
from .queue import CircularArray
from .core.nodes import SL_Node as Node
from .core.fp import FP_rev

class StackBase():
    &#34;&#34;&#34;Abstract base class for the purposes of DRY inheritance of classes
    implementing stack type data structures. Each stack is a very simple
    stateful object containing a count of the number of elements on it and
    a reference to an immutable node of a linear tree of singularly linked
    nodes. Different stack objects can safely share the same data by each
    pointing to the same node. Each stack class ensures None values do not
    get pushed onto the the stack.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a LIFO Stack&#34;&#34;&#34;
        self._head = None
        self._count = 0
        for d in ds:
            if d is not None:
                node = Node(d, self._head)
                self._head = node
                self._count += 1

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data stored on the stack, starting at the head&#34;&#34;&#34;
        node = self._head
        while node:
            yield node._data
            node = node._next

    def __reversed__(self):
        &#34;&#34;&#34;Reverse iterate over the contents of the stack&#34;&#34;&#34;
        return reversed(CircularArray(*self))

    def __repr__(self):
        return f&#39;{self.__class__.__name__}(&#39; + &#39;, &#39;.join(map(repr, reversed(self))) + &#39;)&#39;

    def __bool__(self):
        &#34;&#34;&#34;Returns true if stack is not empty&#34;&#34;&#34;
        return self._count &gt; 0

    def __len__(self):
        &#34;&#34;&#34;Returns current number of values on the stack&#34;&#34;&#34;
        return self._count

    def __eq__(self, other: Any):
        &#34;&#34;&#34;Returns True if all the data stored on the two stacks are the same
        and the two stacks are of the same subclass. Worst case is O(n) behavior
        which happens when all the corresponding data elements on the two stacks
        are equal, in whatever sense they equality is defined, and none of the
        nodes are shared.
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False

        if self._count != other._count:
            return False

        left = self._head
        right = other._head
        nn = self._count
        while nn &gt; 0:
            if left is right:
                return True
            if left is None or right is None:
                return True
            if left._data != right._data:
                return False
            left = left._next
            right = right._next
            nn -= 1
        return True

class Stack(StackBase):
    &#34;&#34;&#34;Class implementing a mutable Last In, First Out (LIFO) stack data structure
    pointing to a singularly linked list of nodes. This class is designed to share
    nodes with other Stack instances.

    Stacks are stateful objects, values can be pushed on &amp; popped off.

    A Stack points to either the top node in the list, or to None which indicates
    an empty stack.

    A Stack keeps a count of the number of objects currently on it. Pushing to,
    popping from, getting the length and copying the Stack are all O(1) operations.

    None represents the absence of a value and ignored if pushed on a Stack.
    &#34;&#34;&#34;
    def __str__(self):
        &#34;&#34;&#34;Display the data in the Stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;|| &#39; + &#39; &lt;- &#39;.join(reversed(CircularArray(*self).map(repr))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; Stack:
        &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
        stack = Stack()
        stack._head, stack._count = self._head, self._count
        return stack

    def reverse(self) -&gt; None:
        &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
        stack = Stack(reversed(self))
        self._head, self._count = stack._head, stack._count

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data that is not NONE onto top of stack,
        return the stack being pushed.
        &#34;&#34;&#34;
        for d in ds:
            if d is not None:
                node = Node(d, self._head)
                self._head, self._count = node, self._count+1

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head, self._count = self._head._next, self._count-1
            return data

    def peak(self, default: Any=None) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the top of the stack. Does not consume the data.
        If stack is empty, data does not exist so in that case return default.
        &#34;&#34;&#34;
        if self._head is None:
            return default
        return self._head._data

    def map(self, f: Callable[[Any], Stack]) -&gt; None:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the Stack.
        Mutates the Stack object. O(n).
        &#34;&#34;&#34;
        newStack = Stack(*map(f, reversed(self)))
        self._head, self._count = newStack._head, newStack._count

class FStack(StackBase, FP_rev):
    &#34;&#34;&#34;Class implementing an immutable Last IN, First Out (LIFO) data structure
    pointing to a singularly linked list of nodes. This class is designed to share
    nodes with other FStack instances.

    FStack stacks are immutable objects.

    An FStack points to either the top node in the list, or to None which indicates
    an empty FStack.

    An Fstack keeps a count of the number of objects currently on it. Getting the head,
    tail, length, copying and creating a new Fstack with cons are all O(1) operations.

    None represents the absence of a value and ignored if pushed on an FStack.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        super().__init__(*ds)

    def __str__(self):
        &#34;&#34;&#34;Display the data in the FStack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;| &#39; + &#39; &lt;- &#39;.join(reversed(CircularArray(*self).map(repr))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; FStack:
        &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        fstack = FStack()
        fstack._head = self._head
        fstack._count = self._count
        return fstack

    def reverse(self) -&gt; FStack:
        return FStack(reversed(self))

    def head(self, default: Any=None) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the top of the FStack. Does not consume the data.
        If the FStack is empty, head does not exist so in that case return default.
        &#34;&#34;&#34;
        if self._head is None:
            return default
        return self._head._data

    def tail(self, default=None) -&gt; FStack:
        &#34;&#34;&#34;Return tail of the FStack. If FStack is empty, tail does not exist, so
        return a default of type FStack instead. If default is not given, return
        an empty FStack.
        &#34;&#34;&#34;
        if self._head:
            fstack = FStack()
            fstack._head = self._head._next
            fstack._count = self._count - 1
            return fstack
        elif default is None:
            return FStack()
        else:
            return default

    def cons(self, d: Any) -&gt; FStack:
        &#34;&#34;&#34;Return a new FStack with data as head and self as tail. Constructing
        an FStack using a non-existent value as head results in a non-existent
        FStack. In that case, just return a copy of the FStack.
        &#34;&#34;&#34;
        if d is not None:
            fstack = FStack()
            fstack._head = Node(d, self._head)
            fstack._count = self._count + 1
            return fstack
        else:
            return self.copy()

if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grscheller.datastructures.stack.FStack"><code class="flex name class">
<span>class <span class="ident">FStack</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Class implementing an immutable Last IN, First Out (LIFO) data structure
pointing to a singularly linked list of nodes. This class is designed to share
nodes with other FStack instances.</p>
<p>FStack stacks are immutable objects.</p>
<p>An FStack points to either the top node in the list, or to None which indicates
an empty FStack.</p>
<p>An Fstack keeps a count of the number of objects currently on it. Getting the head,
tail, length, copying and creating a new Fstack with cons are all O(1) operations.</p>
<p>None represents the absence of a value and ignored if pushed on an FStack.</p>
<p>Construct a LIFO Stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FStack(StackBase, FP_rev):
    &#34;&#34;&#34;Class implementing an immutable Last IN, First Out (LIFO) data structure
    pointing to a singularly linked list of nodes. This class is designed to share
    nodes with other FStack instances.

    FStack stacks are immutable objects.

    An FStack points to either the top node in the list, or to None which indicates
    an empty FStack.

    An Fstack keeps a count of the number of objects currently on it. Getting the head,
    tail, length, copying and creating a new Fstack with cons are all O(1) operations.

    None represents the absence of a value and ignored if pushed on an FStack.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        super().__init__(*ds)

    def __str__(self):
        &#34;&#34;&#34;Display the data in the FStack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;| &#39; + &#39; &lt;- &#39;.join(reversed(CircularArray(*self).map(repr))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; FStack:
        &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        fstack = FStack()
        fstack._head = self._head
        fstack._count = self._count
        return fstack

    def reverse(self) -&gt; FStack:
        return FStack(reversed(self))

    def head(self, default: Any=None) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the top of the FStack. Does not consume the data.
        If the FStack is empty, head does not exist so in that case return default.
        &#34;&#34;&#34;
        if self._head is None:
            return default
        return self._head._data

    def tail(self, default=None) -&gt; FStack:
        &#34;&#34;&#34;Return tail of the FStack. If FStack is empty, tail does not exist, so
        return a default of type FStack instead. If default is not given, return
        an empty FStack.
        &#34;&#34;&#34;
        if self._head:
            fstack = FStack()
            fstack._head = self._head._next
            fstack._count = self._count - 1
            return fstack
        elif default is None:
            return FStack()
        else:
            return default

    def cons(self, d: Any) -&gt; FStack:
        &#34;&#34;&#34;Return a new FStack with data as head and self as tail. Constructing
        an FStack using a non-existent value as head results in a non-existent
        FStack. In that case, just return a copy of the FStack.
        &#34;&#34;&#34;
        if d is not None:
            fstack = FStack()
            fstack._head = Node(d, self._head)
            fstack._count = self._count + 1
            return fstack
        else:
            return self.copy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.stack.StackBase</li>
<li><a title="grscheller.datastructures.core.fp.FP_rev" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev">FP_rev</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.stack.FStack.cons"><code class="name flex">
<span>def <span class="ident">cons</span></span>(<span>self, d: Any) ‑> <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a new FStack with data as head and self as tail. Constructing
an FStack using a non-existent value as head results in a non-existent
FStack. In that case, just return a copy of the FStack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cons(self, d: Any) -&gt; FStack:
    &#34;&#34;&#34;Return a new FStack with data as head and self as tail. Constructing
    an FStack using a non-existent value as head results in a non-existent
    FStack. In that case, just return a copy of the FStack.
    &#34;&#34;&#34;
    if d is not None:
        fstack = FStack()
        fstack._head = Node(d, self._head)
        fstack._count = self._count + 1
        return fstack
    else:
        return self.copy()</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of a FStack in O(1) time &amp; space complexity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; FStack:
    &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
    fstack = FStack()
    fstack._head = self._head
    fstack._count = self._count
    return fstack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, default: Any = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the top of the FStack. Does not consume the data.
If the FStack is empty, head does not exist so in that case return default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, default: Any=None) -&gt; Any:
    &#34;&#34;&#34;Returns the data at the top of the FStack. Does not consume the data.
    If the FStack is empty, head does not exist so in that case return default.
    &#34;&#34;&#34;
    if self._head is None:
        return default
    return self._head._data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self) ‑> <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self) -&gt; FStack:
    return FStack(reversed(self))</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self, default=None) ‑> <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return tail of the FStack. If FStack is empty, tail does not exist, so
return a default of type FStack instead. If default is not given, return
an empty FStack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self, default=None) -&gt; FStack:
    &#34;&#34;&#34;Return tail of the FStack. If FStack is empty, tail does not exist, so
    return a default of type FStack instead. If default is not given, return
    an empty FStack.
    &#34;&#34;&#34;
    if self._head:
        fstack = FStack()
        fstack._head = self._head._next
        fstack._count = self._count - 1
        return fstack
    elif default is None:
        return FStack()
    else:
        return default</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="grscheller.datastructures.core.fp.FP_rev" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev">FP_rev</a></b></code>:
<ul class="hlist">
<li><code><a title="grscheller.datastructures.core.fp.FP_rev.exhaustMap" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP_rev.flatMap" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP_rev.map" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.core.fp.FP_rev.mergeMap" href="core/fp.html#grscheller.datastructures.core.fp.FP_rev.mergeMap">mergeMap</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="grscheller.datastructures.stack.Stack"><code class="flex name class">
<span>class <span class="ident">Stack</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Class implementing a mutable Last In, First Out (LIFO) stack data structure
pointing to a singularly linked list of nodes. This class is designed to share
nodes with other Stack instances.</p>
<p>Stacks are stateful objects, values can be pushed on &amp; popped off.</p>
<p>A Stack points to either the top node in the list, or to None which indicates
an empty stack.</p>
<p>A Stack keeps a count of the number of objects currently on it. Pushing to,
popping from, getting the length and copying the Stack are all O(1) operations.</p>
<p>None represents the absence of a value and ignored if pushed on a Stack.</p>
<p>Construct a LIFO Stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stack(StackBase):
    &#34;&#34;&#34;Class implementing a mutable Last In, First Out (LIFO) stack data structure
    pointing to a singularly linked list of nodes. This class is designed to share
    nodes with other Stack instances.

    Stacks are stateful objects, values can be pushed on &amp; popped off.

    A Stack points to either the top node in the list, or to None which indicates
    an empty stack.

    A Stack keeps a count of the number of objects currently on it. Pushing to,
    popping from, getting the length and copying the Stack are all O(1) operations.

    None represents the absence of a value and ignored if pushed on a Stack.
    &#34;&#34;&#34;
    def __str__(self):
        &#34;&#34;&#34;Display the data in the Stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;|| &#39; + &#39; &lt;- &#39;.join(reversed(CircularArray(*self).map(repr))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; Stack:
        &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
        stack = Stack()
        stack._head, stack._count = self._head, self._count
        return stack

    def reverse(self) -&gt; None:
        &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
        stack = Stack(reversed(self))
        self._head, self._count = stack._head, stack._count

    def push(self, *ds: Any) -&gt; None:
        &#34;&#34;&#34;Push data that is not NONE onto top of stack,
        return the stack being pushed.
        &#34;&#34;&#34;
        for d in ds:
            if d is not None:
                node = Node(d, self._head)
                self._head, self._count = node, self._count+1

    def pop(self) -&gt; Any:
        &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head, self._count = self._head._next, self._count-1
            return data

    def peak(self, default: Any=None) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the top of the stack. Does not consume the data.
        If stack is empty, data does not exist so in that case return default.
        &#34;&#34;&#34;
        if self._head is None:
            return default
        return self._head._data

    def map(self, f: Callable[[Any], Stack]) -&gt; None:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the Stack.
        Mutates the Stack object. O(n).
        &#34;&#34;&#34;
        newStack = Stack(*map(f, reversed(self)))
        self._head, self._count = newStack._head, newStack._count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.stack.StackBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.stack.Stack.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="grscheller.datastructures.stack.Stack" href="#grscheller.datastructures.stack.Stack">Stack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of a Stack in O(1) time &amp; space complexity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; Stack:
    &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
    stack = Stack()
    stack._head, stack._count = self._head, self._count
    return stack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f: Callable[[Any], <a title="grscheller.datastructures.stack.Stack" href="#grscheller.datastructures.stack.Stack">Stack</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Maps a function (or callable object) over the values on the Stack.
Mutates the Stack object. O(n).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[Any], Stack]) -&gt; None:
    &#34;&#34;&#34;Maps a function (or callable object) over the values on the Stack.
    Mutates the Stack object. O(n).
    &#34;&#34;&#34;
    newStack = Stack(*map(f, reversed(self)))
    self._head, self._count = newStack._head, newStack._count</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>self, default: Any = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the top of the stack. Does not consume the data.
If stack is empty, data does not exist so in that case return default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak(self, default: Any=None) -&gt; Any:
    &#34;&#34;&#34;Returns the data at the top of the stack. Does not consume the data.
    If stack is empty, data does not exist so in that case return default.
    &#34;&#34;&#34;
    if self._head is None:
        return default
    return self._head._data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off of top of stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; Any:
    &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
    if self._head is None:
        return None
    else:
        data = self._head._data
        self._head, self._count = self._head._next, self._count-1
        return data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, *ds: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Push data that is not NONE onto top of stack,
return the stack being pushed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, *ds: Any) -&gt; None:
    &#34;&#34;&#34;Push data that is not NONE onto top of stack,
    return the stack being pushed.
    &#34;&#34;&#34;
    for d in ds:
        if d is not None:
            node = Node(d, self._head)
            self._head, self._count = node, self._count+1</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.Stack.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of a Stack in O(1) time &amp; space complexity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self) -&gt; None:
    &#34;&#34;&#34;Return shallow copy of a Stack in O(1) time &amp; space complexity&#34;&#34;&#34;
    stack = Stack(reversed(self))
    self._head, self._count = stack._head, stack._count</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grscheller.datastructures" href="index.html">grscheller.datastructures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></code></h4>
<ul class="">
<li><code><a title="grscheller.datastructures.stack.FStack.cons" href="#grscheller.datastructures.stack.FStack.cons">cons</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.copy" href="#grscheller.datastructures.stack.FStack.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.head" href="#grscheller.datastructures.stack.FStack.head">head</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.reverse" href="#grscheller.datastructures.stack.FStack.reverse">reverse</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.tail" href="#grscheller.datastructures.stack.FStack.tail">tail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grscheller.datastructures.stack.Stack" href="#grscheller.datastructures.stack.Stack">Stack</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.stack.Stack.copy" href="#grscheller.datastructures.stack.Stack.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.map" href="#grscheller.datastructures.stack.Stack.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.peak" href="#grscheller.datastructures.stack.Stack.peak">peak</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.pop" href="#grscheller.datastructures.stack.Stack.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.push" href="#grscheller.datastructures.stack.Stack.push">push</a></code></li>
<li><code><a title="grscheller.datastructures.stack.Stack.reverse" href="#grscheller.datastructures.stack.Stack.reverse">reverse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grscheller.datastructures.stack API documentation</title>
<meta name="description" content="Module grscheller.datastructure.stack - LIFO stack: â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grscheller.datastructures.stack</code></h1>
</header>
<section id="section-intro">
<p>Module grscheller.datastructure.stack - LIFO stack:</p>
<p>Module implementing a LIFO stack using a singularly linked linear tree of
nodes. The nodes can be safely shared between different Stack instances and
are an implementation detail hidden from client code.</p>
<p>Pushing to, popping from, and getting the length of the stack are all O(1)
operations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2023 Geoffrey R. Scheller
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;Module grscheller.datastructure.stack - LIFO stack:

   Module implementing a LIFO stack using a singularly linked linear tree of
   nodes. The nodes can be safely shared between different Stack instances and
   are an implementation detail hidden from client code.

   Pushing to, popping from, and getting the length of the stack are all O(1)
   operations.
&#34;&#34;&#34;

from __future__ import annotations

__all__ = [&#39;PStack&#39;, &#39;FStack&#39;]
__author__ = &#34;Geoffrey R. Scheller&#34;
__copyright__ = &#34;Copyright (c) 2023 Geoffrey R. Scheller&#34;
__license__ = &#34;Appache License 2.0&#34;

from typing import Any, Callable, Self
from itertools import chain
from .core.iterlib import merge, exhaust
from .core.carray import CArray

class _Node():

    &#34;&#34;&#34;Class implementing nodes that can be linked together to form a singularly
    linked list. A node always contain data. It either has a reference to the
    next _Node object or None to indicate the bottom of the linked list.

    Nodes can safely be shared between different Stack instances.
    &#34;&#34;&#34;
    def __init__(self, data: Any, nodeNext: _Node|None):
        &#34;&#34;&#34;Construct an element of a linked list, semantically immutable.

        Note: It is the Stack class&#39;s responsibility that the _data property is
        never set to None.
        &#34;&#34;&#34;
        self._data = data
        self._next = nodeNext

    def __bool__(self):
        &#34;&#34;&#34;Always return true, None will return as false&#34;&#34;&#34;
        return True

class Stack():
    &#34;&#34;&#34;Abstract base class for the purposes of DRY inheritance of classes
    implementing stack type data structures. Each stack is a very simple
    stateful object containing a count of the number of elements on it and
    a reference to an immutable node of a linear tree of singularly linked
    nodes. Different stack objects can safely share the same data by each
    pointing to the same node. Each stack class ensures None values do not
    get pushed onto the the stack.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a LIFO Stack&#34;&#34;&#34;
        self._head = None
        self._count = 0
        for d in ds:
            if d is not None:
                node = _Node(d, self._head)
                self._head = node
                self._count += 1

    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;Returns true if stack is not empty&#34;&#34;&#34;
        return self._count &gt; 0

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Returns current number of values on the stack&#34;&#34;&#34;
        return self._count

    def __iter__(self):
        &#34;&#34;&#34;Iterator yielding data stored in the stack, starting at the head&#34;&#34;&#34;
        node = self._head
        while node:
            yield node._data
            node = node._next

    def __reversed__(self):
        &#34;&#34;&#34;Reverse iterate over the contents of the stack&#34;&#34;&#34;
        return reversed(CArray(*self))

    def __eq__(self, other: Any):
        &#34;&#34;&#34;Returns True if all the data stored on the two stacks are the same
        and the two stacks are of the same subclass. Worst case is O(n) behavior
        which happens when all the corresponding data elements on the two stacks
        are equal, in whatever sense they equality is defined, and none of the
        nodes are shared.
        &#34;&#34;&#34;
        if not isinstance(other, type(self)):
            return False

        if self._count != other._count:
            return False

        left = self._head
        right = other._head
        nn = self._count
        while nn &gt; 0:
            if left is right:
                return True
            if left is None or right is None:
                return True
            if left._data != right._data:
                return False
            left = left._next
            right = right._next
            nn -= 1
        return True


class PStack(Stack):
    &#34;&#34;&#34;Class implementing a Last In, First Out (LIFO) stack data structure. The
    stack contains a singularly linked list of nodes. Class designed to share
    nodes with other PStack instances.

    PStacks are stateful objects where values can be pushed on &amp; popped off.

    A stack points to either the top node of a singlely linked list, or to
    None which indicates an empty stack.

    A stack keeps a count of the number of objects currently on it.

    None represents the absence of a value and are ignored if pushed on the
    stack. Use another object, like an empty tuple (), as a sentinal value.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a stateful LIFO Stack&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;|| &#39; + &#39; &lt;- &#39;.join(reversed(CArray(*self).map(lambda x: repr(x)))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; PStack:
        &#34;&#34;&#34;Return shallow copy of a PStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        pstack = PStack()
        pstack._head = self._head
        pstack._count = self._count
        return pstack

    def push(self, *ds: Any) -&gt; Self:
        &#34;&#34;&#34;Push data that is not NONE onto top of stack,
        return the stack being pushed.
        &#34;&#34;&#34;
        for d in ds:
            if d is not None:
                node = _Node(d, self._head)
                self._head = node
                self._count += 1
        return self

    def pop(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head = self._head._next
            self._count -= 1
            return data

    def peak(self) -&gt; Any|None:
        &#34;&#34;&#34;Returns the data at the top of stack. Does not consume the data.

        Note: If stack is empty, return None.
        &#34;&#34;&#34;
        if self._head is None:
            return None
        return self._head._data

    def peakOr(self, default: Any) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return default value.
        &#34;&#34;&#34;
        value = self.peak()
        if value is None:
            value = default
        return value

    def map(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

        Returns a new stack with new nodes.  None values surpressed.
        &#34;&#34;&#34;
        newPStack = PStack(*map(f, reversed(self)))
        self._head = newPStack._head
        self._count = newPStack._count

    def flatMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance.

        Merge the stacks produced sequentially front-to-back.
        &#34;&#34;&#34;
        newPStack = PStack(*chain(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count

    def mergeMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance.

        Round Robin Merge the stacks produced until first cached stack is
        exhausted.
        &#34;&#34;&#34;
        newPStack = PStack(*merge(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count

    def exhaustMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until all the cached stacks are
        exhausted.
        &#34;&#34;&#34;
        newPStack = PStack(*exhaust(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count


class FStack(Stack):
    &#34;&#34;&#34;Class implementing an immutable singularly linked stack data
    structure consisting of a singularly linked list of nodes. This class
    designed to share nodes with other FStack instances.

    Functional stacks are also immutable objects.

    A functional stack points to either the top node in the list, or to None
    which indicates an empty stack.

    A functional stack has the count of the number of objects on it.

    None represents the absence of a value and are ignored if pushed on the
    stack. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct an immutable LIFO Stack&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;| &#39; + &#39; &lt;- &#39;.join(reversed(CArray(*self).map(lambda x: repr(x)))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; FStack:
        &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        fstack = FStack()
        fstack._head = self._head
        fstack._count = self._count
        return fstack

    def head(self) -&gt; Any|None:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return None.
        &#34;&#34;&#34;
        if self._head is None:
            return None
        return self._head._data

    def headOr(self, default: Any) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return default value.
        &#34;&#34;&#34;
        value = self.head()
        if value is None:
            value = default
        return value

    def tail(self) -&gt; Stack|None:
        &#34;&#34;&#34;Return tail of the stack. Note, the tail of an empty stack does
        not exist, hence return None.
        &#34;&#34;&#34;
        stack = FStack()
        if self._head:
            stack._head = self._head._next
            stack._count = self._count - 1
            return stack
        return None

    def tailOr(self, default: FStack|None=None) -&gt; Stack:
        &#34;&#34;&#34;Return tail of the stack.

        Note: If stack is empty, return default value of type Stack.
              If default value not give, return a new empty stack.
        &#34;&#34;&#34;
        stack = self.tail()
        if stack is None:
            if default is None:
                stack = FStack()
            else:
                stack = default
        return stack

    def cons(self, data: Any) -&gt; FStack|None:
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        Constructing a stack using a non-existent value as
        head results in a non-existent stack.
        &#34;&#34;&#34;
        if data is not None:
            stack = FStack()
            stack._head = _Node(data, self._head)
            stack._count = self._count + 1
            return stack
        else:
            return None

    def consOr(self, data: Any, default: Any=None) -&gt; FStack:
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        If data is None, use default value to construct the new FStack, unless
        the default value is also None. In that case, just return the original
        FStack.
        &#34;&#34;&#34;
        if data is None:
            data = default
        stack = FStack()
        if data is not None:
            stack._head = _Node(data, self._head)
            stack._count = self._count + 1
        else:
            stack._head = self._head
            stack._count = self._count
        return stack

    def map(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

        Returns a new stack with new nodes. None values surpressed.
        &#34;&#34;&#34;
        return FStack(*map(f, reversed(self)))

    def flatMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Merge the stacks produced sequentially front-to-back.
        &#34;&#34;&#34;
        return FStack(*chain(
            *map(reversed, map(f, reversed(self)))
        ))

    def mergeMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until first cached stack is
        exhausted.
        &#34;&#34;&#34;
        return FStack(*merge(
            *map(reversed, map(f, reversed(self)))
        ))

    def exhaustMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until all the cached stacks are
        exhausted.
        &#34;&#34;&#34;
        return FStack(*exhaust(
            *map(reversed, map(f, reversed(self)))
        ))


if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grscheller.datastructures.stack.FStack"><code class="flex name class">
<span>class <span class="ident">FStack</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Class implementing an immutable singularly linked stack data
structure consisting of a singularly linked list of nodes. This class
designed to share nodes with other FStack instances.</p>
<p>Functional stacks are also immutable objects.</p>
<p>A functional stack points to either the top node in the list, or to None
which indicates an empty stack.</p>
<p>A functional stack has the count of the number of objects on it.</p>
<p>None represents the absence of a value and are ignored if pushed on the
stack. Use another object, like an empty tuple (), as a sentinal values.</p>
<p>Construct an immutable LIFO Stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FStack(Stack):
    &#34;&#34;&#34;Class implementing an immutable singularly linked stack data
    structure consisting of a singularly linked list of nodes. This class
    designed to share nodes with other FStack instances.

    Functional stacks are also immutable objects.

    A functional stack points to either the top node in the list, or to None
    which indicates an empty stack.

    A functional stack has the count of the number of objects on it.

    None represents the absence of a value and are ignored if pushed on the
    stack. Use another object, like an empty tuple (), as a sentinal values.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct an immutable LIFO Stack&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;| &#39; + &#39; &lt;- &#39;.join(reversed(CArray(*self).map(lambda x: repr(x)))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; FStack:
        &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        fstack = FStack()
        fstack._head = self._head
        fstack._count = self._count
        return fstack

    def head(self) -&gt; Any|None:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return None.
        &#34;&#34;&#34;
        if self._head is None:
            return None
        return self._head._data

    def headOr(self, default: Any) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return default value.
        &#34;&#34;&#34;
        value = self.head()
        if value is None:
            value = default
        return value

    def tail(self) -&gt; Stack|None:
        &#34;&#34;&#34;Return tail of the stack. Note, the tail of an empty stack does
        not exist, hence return None.
        &#34;&#34;&#34;
        stack = FStack()
        if self._head:
            stack._head = self._head._next
            stack._count = self._count - 1
            return stack
        return None

    def tailOr(self, default: FStack|None=None) -&gt; Stack:
        &#34;&#34;&#34;Return tail of the stack.

        Note: If stack is empty, return default value of type Stack.
              If default value not give, return a new empty stack.
        &#34;&#34;&#34;
        stack = self.tail()
        if stack is None:
            if default is None:
                stack = FStack()
            else:
                stack = default
        return stack

    def cons(self, data: Any) -&gt; FStack|None:
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        Constructing a stack using a non-existent value as
        head results in a non-existent stack.
        &#34;&#34;&#34;
        if data is not None:
            stack = FStack()
            stack._head = _Node(data, self._head)
            stack._count = self._count + 1
            return stack
        else:
            return None

    def consOr(self, data: Any, default: Any=None) -&gt; FStack:
        &#34;&#34;&#34;Return a new stack with data as head and self as tail.

        If data is None, use default value to construct the new FStack, unless
        the default value is also None. In that case, just return the original
        FStack.
        &#34;&#34;&#34;
        if data is None:
            data = default
        stack = FStack()
        if data is not None:
            stack._head = _Node(data, self._head)
            stack._count = self._count + 1
        else:
            stack._head = self._head
            stack._count = self._count
        return stack

    def map(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

        Returns a new stack with new nodes. None values surpressed.
        &#34;&#34;&#34;
        return FStack(*map(f, reversed(self)))

    def flatMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Merge the stacks produced sequentially front-to-back.
        &#34;&#34;&#34;
        return FStack(*chain(
            *map(reversed, map(f, reversed(self)))
        ))

    def mergeMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until first cached stack is
        exhausted.
        &#34;&#34;&#34;
        return FStack(*merge(
            *map(reversed, map(f, reversed(self)))
        ))

    def exhaustMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until all the cached stacks are
        exhausted.
        &#34;&#34;&#34;
        return FStack(*exhaust(
            *map(reversed, map(f, reversed(self)))
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.stack.Stack</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.stack.FStack.cons"><code class="name flex">
<span>def <span class="ident">cons</span></span>(<span>self, data:Â Any) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new stack with data as head and self as tail.</p>
<p>Constructing a stack using a non-existent value as
head results in a non-existent stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cons(self, data: Any) -&gt; FStack|None:
    &#34;&#34;&#34;Return a new stack with data as head and self as tail.

    Constructing a stack using a non-existent value as
    head results in a non-existent stack.
    &#34;&#34;&#34;
    if data is not None:
        stack = FStack()
        stack._head = _Node(data, self._head)
        stack._count = self._count + 1
        return stack
    else:
        return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.consOr"><code class="name flex">
<span>def <span class="ident">consOr</span></span>(<span>self, data:Â Any, default:Â AnyÂ =Â None) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a new stack with data as head and self as tail.</p>
<p>If data is None, use default value to construct the new FStack, unless
the default value is also None. In that case, just return the original
FStack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consOr(self, data: Any, default: Any=None) -&gt; FStack:
    &#34;&#34;&#34;Return a new stack with data as head and self as tail.

    If data is None, use default value to construct the new FStack, unless
    the default value is also None. In that case, just return the original
    FStack.
    &#34;&#34;&#34;
    if data is None:
        data = default
    stack = FStack()
    if data is not None:
        stack._head = _Node(data, self._head)
        stack._count = self._count + 1
    else:
        stack._head = self._head
        stack._count = self._count
    return stack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of a FStack in O(1) time &amp; space complexity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; FStack:
    &#34;&#34;&#34;Return shallow copy of a FStack in O(1) time &amp; space complexity&#34;&#34;&#34;
    fstack = FStack()
    fstack._head = self._head
    fstack._count = self._count
    return fstack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.exhaustMap"><code class="name flex">
<span>def <span class="ident">exhaustMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>]) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance</p>
<p>Round Robin Merge the stacks produced until all the cached stacks are
exhausted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exhaustMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance

    Round Robin Merge the stacks produced until all the cached stacks are
    exhausted.
    &#34;&#34;&#34;
    return FStack(*exhaust(
        *map(reversed, map(f, reversed(self)))
    ))</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.flatMap"><code class="name flex">
<span>def <span class="ident">flatMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>]) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance</p>
<p>Merge the stacks produced sequentially front-to-back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance

    Merge the stacks produced sequentially front-to-back.
    &#34;&#34;&#34;
    return FStack(*chain(
        *map(reversed, map(f, reversed(self)))
    ))</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the head of stack. Does not consume the data.</p>
<p>Note: If stack is empty, return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self) -&gt; Any|None:
    &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

    Note: If stack is empty, return None.
    &#34;&#34;&#34;
    if self._head is None:
        return None
    return self._head._data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.headOr"><code class="name flex">
<span>def <span class="ident">headOr</span></span>(<span>self, default:Â Any) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the head of stack. Does not consume the data.</p>
<p>Note: If stack is empty, return default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def headOr(self, default: Any) -&gt; Any:
    &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

    Note: If stack is empty, return default value.
    &#34;&#34;&#34;
    value = self.head()
    if value is None:
        value = default
    return value</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>]) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Maps a function (or callable object) over the values on the stack.</p>
<p>Returns a new stack with new nodes. None values surpressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[Any], FStack]) -&gt; FStack:
    &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

    Returns a new stack with new nodes. None values surpressed.
    &#34;&#34;&#34;
    return FStack(*map(f, reversed(self)))</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.mergeMap"><code class="name flex">
<span>def <span class="ident">mergeMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>]) â€‘>Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance</p>
<p>Round Robin Merge the stacks produced until first cached stack is
exhausted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeMap(self, f: Callable[[Any], FStack]) -&gt; FStack:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance

    Round Robin Merge the stacks produced until first cached stack is
    exhausted.
    &#34;&#34;&#34;
    return FStack(*merge(
        *map(reversed, map(f, reversed(self)))
    ))</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.tail"><code class="name flex">
<span>def <span class="ident">tail</span></span>(<span>self) â€‘>Â grscheller.datastructures.stack.StackÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Return tail of the stack. Note, the tail of an empty stack does
not exist, hence return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tail(self) -&gt; Stack|None:
    &#34;&#34;&#34;Return tail of the stack. Note, the tail of an empty stack does
    not exist, hence return None.
    &#34;&#34;&#34;
    stack = FStack()
    if self._head:
        stack._head = self._head._next
        stack._count = self._count - 1
        return stack
    return None</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.FStack.tailOr"><code class="name flex">
<span>def <span class="ident">tailOr</span></span>(<span>self, default:Â <a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a>Â |Â NoneÂ =Â None) â€‘>Â grscheller.datastructures.stack.Stack</span>
</code></dt>
<dd>
<div class="desc"><p>Return tail of the stack.</p>
<p>Note: If stack is empty, return default value of type Stack.
If default value not give, return a new empty stack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tailOr(self, default: FStack|None=None) -&gt; Stack:
    &#34;&#34;&#34;Return tail of the stack.

    Note: If stack is empty, return default value of type Stack.
          If default value not give, return a new empty stack.
    &#34;&#34;&#34;
    stack = self.tail()
    if stack is None:
        if default is None:
            stack = FStack()
        else:
            stack = default
    return stack</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grscheller.datastructures.stack.PStack"><code class="flex name class">
<span>class <span class="ident">PStack</span></span>
<span>(</span><span>*ds)</span>
</code></dt>
<dd>
<div class="desc"><p>Class implementing a Last In, First Out (LIFO) stack data structure. The
stack contains a singularly linked list of nodes. Class designed to share
nodes with other PStack instances.</p>
<p>PStacks are stateful objects where values can be pushed on &amp; popped off.</p>
<p>A stack points to either the top node of a singlely linked list, or to
None which indicates an empty stack.</p>
<p>A stack keeps a count of the number of objects currently on it.</p>
<p>None represents the absence of a value and are ignored if pushed on the
stack. Use another object, like an empty tuple (), as a sentinal value.</p>
<p>Construct a stateful LIFO Stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PStack(Stack):
    &#34;&#34;&#34;Class implementing a Last In, First Out (LIFO) stack data structure. The
    stack contains a singularly linked list of nodes. Class designed to share
    nodes with other PStack instances.

    PStacks are stateful objects where values can be pushed on &amp; popped off.

    A stack points to either the top node of a singlely linked list, or to
    None which indicates an empty stack.

    A stack keeps a count of the number of objects currently on it.

    None represents the absence of a value and are ignored if pushed on the
    stack. Use another object, like an empty tuple (), as a sentinal value.
    &#34;&#34;&#34;
    def __init__(self, *ds):
        &#34;&#34;&#34;Construct a stateful LIFO Stack&#34;&#34;&#34;
        super().__init__(*ds)

    def __repr__(self):
        &#34;&#34;&#34;Display the data in the stack, left to right starting at bottom&#34;&#34;&#34;
        return &#39;|| &#39; + &#39; &lt;- &#39;.join(reversed(CArray(*self).map(lambda x: repr(x)))) + &#39; &gt;&lt;&#39;

    def copy(self) -&gt; PStack:
        &#34;&#34;&#34;Return shallow copy of a PStack in O(1) time &amp; space complexity&#34;&#34;&#34;
        pstack = PStack()
        pstack._head = self._head
        pstack._count = self._count
        return pstack

    def push(self, *ds: Any) -&gt; Self:
        &#34;&#34;&#34;Push data that is not NONE onto top of stack,
        return the stack being pushed.
        &#34;&#34;&#34;
        for d in ds:
            if d is not None:
                node = _Node(d, self._head)
                self._head = node
                self._count += 1
        return self

    def pop(self) -&gt; Any|None:
        &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
        if self._head is None:
            return None
        else:
            data = self._head._data
            self._head = self._head._next
            self._count -= 1
            return data

    def peak(self) -&gt; Any|None:
        &#34;&#34;&#34;Returns the data at the top of stack. Does not consume the data.

        Note: If stack is empty, return None.
        &#34;&#34;&#34;
        if self._head is None:
            return None
        return self._head._data

    def peakOr(self, default: Any) -&gt; Any:
        &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

        Note: If stack is empty, return default value.
        &#34;&#34;&#34;
        value = self.peak()
        if value is None:
            value = default
        return value

    def map(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

        Returns a new stack with new nodes.  None values surpressed.
        &#34;&#34;&#34;
        newPStack = PStack(*map(f, reversed(self)))
        self._head = newPStack._head
        self._count = newPStack._count

    def flatMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance.

        Merge the stacks produced sequentially front-to-back.
        &#34;&#34;&#34;
        newPStack = PStack(*chain(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count

    def mergeMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance.

        Round Robin Merge the stacks produced until first cached stack is
        exhausted.
        &#34;&#34;&#34;
        newPStack = PStack(*merge(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count

    def exhaustMap(self, f: Callable[[Any], PStack]) -&gt; None:
        &#34;&#34;&#34;Apply function and flatten result, returns new instance

        Round Robin Merge the stacks produced until all the cached stacks are
        exhausted.
        &#34;&#34;&#34;
        newPStack = PStack(*exhaust(
            *map(reversed, map(f, reversed(self)))
        ))
        self._head = newPStack._head
        self._count = newPStack._count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>grscheller.datastructures.stack.Stack</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="grscheller.datastructures.stack.PStack.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return shallow copy of a PStack in O(1) time &amp; space complexity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; PStack:
    &#34;&#34;&#34;Return shallow copy of a PStack in O(1) time &amp; space complexity&#34;&#34;&#34;
    pstack = PStack()
    pstack._head = self._head
    pstack._count = self._count
    return pstack</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.exhaustMap"><code class="name flex">
<span>def <span class="ident">exhaustMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a>]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance</p>
<p>Round Robin Merge the stacks produced until all the cached stacks are
exhausted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exhaustMap(self, f: Callable[[Any], PStack]) -&gt; None:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance

    Round Robin Merge the stacks produced until all the cached stacks are
    exhausted.
    &#34;&#34;&#34;
    newPStack = PStack(*exhaust(
        *map(reversed, map(f, reversed(self)))
    ))
    self._head = newPStack._head
    self._count = newPStack._count</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.flatMap"><code class="name flex">
<span>def <span class="ident">flatMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a>]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance.</p>
<p>Merge the stacks produced sequentially front-to-back.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatMap(self, f: Callable[[Any], PStack]) -&gt; None:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance.

    Merge the stacks produced sequentially front-to-back.
    &#34;&#34;&#34;
    newPStack = PStack(*chain(
        *map(reversed, map(f, reversed(self)))
    ))
    self._head = newPStack._head
    self._count = newPStack._count</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a>]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Maps a function (or callable object) over the values on the stack.</p>
<p>Returns a new stack with new nodes.
None values surpressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f: Callable[[Any], PStack]) -&gt; None:
    &#34;&#34;&#34;Maps a function (or callable object) over the values on the stack.

    Returns a new stack with new nodes.  None values surpressed.
    &#34;&#34;&#34;
    newPStack = PStack(*map(f, reversed(self)))
    self._head = newPStack._head
    self._count = newPStack._count</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.mergeMap"><code class="name flex">
<span>def <span class="ident">mergeMap</span></span>(<span>self, f:Â Callable[[Any],Â <a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a>]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function and flatten result, returns new instance.</p>
<p>Round Robin Merge the stacks produced until first cached stack is
exhausted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mergeMap(self, f: Callable[[Any], PStack]) -&gt; None:
    &#34;&#34;&#34;Apply function and flatten result, returns new instance.

    Round Robin Merge the stacks produced until first cached stack is
    exhausted.
    &#34;&#34;&#34;
    newPStack = PStack(*merge(
        *map(reversed, map(f, reversed(self)))
    ))
    self._head = newPStack._head
    self._count = newPStack._count</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the top of stack. Does not consume the data.</p>
<p>Note: If stack is empty, return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak(self) -&gt; Any|None:
    &#34;&#34;&#34;Returns the data at the top of stack. Does not consume the data.

    Note: If stack is empty, return None.
    &#34;&#34;&#34;
    if self._head is None:
        return None
    return self._head._data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.peakOr"><code class="name flex">
<span>def <span class="ident">peakOr</span></span>(<span>self, default:Â Any) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the data at the head of stack. Does not consume the data.</p>
<p>Note: If stack is empty, return default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peakOr(self, default: Any) -&gt; Any:
    &#34;&#34;&#34;Returns the data at the head of stack. Does not consume the data.

    Note: If stack is empty, return default value.
    &#34;&#34;&#34;
    value = self.peak()
    if value is None:
        value = default
    return value</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self) â€‘>Â typing.AnyÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Pop data off of top of stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self) -&gt; Any|None:
    &#34;&#34;&#34;Pop data off of top of stack&#34;&#34;&#34;
    if self._head is None:
        return None
    else:
        data = self._head._data
        self._head = self._head._next
        self._count -= 1
        return data</code></pre>
</details>
</dd>
<dt id="grscheller.datastructures.stack.PStack.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, *ds:Â Any) â€‘>Â Self</span>
</code></dt>
<dd>
<div class="desc"><p>Push data that is not NONE onto top of stack,
return the stack being pushed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, *ds: Any) -&gt; Self:
    &#34;&#34;&#34;Push data that is not NONE onto top of stack,
    return the stack being pushed.
    &#34;&#34;&#34;
    for d in ds:
        if d is not None:
            node = _Node(d, self._head)
            self._head = node
            self._count += 1
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="grscheller.datastructures" href="index.html">grscheller.datastructures</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grscheller.datastructures.stack.FStack" href="#grscheller.datastructures.stack.FStack">FStack</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.stack.FStack.cons" href="#grscheller.datastructures.stack.FStack.cons">cons</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.consOr" href="#grscheller.datastructures.stack.FStack.consOr">consOr</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.copy" href="#grscheller.datastructures.stack.FStack.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.exhaustMap" href="#grscheller.datastructures.stack.FStack.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.flatMap" href="#grscheller.datastructures.stack.FStack.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.head" href="#grscheller.datastructures.stack.FStack.head">head</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.headOr" href="#grscheller.datastructures.stack.FStack.headOr">headOr</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.map" href="#grscheller.datastructures.stack.FStack.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.mergeMap" href="#grscheller.datastructures.stack.FStack.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.tail" href="#grscheller.datastructures.stack.FStack.tail">tail</a></code></li>
<li><code><a title="grscheller.datastructures.stack.FStack.tailOr" href="#grscheller.datastructures.stack.FStack.tailOr">tailOr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grscheller.datastructures.stack.PStack" href="#grscheller.datastructures.stack.PStack">PStack</a></code></h4>
<ul class="two-column">
<li><code><a title="grscheller.datastructures.stack.PStack.copy" href="#grscheller.datastructures.stack.PStack.copy">copy</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.exhaustMap" href="#grscheller.datastructures.stack.PStack.exhaustMap">exhaustMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.flatMap" href="#grscheller.datastructures.stack.PStack.flatMap">flatMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.map" href="#grscheller.datastructures.stack.PStack.map">map</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.mergeMap" href="#grscheller.datastructures.stack.PStack.mergeMap">mergeMap</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.peak" href="#grscheller.datastructures.stack.PStack.peak">peak</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.peakOr" href="#grscheller.datastructures.stack.PStack.peakOr">peakOr</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.pop" href="#grscheller.datastructures.stack.PStack.pop">pop</a></code></li>
<li><code><a title="grscheller.datastructures.stack.PStack.push" href="#grscheller.datastructures.stack.PStack.push">push</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
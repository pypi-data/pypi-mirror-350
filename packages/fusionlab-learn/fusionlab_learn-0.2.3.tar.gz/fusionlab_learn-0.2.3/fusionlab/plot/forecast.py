# -*- coding: utf‑8 -*-
# License: BSD‑3‑Clause
# Author: LKouadio <etanoyau@gmail.com>

"""
Convenience helpers for **quick‑look** visual inspection of model
forecasts.
"""

from __future__ import annotations

import warnings
from typing import Any, List, Optional, Tuple, Union

import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from ..core.checks import ( 
    check_non_emptiness, 
    check_spatial_columns, 
    is_in_if
)
from ..core.handlers import columns_manager
from ..utils.generic_utils import ( 
    get_actual_column_name,
    vlog
)
from ..utils.ts_utils import filter_by_period
from ..utils.validator import assert_xy_in, is_frame

__all__= ["plot_forecasts", "visualize_forecasts"]


@check_non_emptiness 
def plot_forecasts(
    forecast_df: pd.DataFrame,
    target_name: str = "target",
    quantiles: Optional[List[float]] = None,
    output_dim: int = 1,
    kind: str = "temporal",
    actual_data: Optional[pd.DataFrame] = None,
    dt_col: Optional[str] = None,
    actual_target_name: Optional[str] = None,
    sample_ids: Optional[Union[int, List[int], str]] = "first_n",
    num_samples: int = 3,
    horizon_steps: Optional[Union[int, List[int]]] = 1,
    spatial_cols: Optional[List[str]] = None,
    max_cols: int = 2,
    figsize: Tuple[float, float] = (8, 4.5), 
    scaler: Optional[Any] = None,
    scaler_feature_names: Optional[List[str]] = None,
    target_idx_in_scaler: Optional[int] = None,
    titles: Optional[List[str]] = None,
    verbose: int = 0,
    **plot_kwargs: Any
    ) -> None:
    """
    Visualizes model forecasts from a structured DataFrame.
    
    This function generates plots to visualize time series forecasts,
    supporting temporal line plots for individual samples/items and
    spatial scatter plots for specific forecast horizons. It can
    handle point forecasts and quantile (probabilistic) forecasts,
    optionally overlaying actual values for comparison. Predictions
    and actuals can be inverse-transformed if a scaler is provided.
    
    The input `forecast_df` is expected to be in a long format, typically
    generated by :func:`~fusionlab.nn.utils.format_predictions_to_dataframe`,
    containing 'sample_idx' and 'forecast_step' columns, along with
    prediction columns (e.g., '{target_name}_pred',
    '{target_name}_q50') and optionally actual value columns
    (e.g., '{target_name}_actual').
    
    Parameters
    ----------
    forecast_df : pd.DataFrame
        A pandas DataFrame containing the forecast data in long format.
        Must include 'sample_idx' and 'forecast_step' columns,
        along with prediction columns (and optionally actuals and
        spatial coordinate columns).
    target_name : str, default "target"
        The base name of the target variable. This is used to
        construct column names for predictions and actuals (e.g.,
        "target_pred", "target_q50", "target_actual").
    quantiles : List[float], optional
        A list of quantiles that were predicted (e.g., `[0.1, 0.5, 0.9]`).
        If provided, the function will plot the median quantile as a line
        and the range between the first and last quantile as a shaded
        uncertainty interval (for temporal plots). If ``None``, a point
        forecast is assumed. Default is ``None``.
    output_dim : int, default 1
        The number of target variables (output dimensions) predicted
        at each time step. If > 1, separate subplots or plot groups
        may be generated for each output dimension.
    kind : {'temporal', 'spatial'}, default "temporal"
        The type of plot to generate:
        - ``'temporal'``: Plots forecasts over the horizon for selected
          samples (time series line plots).
        - ``'spatial'``: Creates scatter plots of forecast values over
          spatial coordinates for selected horizon steps. Requires
          `spatial_cols` to be specified.
    actual_data : pd.DataFrame, optional
        An optional DataFrame containing the true actual values for
        comparison. If `forecast_df` already contains actual value
        columns (e.g., '{target_name}_actual'), this may not be needed
        or can be used to supplement. If provided, `dt_col` and
        `actual_target_name` might be used for alignment or direct plotting.
        *Note: Current implementation primarily uses actuals from `forecast_df`.*
    dt_col : str, optional
        Name of the datetime column in `actual_data` or `forecast_df`
        if needed for x-axis labeling in temporal plots. If `forecast_df`
        uses 'forecast_step', this might be less critical unless aligning
        with a true date axis from `actual_data`.
    actual_target_name : str, optional
        The name of the target column in `actual_data` if it differs
        from `target_name`. If ``None``, `target_name` is assumed.
    sample_ids : int, List[int], str, default "first_n"
        Specifies which samples (based on 'sample_idx' in `forecast_df`)
        to plot for `kind='temporal'`.
        - If `int`: Plots the sample at that specific index.
        - If `List[int]`: Plots all samples with these indices.
        - If ``"first_n"``: Plots the first `num_samples`.
        - If ``"all"``: Plots all unique samples (can be many plots).
    num_samples : int, default 3
        Number of samples to plot if `sample_ids="first_n"`.
    horizon_steps : int, List[int], str, default 1
        Specifies which forecast horizon step(s) to plot for
        `kind='spatial'`.
        - If `int`: Plots the specified single step (1-indexed).
        - If `List[int]`: Plots all specified steps.
        - If ``"all"`` or ``None``: Plots all unique forecast steps available.
    spatial_cols : List[str], optional
        Required if `kind='spatial'`. A list of two column names
        from `forecast_df` representing the x and y spatial
        coordinates (e.g., `['longitude', 'latitude']`).
        Default is ``None``.
    max_cols : int, default 2
        Maximum number of subplots to arrange per row in the figure.
    figsize : Tuple[float, float], default (8, 4.5)
        The size `(width, height)` in inches for **each subplot**.
        The total figure size will be inferred based on the number
        of rows and columns of subplots.
    scaler : Any, optional
        A fitted scikit-learn-like scaler object (must have an
        `inverse_transform` method). If provided along with
        `scaler_feature_names` and `target_idx_in_scaler`,
        prediction and actual columns related to `target_name`
        will be inverse-transformed before plotting. Default is ``None``.
    scaler_feature_names : List[str], optional
        A list of all feature names (in order) that the `scaler` was
        originally fit on. Required for targeted inverse transform if
        `scaler` is provided. Default is ``None``.
    target_idx_in_scaler : int, optional
        The index of the `target_name` (or the specific output
        dimension being plotted) within the `scaler_feature_names`
        list. Required for targeted inverse transform if `scaler` is
        provided. Default is ``None``.
    titles : List[str], optional
        A list of custom titles for the subplots. If provided, its
        length should match the number of subplots generated.
        Default is ``None`` (titles are auto-generated).
    verbose : int, default 0
        Verbosity level for logging during plot generation.
        - ``0``: Silent.
        - ``1`` or higher: Print informational messages.
    **plot_kwargs : Any
        Additional keyword arguments to pass to the underlying
        Matplotlib plotting functions (e.g., `ax.plot`, `ax.scatter`,
        `ax.fill_between`). Can be used to customize line styles,
        colors, marker sizes, etc. For example,
        `median_plot_kwargs={'color': 'blue'}`,
        `fill_between_kwargs={'color': 'lightblue'}`.
    
    Returns
    -------
    None
        This function directly generates and shows/saves plots using
        Matplotlib and does not return any value.
    
    Raises
    ------
    TypeError
        If `forecast_df` is not a pandas DataFrame.
    ValueError
        If essential columns like 'sample_idx' or 'forecast_step'
        are missing from `forecast_df`.
        If `kind='spatial'` is chosen but `spatial_cols` are not
        provided or not found in `forecast_df`.
        If an unsupported `kind` is specified.
    
    See Also
    --------
    fusionlab.nn.utils.format_predictions_to_dataframe :
        Utility to generate the `forecast_df` expected by this function.
    matplotlib.pyplot.plot : Underlying plotting function for temporal forecasts.
    matplotlib.pyplot.scatter : Underlying plotting function for spatial forecasts.
    
    Examples
    --------
    >>> from fusionlab.nn.utils import format_predictions_to_dataframe
    >>> from fusionlab.plot.forecast import visualize_forecasts
    >>> import pandas as pd
    >>> import numpy as np
    
    >>> # Assume preds_point (B,H,O) and preds_quant (B,H,Q) are available
    >>> B, H, O, Q_len = 4, 3, 1, 3
    >>> preds_point = np.random.rand(B, H, O)
    >>> preds_quant = np.random.rand(B, H, Q_len)
    >>> y_true_seq = np.random.rand(B, H, O)
    >>> quantiles_list = [0.1, 0.5, 0.9]
    
    >>> # Create DataFrames using format_predictions_to_dataframe
    >>> df_point = format_predictions_to_dataframe(
    ...     predictions=preds_point, y_true_sequences=y_true_seq,
    ...     target_name="value", forecast_horizon=H, output_dim=O
    ... )
    >>> df_quant = format_predictions_to_dataframe(
    ...     predictions=preds_quant, y_true_sequences=y_true_seq,
    ...     target_name="value", quantiles=quantiles_list,
    ...     forecast_horizon=H, output_dim=O
    ... )
    
    >>> # Example 1: Plot temporal point forecast for first sample
    >>> # plot_forecasts(df_point, target_name="value", sample_ids=0)
    
    >>> # Example 2: Plot temporal quantile forecast for first 2 samples
    >>> # plot_forecasts(df_quant, target_name="value",
    ... #                quantiles=quantiles_list, sample_ids="first_n",
    ... #                num_samples=2, max_cols=1)
    
    >>> # Example 3: Spatial plot (requires spatial_cols in df_quant)
    >>> # Assume df_quant has 'lon' and 'lat' columns
    >>> # df_quant['lon'] = np.random.rand(len(df_quant)) * 10
    >>> # df_quant['lat'] = np.random.rand(len(df_quant)) * 5
    >>> # plot_forecasts(df_quant, target_name="value",
    ... #                quantiles=quantiles_list, kind='spatial',
    ... #                horizon_steps=1, spatial_cols=['lon', 'lat'])
    """

    vlog(f"Starting forecast visualization (kind='{kind}')...",
         level=3, verbose=verbose)

    if not isinstance(forecast_df, pd.DataFrame):
        raise TypeError("`forecast_df` must be a pandas DataFrame, typically "
                        "the output of `format_predictions_to_dataframe`.")

    if 'sample_idx' not in forecast_df.columns or \
       'forecast_step' not in forecast_df.columns:
        raise ValueError(
            "`forecast_df` must contain 'sample_idx' and 'forecast_step' "
            "columns."
        )

    # --- Data Preparation & Inverse Transform ---
    # Work on a copy to avoid modifying the original DataFrame
    df_to_plot = forecast_df.copy()
    actual_col_names_in_df = [] # To store names of actual columns in df_to_plot
    pred_col_names_in_df = []   # To store names of prediction columns

    # Identify prediction and actual columns based on target_name and quantiles
    base_pred_name = target_name
    base_actual_name = actual_target_name if actual_target_name \
        else target_name

    if quantiles:
        # Sort quantiles to ensure consistent order for plotting (e.g., low, mid, high)
        sorted_quantiles = sorted([float(q) for q in quantiles])
        for o_idx in range(output_dim):
            for q_val in sorted_quantiles:
                q_suffix = f"_q{int(q_val*100)}"
                col_name = f"{base_pred_name}"
                if output_dim > 1: col_name += f"_{o_idx}"
                col_name += q_suffix
                if col_name in df_to_plot.columns:
                    pred_col_names_in_df.append(col_name)
            # Actual column for this output dimension
            actual_col = f"{base_actual_name}"
            if output_dim > 1: actual_col += f"_{o_idx}"
            actual_col += "_actual"
            if actual_col in df_to_plot.columns:
                actual_col_names_in_df.append(actual_col)
    else: # Point forecast
        for o_idx in range(output_dim):
            col_name = f"{base_pred_name}"
            if output_dim > 1: col_name += f"_{o_idx}"
            col_name += "_pred"
            if col_name in df_to_plot.columns:
                pred_col_names_in_df.append(col_name)
            actual_col = f"{base_actual_name}"
            if output_dim > 1: actual_col += f"_{o_idx}"
            actual_col += "_actual"
            if actual_col in df_to_plot.columns:
                actual_col_names_in_df.append(actual_col)

    if not pred_col_names_in_df:
        warnings.warn("No prediction columns found in `forecast_df` "
                      "based on `target_name` and `quantiles`.")
        # Attempt to find any column ending with _pred or _qXX
        pred_cols_found = [c for c in df_to_plot.columns if "_pred" in c or "_q" in c]
        if pred_cols_found:
            pred_col_names_in_df = pred_cols_found
            vlog(f"  Auto-detected prediction columns: {pred_col_names_in_df}",
                 level=2, verbose=verbose)
        else:
            vlog("  No prediction columns could be auto-detected. "
                 "Plotting may be limited.", level=2, verbose=verbose)

    # Apply inverse transform if scaler is provided
    if scaler is not None:
        if scaler_feature_names is None or target_idx_in_scaler is None:
            warnings.warn(
                "Scaler provided, but `scaler_feature_names` or "
                "`target_idx_in_scaler` is missing. Inverse transform "
                "cannot be applied correctly to specific target columns.",
                UserWarning
            )
        else:
            vlog("  Applying inverse transformation using provided scaler...",
                 level=4, verbose=verbose)
            cols_to_inverse_transform = pred_col_names_in_df + actual_col_names_in_df
            dummy_array_shape = (len(df_to_plot), len(scaler_feature_names))

            for col_to_inv in cols_to_inverse_transform:
                if col_to_inv in df_to_plot.columns:
                    try:
                        dummy = np.zeros(dummy_array_shape)
                        dummy[:, target_idx_in_scaler] = df_to_plot[col_to_inv]
                        df_to_plot[col_to_inv] = scaler.inverse_transform(
                            dummy
                            )[:, target_idx_in_scaler]
                    except Exception as e:
                        warnings.warn(
                            f"Failed to inverse transform column '{col_to_inv}'. "
                            f"Plotting scaled value. Error: {e}"
                            )
            vlog("    Inverse transformation applied.", level=5, verbose=verbose)

    # --- Select Samples/Items to Plot ---
    unique_sample_ids = df_to_plot['sample_idx'].unique()
    selected_ids_for_plot = []
    if isinstance(sample_ids, str):
        if sample_ids.lower() == "all":
            selected_ids_for_plot = unique_sample_ids
        elif sample_ids.lower() == "first_n":
            selected_ids_for_plot = unique_sample_ids[:num_samples]
        else:
            warnings.warn(f"Unknown string for `sample_ids`: "
                          f"'{sample_ids}'. Plotting first sample.")
            selected_ids_for_plot = unique_sample_ids[:1]
    elif isinstance(sample_ids, int):
        if sample_ids < len(unique_sample_ids):
            selected_ids_for_plot = [unique_sample_ids[sample_ids]]
        else:
            warnings.warn(f"sample_idx {sample_ids} out of range. "
                          "Plotting first sample.")
            selected_ids_for_plot = unique_sample_ids[:1]
    elif isinstance(sample_ids, list):
        selected_ids_for_plot = [
            sid for sid in sample_ids if sid in unique_sample_ids
            ]
    if len(selected_ids_for_plot) ==0:
        vlog("No valid sample_idx found to plot. Defaulting to first available.",
             level=2, verbose=verbose)
        selected_ids_for_plot = unique_sample_ids[:1]
    if len(selected_ids_for_plot) ==0 : # check if is empty
        vlog ("No sample to plot. Returning ...", level =1, verbose=verbose)
        return

    vlog(f"  Plotting for sample_idx: {selected_ids_for_plot}",
         level=4, verbose=verbose)

    # --- Plotting Logic ---
    if kind == "temporal":
        num_plots = len(selected_ids_for_plot) * output_dim
        if num_plots == 0:
            vlog("No data to plot for temporal type.", level=2, verbose=verbose)
            return

        n_cols_plot = min(max_cols, num_plots)
        n_rows_plot = (num_plots + n_cols_plot - 1) // n_cols_plot

        fig, axes = plt.subplots(
            n_rows_plot, n_cols_plot,
            figsize=(n_cols_plot * figsize[0],
                     n_rows_plot * figsize[1]),
            squeeze=False # Always return 2D array for axes
        )
        axes_flat = axes.flatten()
        plot_idx = 0

        for s_idx in selected_ids_for_plot:
            sample_df = df_to_plot[df_to_plot['sample_idx'] == s_idx]
            if sample_df.empty:
                continue

            for o_idx in range(output_dim):
                if plot_idx >= len(axes_flat): break # Should not happen
                ax = axes_flat[plot_idx]

                title = f"Sample ID: {s_idx}"
                if output_dim > 1:
                    title += f", Target Dim: {o_idx}"
                if titles and plot_idx < len(titles):
                    title = titles[plot_idx]
                ax.set_title(title)

                # Plot actuals if available
                actual_col = f"{base_actual_name}"
                if output_dim > 1: actual_col += f"_{o_idx}"
                actual_col += "_actual"
                if actual_col in sample_df.columns:
                    ax.plot(
                        sample_df['forecast_step'], sample_df[actual_col],
                        label=f'Actual {target_name}'
                              f'{f"_{o_idx}" if output_dim > 1 else ""}',
                        marker='o', linestyle='--'
                    )

                # Plot predictions
                if quantiles:
                    median_q_val = 0.5
                    if 0.5 not in quantiles: # Find closest if 0.5 not present
                        median_q_val = quantiles[len(quantiles) // 2]

                    median_col = f"{base_pred_name}"
                    if output_dim > 1: median_col += f"_{o_idx}"
                    median_col += f"_q{int(median_q_val*100)}"

                    lower_q_col = f"{base_pred_name}"
                    if output_dim > 1: lower_q_col += f"_{o_idx}"
                    lower_q_col += f"_q{int(sorted_quantiles[0]*100)}"

                    upper_q_col = f"{base_pred_name}"
                    if output_dim > 1: upper_q_col += f"_{o_idx}"
                    upper_q_col += f"_q{int(sorted_quantiles[-1]*100)}"

                    if median_col in sample_df.columns:
                        ax.plot(
                            sample_df['forecast_step'], sample_df[median_col],
                            label=f'Median (q{int(median_q_val*100)})',
                            marker='x',
                            **plot_kwargs.get("median_plot_kwargs", {})
                        )
                    if lower_q_col in sample_df.columns and \
                       upper_q_col in sample_df.columns:
                        ax.fill_between(
                            sample_df['forecast_step'],
                            sample_df[lower_q_col],
                            sample_df[upper_q_col],
                            color='gray', alpha=0.3,
                            label=f'Interval (q{int(sorted_quantiles[0]*100)}'
                                  f'-q{int(sorted_quantiles[-1]*100)})',
                            **plot_kwargs.get("fill_between_kwargs", {})
                        )
                else: # Point forecast
                    pred_col = f"{base_pred_name}"
                    if output_dim > 1: pred_col += f"_{o_idx}"
                    pred_col += "_pred"
                    if pred_col in sample_df.columns:
                        ax.plot(
                            sample_df['forecast_step'], sample_df[pred_col],
                            label=f'Predicted {target_name}'
                                  f'{f"_{o_idx}" if output_dim > 1 else ""}',
                            marker='x',
                            **plot_kwargs.get("point_plot_kwargs", {})
                        )
                ax.set_xlabel("Forecast Step into Horizon")
                ax.set_ylabel(
                    f"{target_name}{f' (Dim {o_idx})' if output_dim > 1 else ''}"
                    )
                ax.legend()
                ax.grid(True)
                plot_idx += 1

        # Hide unused subplots
        for i in range(plot_idx, len(axes_flat)):
            axes_flat[i].set_visible(False)
        fig.tight_layout()
        plt.show()

    elif kind == "spatial":
        
        spatial_x_col = None 
        spatial_y_col =None 
        
        if spatial_cols is not None:
            spatial_cols = columns_manager (spatial_cols, empty_as_none=False)
            if len(spatial_cols )!=2: 
                raise ValueError(
                    "Spatial_cols need exactly two columns (e.g., longitude,"
                    f" latitude ). Got {spatial_cols}")
                
            spatial_x_col , spatial_y_col = spatial_cols 
    
        if spatial_x_col is None or spatial_y_col is None:
            raise ValueError(
                "`spatial_x_col` and `spatial_y_col` must be provided "
                "for `kind='spatial'`."
            )
        if spatial_x_col not in df_to_plot.columns or \
           spatial_y_col not in df_to_plot.columns:
            raise ValueError(
                f"Spatial columns '{spatial_x_col}' or '{spatial_y_col}' "
                "not found in forecast_df."
            )

        steps_to_plot = []
        if isinstance(horizon_steps, int):
            steps_to_plot = [horizon_steps]
        elif isinstance(horizon_steps, list):
            steps_to_plot = horizon_steps
        elif horizon_steps is None or \
             str(horizon_steps).lower() == "all":
            # Plot all unique forecast steps present in the data
            steps_to_plot = sorted(df_to_plot['forecast_step'].unique())
        else:
            raise ValueError("Invalid `horizon_steps`.")

        num_plots = len(steps_to_plot) * output_dim
        if num_plots == 0:
            vlog("No data/steps to plot for spatial type.",
                 level=2, verbose=verbose)
            return

        n_cols_plot = min(max_cols, num_plots)
        n_rows_plot = (num_plots + n_cols_plot - 1) // n_cols_plot

        fig, axes = plt.subplots(
            n_rows_plot, n_cols_plot,
            figsize=(n_cols_plot * figsize[0],
                     n_rows_plot * figsize[1]),
            squeeze=False
        )
        axes_flat = axes.flatten()
        plot_idx = 0

        for step in steps_to_plot:
            step_df = df_to_plot[df_to_plot['forecast_step'] == step]
            if step_df.empty:
                continue
            for o_idx in range(output_dim):
                if plot_idx >= len(axes_flat): break
                ax = axes_flat[plot_idx]

                # Determine column to use for color intensity
                color_col = None
                plot_title_suffix = ""
                if quantiles: # Use median for color
                    median_q_val = 0.5
                    if 0.5 not in quantiles:
                        median_q_val = quantiles[len(quantiles) // 2]
                    color_col = f"{base_pred_name}"
                    if output_dim > 1: color_col += f"_{o_idx}"
                    color_col += f"_q{int(median_q_val*100)}"
                    plot_title_suffix = f" (Median q{int(median_q_val*100)})"
                else: # Point forecast
                    color_col = f"{base_pred_name}"
                    if output_dim > 1: color_col += f"_{o_idx}"
                    color_col += "_pred"

                if color_col not in step_df.columns:
                    warnings.warn(f"Color column '{color_col}' not found "
                                  "for spatial plot. Skipping subplot.")
                    plot_idx +=1 # Increment to avoid reusing subplot
                    continue

                scatter_data = step_df.dropna(
                    subset=[spatial_x_col, spatial_y_col, color_col]
                    )
                if scatter_data.empty:
                    warnings.warn(f"No valid data to plot for step {step}, "
                                  f"output_dim {o_idx} after dropna. Skipping.")
                    plot_idx += 1
                    continue

                # Normalize color data for better visualization
                norm = mcolors.Normalize(
                    vmin=scatter_data[color_col].min(),
                    vmax=scatter_data[color_col].max()
                    )
                cmap = plot_kwargs.get('cmap', 'viridis')

                sc = ax.scatter(
                    scatter_data[spatial_x_col], scatter_data[spatial_y_col],
                    c=scatter_data[color_col], cmap=cmap, norm=norm,
                    s=plot_kwargs.get('s', 50), # Marker size
                    alpha=plot_kwargs.get('alpha', 0.7)
                )
                fig.colorbar(sc, ax=ax, label=f"{target_name}{plot_title_suffix}")
                title = f"Forecast Step: {step}"
                if output_dim > 1: title += f", Target Dim: {o_idx}"
                ax.set_title(title)
                ax.set_xlabel(spatial_x_col)
                ax.set_ylabel(spatial_y_col)
                ax.grid(True)
                plot_idx += 1
        
        for i in range(plot_idx, len(axes_flat)):
            axes_flat[i].set_visible(False)
        fig.tight_layout()
        plt.show()

    else:
        raise ValueError(
            f"Unsupported `kind`: '{kind}'. "
            "Choose 'temporal' or 'spatial'."
            )
    vlog("Forecast visualization complete.", level=3, verbose=verbose)
    

@check_non_emptiness
def visualize_forecasts(
    forecast_df,
    dt_col,
    tname,
    test_data=None,
    eval_periods=None,      
    mode="quantile",       
    kind="spatial", 
    actual_name=None,        
    x=None,                
    y=None,                
    cmap="coolwarm",       
    max_cols=3, 
    axis="on",  
    s=2, 
    show_grid=True,
    grid_props=None,           
    verbose=1,
    **kw
):
    r"""
    Visualize forecast results and actual test data for one or more
    evaluation periods.

    The function plots a grid of scatter plots comparing actual values
    with forecasted predictions. Each evaluation period yields two plots:
    one for actual values and one for predicted values. If multiple
    evaluation periods are provided, the grid layout wraps after
    ``max_cols`` columns.

    .. math::

       \hat{y}_{t+i} = f\Bigl(
       X_{\text{static}},\;X_{\text{dynamic}},\;
       X_{\text{future}}\Bigr)

    for :math:`i = 1, \dots, N`, where :math:`N` is the forecast horizon.

    Parameters
    ----------
    forecast_df : pandas.DataFrame
        DataFrame containing forecast results with a time column,
        spatial coordinates, and prediction columns.
    dt_col      : str
        Name of the time column used to filter forecast results (e.g.
        ``"year"``).
    tname : str
        Target variable name used to construct forecast columns (e.g.
        ``"subsidence"``). This argument is required.
        
        
    eval_periods : scalar or list, optional
        Evaluation period(s) used to select forecast results. If set to
        ``None``, the function selects up to three unique periods from
        ``test_data[dt_col]``.
    mode        : str, optional
        Forecast mode. Must be either ``"quantile"`` or ``"point"``.
        Default is ``"quantile"``.
    kind        : str, optional
        Type of visualization. If ``"spatial"``, spatial columns are
        required; otherwise, the provided `x` and `y` columns are used.
    x : str, optional
        Column name for the x-axis. For non-spatial plots, this must be
        provided or will be inferred via ``assert_xy_in``.
    y : str, optional
        Column name for the y-axis. For non-spatial plots, this must be
        provided or will be inferred via ``assert_xy_in``.
    cmap : str, optional
        Colormap used for scatter plots. Default is ``"coolwarm"``.
    max_cols : int, optional
        Maximum number of evaluation periods to plot per row. If the
        number of periods exceeds ``max_cols``, a new row is started.
    axis: str, optional, 
       Wether to keep the axis of set it to False. 
    show_grid: bool, default=True, 
       Visualize the grid 
    grid_props: dict, optional 
       Grid properties for visualizations. If none the properties is 
       infered as ``{"linestyle":":", 'alpha':0.7}``.
    verbose : int, optional
        Verbosity level. Controls the amount of output printed.

    Returns
    -------
    None
        The function displays the visualization plot.

    Examples
    --------
    Example 1: **Spatial Visualization**
    
    In this example, we visualize the forecasted and actual values of the
    **subsidence** target variable, using **longitude** and **latitude**
    for the spatial coordinates. We visualize the results for two
    evaluation periods (2023 and 2024), using **quantile** mode for the forecast.

    >>> from fusionlab.plot.forecast import visualize_forecasts
    >>> forecast_results = pd.DataFrame({
    >>>     'longitude': [-103.808151, -103.808151, -103.808151],
    >>>     'latitude': [0.473152, 0.473152, 0.473152],
    >>>     'subsidence_q50': [0.3, 0.4, 0.5],
    >>>     'subsidence': [0.35, 0.42, 0.49],
    >>>     'date': ['2023-01-01', '2023-01-02', '2023-01-03']
    >>> })
    >>> test_data = pd.DataFrame({
    >>>     'longitude': [-103.808151, -103.808151, -103.808151],
    >>>     'latitude': [0.473152, 0.473152, 0.473152],
    >>>     'subsidence': [0.35, 0.41, 0.49],
    >>>     'date': ['2023-01-01', '2023-01-02', '2023-01-03']
    >>> })
    >>> visualize_forecasts(
    >>>     forecast_df=forecast_results,
    >>>     test_data=test_data,
    >>>     dt_col="date",
    >>>     tname="subsidence",
    >>>     eval_periods=[2023, 2024],
    >>>     mode="quantile",
    >>>     kind="spatial",
    >>>     cmap="coolwarm",
    >>>     max_cols=2,
    >>>     verbose=1
    >>> )
    
    Example 2: **Non-Spatial Visualization**
    
    In this example, we visualize the forecasted and actual values of the
    **subsidence** target variable in a **non-spatial** context. The columns
    `longitude` and `latitude` are still provided but used for non-spatial
    x and y axes. Evaluation is for 2023.

    >>> from fusionlab.plot.forecast import visualize_forecasts
    >>> forecast_results = pd.DataFrame({
    >>>     'longitude': [-103.808151, -103.808151, -103.808151],
    >>>     'latitude': [0.473152, 0.473152, 0.473152],
    >>>     'subsidence_pred': [0.35, 0.41, 0.48],
    >>>     'subsidence': [0.36, 0.43, 0.49],
    >>>     'date': ['2023-01-01', '2023-01-02', '2023-01-03']
    >>> })
    >>> test_data = pd.DataFrame({
    >>>     'longitude': [-103.808151, -103.808151, -103.808151],
    >>>     'latitude': [0.473152, 0.473152, 0.473152],
    >>>     'subsidence': [0.36, 0.42, 0.50],
    >>>     'date': ['2023-01-01', '2023-01-02', '2023-01-03']
    >>> })
    >>> forecast_df_point = visualize_forecasts(
    >>>     forecast_df=forecast_results,
    >>>     test_data=test_data,
    >>>     dt_col="date",
    >>>     tname="subsidence",
    >>>     eval_periods=[2023],
    >>>     mode="point",
    >>>     kind="non-spatial",
    >>>     x="longitude",
    >>>     y="latitude",
    >>>     cmap="viridis",
    >>>     max_cols=1,
    >>>     axis="off",
    >>>     show_grid=True,
    >>>     grid_props={"linestyle": "--", "alpha": 0.5},
    >>>     verbose=2
    >>> )

    Notes
    -----
    - In ``quantile`` mode, the function uses the column
      ``<tname>_q50`` for visualization.
    - In ``point`` mode, the column ``<tname>_pred`` is used.
    - For spatial visualizations, if ``x`` and ``y`` are not provided,
      they default to ``"longitude"`` and ``"latitude"``.
    - The evaluation period(s) are determined by filtering
      ``forecast_df[dt_col] == <eval_period>``.
    - Use ``assert_xy_in`` to validate that the x and y columns exist in
      the provided DataFrames.

    See Also
    --------
    generate_forecast : Function to generate forecast results.
    coverage_score   : Function to compute the coverage score.

    References
    ----------
    .. [1] Kouadio L. et al., "Gofast Forecasting Model", Journal of
       Advanced Forecasting, 2025. (In review)
    """

    # Check that forecast_df is a valid DataFrame
    is_frame (
        forecast_df, 
        df_only=True,
        objname="Forecast data", 
        error="raise"
    )
    if eval_periods is None:
        unique_periods = sorted(forecast_df[dt_col].unique())
        if verbose:
            print("No eval_period provided; using up to three unique " +
                  "periods from forecast data.")
        eval_periods = unique_periods[:3]
    
    eval_periods = columns_manager(eval_periods, to_string=True )
    # Check if test_data is provided, else set it to None
    if test_data is not None: 
        is_frame (
            test_data, 
            df_only=True,
            objname="Test data", 
            error="raise"
        )
        # filterby periods ensure Ensure dt_col is in Pandas datetime format
        test_data =filter_by_period (test_data, eval_periods, dt_col)

    forecast_df =filter_by_period (forecast_df, eval_periods, dt_col)
 
    # Convert eval_periods to Pandas datetime64[ns] format
    # # Ensure dtype match before filtering
    eval_periods= forecast_df[dt_col].astype(str).unique()

    # Determine x and y columns for spatial or non-spatial visualization
    if kind == "spatial":
        if x is None and y is None:
            x, y = "longitude", "latitude"
        check_spatial_columns(forecast_df, spatial_cols=(x, y ))
        x, y = assert_xy_in(x, y, data=forecast_df, asarray=False)
    else:
        if x is None or y is None:
            raise ValueError("For non-spatial kind, both x and y must be provided.")
        x, y = assert_xy_in(x, y, data=forecast_df, asarray=False)

    # Set prediction column based on forecast mode
    if mode == "quantile":
        pred_col   = f"{tname}_q50"
        pred_label = f"Predicted {tname} (q50)"
    elif mode == "point":
        pred_col   = f"{tname}_pred"
        pred_label = f"Predicted {tname}"
    else:
        raise ValueError("Mode must be either 'quantile' or 'point'.")

    # XXX  # restore back to origin_dtype before 

    # Loop over evaluation periods and plot
    df_actual = test_data if test_data is not None else forecast_df 
    
    actual_name = get_actual_column_name (
        df_actual, tname, actual_name=actual_name , 
        default_to='tname', 
    )
    
    # Compute global min-max for color scale
    # for all plot.
    vmin = forecast_df[pred_col].min()
    vmax = forecast_df[pred_col].max()
    
    if test_data is not None and actual_name in test_data.columns:
        vmin = min(vmin, test_data[actual_name].min())
        vmax = max(vmax, test_data[actual_name].max())

    # Determine common periods in both forecast_df and test_data (if available)
    if test_data is not None: 
        available_periods = is_in_if (
            forecast_df[dt_col].astype(str).unique(), 
            test_data[dt_col].astype(str).unique(), 
            return_intersect=True, 
            )
        # available_periods = sorted(set(forecast_df[dt_col]) & set(test_data[dt_col]))
    else:
        # sorted(forecast_df[dt_col].astype(str).unique())
        available_periods = eval_periods 
    
    # Ensure the eval_periods only contain periods available in the data
    eval_periods = [p for p in eval_periods if p in available_periods]
    
    if len(eval_periods) == 0:
        raise ValueError(
            "[ERROR] No valid evaluation periods found in forecast or test data.")
    
    # Compute subplot grid dimensions
    n_periods = len(eval_periods)
    n_cols = min(n_periods, max_cols)
    n_rows = int(np.ceil(n_periods / max_cols))
    
    # Two rows per evaluation period if 
    # test_data is passed or is not empty 
    total_rows = n_rows * 2  if test_data is not None else n_rows 
    
    # Create subplot grid
    fig, axes = plt.subplots(
        total_rows, n_cols, figsize=(5 * n_cols, 4 * total_rows)
    )
    
    # Ensure `axes` is a 2D array for consistent indexing
    if total_rows == 1 and n_cols == 1:
        pass # axes = np.array([[axes]])
    elif total_rows == 1:
        axes = np.array([axes])
    elif n_cols == 1:
        axes = axes.reshape(total_rows, 1)

    for idx, period in enumerate(eval_periods):
        # Try to reconvert 
        col_idx = idx % n_cols
        row_idx = (idx // n_cols) * 2 if test_data is not None else (idx // n_cols)

        # Filter data for the current period using 'isin' for robustness
        forecast_subset = forecast_df[forecast_df[dt_col].isin([period])]
        
        if test_data is not None:
            test_subset = test_data[test_data[dt_col].isin([period])]
            # test_subset =filter_by_period (test_data, period, dt_col)
        else:
            test_subset = forecast_subset  # If no test_data, use forecast_df itself
        
        if forecast_subset.empty or test_subset.empty:
            if verbose:
                print(f"[WARNING] No data for period {period}; skipping.")
            continue
        
        # Plot actual values
        if test_data is not None: 
            ax_actual = axes[row_idx, col_idx]
            sc_actual = ax_actual.scatter(
                test_subset[x.name],
                test_subset[y.name],
                c=test_subset[actual_name],
                cmap=cmap,
                alpha=0.7,
                edgecolors='k', 
                s=s, 
                vmin=vmin,  
                vmax=vmax,  
                **kw
            )
            ax_actual.set_title(f"Actual {tname.capitalize()} ({period})")
            ax_actual.set_xlabel(x.name.capitalize())
            ax_actual.set_ylabel(y.name.capitalize())
            if axis == "off": 
                ax_actual.set_axis_off()
            else: 
                ax_actual.set_axis_on()
    
            fig.colorbar(sc_actual, ax=ax_actual, label=tname.capitalize())
            if show_grid: 
                if grid_props is None: 
                    grid_props = {"linestyle": ":", 'alpha': 0.7}
                ax_actual.grid(True, **grid_props)

        # Plot predicted values
        ax_pred = axes[row_idx + 1, col_idx
                       ] if test_data is not None else axes[row_idx, col_idx]
        # ax_pred = axes[row_idx + 1, col_idx]
        sc_pred = ax_pred.scatter(
            forecast_subset[x.name],
            forecast_subset[y.name],
            c=forecast_subset[pred_col],
            cmap=cmap,
            alpha=0.7,
            edgecolors='k',
            s=s, 
            vmin=vmin,  # Apply global min
            vmax=vmax,  # Apply global max
            **kw
        )
        ax_pred.set_title(f"{pred_label} ({period})")
        ax_pred.set_xlabel(x.name.capitalize())
        ax_pred.set_ylabel(y.name.capitalize())
        if axis == "off": 
            ax_pred.set_axis_off()
        else: 
            ax_pred.set_axis_on()

        if show_grid: 
            if grid_props is None: 
                grid_props = {"linestyle": ":", 'alpha': 0.7}
            ax_pred.grid(True, **grid_props)

        fig.colorbar(sc_pred, ax=ax_pred, label=pred_label)

    plt.tight_layout()
    plt.show()

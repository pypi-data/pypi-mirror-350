#! Generated by VisualDCT v2.6
#! DBDSTART
#! DBD("../../dbd/dlsPLC_vdct.dbd")
#! DBDEND

# NX102_interlock.vdb expanded to NX102_interlock.template by flatdb.
# % macro, __doc__, Template showing the status of various MPS interlocks in
# an Omron NX102 PLC.
# % macro, device, device prefix
# % macro, port, port name of ether_ip driver
# % macro, interlock, Interlock suffix (e.g. :INT1)
# % macro, tag, NX PLC tag string e.g. ILK (from ILK.Control[1])
# % macro, tagidx, NX PLC tag index number e.g. 1 (from ILK.Control[1])
# % macro, desc, Permit description (e.g. Front end permit)
# % macro, name, Object name and gui association name
# % macro, auto_reset, Set to 1 to push the reset button whenever the raw interlocks are all ok
# 
# This associates an edm screen with the template
# % gui, $(name=), edm, NX102_interlock.edl, device=$(device), interlock=$(interlock)
# % gui, $(name=), edmembed, NX102_interlock-embed-small.edl, device=$(device), interlock=$(interlock), desc=$(desc)
# This associates BOY screens with the template
# % gui, $(name=), boydetail, dlsPLCApp_opi/NX102_interlock_small_detail.opi, device=$(device), interlock=$(interlock), name=$(name=)
# % gui, $(name=), boyembed, dlsPLCApp_opi/NX102_interlock_small_embed_box.opi, device=$(device), interlock=$(interlock), name=$(name=)
# % gui, $(name=), boyembed, dlsPLCApp_opi/NX102_interlock_small_embed.opi, device=$(device), interlock=$(interlock), name=$(name=)
#
# The interface record interprets the NX102 interface for the
# interlock according to the PLC spreadsheet after its value is read
# back from the PLC.
# Interface 0 is a standard interlock which can be reset.
# Interface 1 shows the status word of an interlock, but it cannot be reset.
# The record allows gui screens to manage whether to present a Reset button
# or not (similarly latched and ini columns).
# The template actually implements the extra stuff in any case, but the
# PLC will not allow it i.e. the INTERFACE and INTERFACE:RAW records do NOT
# interact with other records in the database at time of writing (by acting
# the RESET DISA, DISV , SDIS fields for example).
#
record(mbbi, "$(device)$(interlock):INTERFACE") {
  field(DTYP, "Soft Channel")
  field(INP, "$(device)$(interlock):INTERFACE:RAW")
  field(ZRST, "Resettable Ilk")
  field(ONST, "Status Only Ilk")
}

# Read back the interface code for the interlock from the PLC.
# Hard coded scan rate inherited from copying the valve template equivalent.
record(ai, "$(device)$(interlock):INTERFACE:RAW") {
  field(SCAN, "10 second")
  field(DTYP, "EtherIP")
  field(INP, "@$(port) $(tag).Interfc[$(tagidx)]")
  field(FLNK, "$(device)$(interlock):INTERFACE")
}

# Added a layer of indirection here due to the underlying ether_ip driver
# It is set up to also read the value from the PLC, which is set to 65535 after
# a reset, and triggers the record to process, sending a 2 (reset command)
# Therefore the control value was continuously toggling between 2 and 65535
# This way, the CONTROL:WR record holds that value and the RESET record
# only processes when either caput or the AUTORESET record triggers it
record(ao, "$(device)$(interlock):RESET") {
  field(DESC, "Write number to a tag on PLC")
  field(SCAN, "Passive")
  field(DTYP, "Soft Channel")
  field(OUT, "$(device)$(interlock):CONTROL:WR PP")
  field(DOL, "2")
  field(OMSL, "closed_loop")
  field(DRVH, "2")
}

# S 1 necessary on passive field to provide read rate from PLC
# See ether_ip for more details
record(ao, "$(device)$(interlock):CONTROL:WR") {
  field(DESC, "Write to control value on PLC")
  field(SCAN, "Passive")
  field(DTYP, "EtherIP")
  field(OUT, "@$(port) $(tag).Control[$(tagidx)] S 1")
}

# If auto_reset macro has been defined as 1, the AUTORESET record
# triggers the RESET record to clear the latched interlocks when the
# raw interlocks clear.
record(calcout, "$(device)$(interlock):AUTORESET") {
  field(INPA, "$(device)$(interlock):RAWILK CP")
  field(B, "$(auto_reset=0)")
  field(CALC, "B=1&&A=65535")
  field(OOPT, "Transition To Non-zero")
  field(OUT, "$(device)$(interlock):RESET.PROC PP")
}

record(stringout, "$(device)$(interlock):NAME") {
  field(DESC, "Name of interlock")
  field(DTYP, "Soft Channel")
  field(VAL, "$(desc)")
}

# The VDCT expand command causes a utility called flatdb to be run which
# includes the target file and substitutes the macro definitions as specified.
#
# Empty tag prefix for standalone interlocks.
expand("NX102_valveIlk.vdb", valveIlk) {
  macro(device, "$(device)")
  macro(PORT, "$(port)")
  macro(TAG, "$(tag)")
  macro(TAGIDX, "$(tagidx)")
  macro(TAGPREFIX, "")
  macro(typeprefix, "")
  macro(DIR, "$(interlock):")
}

#! Further lines contain data used by VisualDCT
#! View(0,0,1.0)
#! Record("$(device)$(interlock):INTERFACE",720,88,0,0,"$(device)$(interlock):INTERFACE")
#! Field("$(device)$(interlock):INTERFACE.INP",16777215,0,"$(device)$(interlock):INTERFACE.INP")
#! Link("$(device)$(interlock):INTERFACE.INP","$(device)$(interlock):INTERFACE:RAW.VAL")
#! Record("$(device)$(interlock):INTERFACE:RAW",380,28,0,0,"$(device)$(interlock):INTERFACE:RAW")
#! Field("$(device)$(interlock):INTERFACE:RAW.FLNK",16777215,1,"$(device)$(interlock):INTERFACE:RAW.FLNK")
#! Link("$(device)$(interlock):INTERFACE:RAW.FLNK","$(device)$(interlock):INTERFACE")
#! Field("$(device)$(interlock):INTERFACE:RAW.VAL",16777215,1,"$(device)$(interlock):INTERFACE:RAW.VAL")
#! Record("$(device)$(interlock):RESET",720,286,0,1,"$(device)$(interlock):RESET")
#! Field("$(device)$(interlock):RESET.OUT",16777215,1,"$(device)$(interlock):RESET.OUT")
#! Link("$(device)$(interlock):RESET.OUT","$(device)$(interlock):CONTROL:WR.VAL")
#! Field("$(device)$(interlock):RESET.PROC",16777215,0,"$(device)$(interlock):RESET.PROC")
#! Record("$(device)$(interlock):CONTROL:WR",1040,328,0,0,"$(device)$(interlock):CONTROL:WR")
#! Field("$(device)$(interlock):CONTROL:WR.VAL",16777215,0,"$(device)$(interlock):CONTROL:WR.VAL")
#! Record("$(device)$(interlock):AUTORESET",360,314,0,0,"$(device)$(interlock):AUTORESET")
#! Field("$(device)$(interlock):AUTORESET.INPA",16777215,1,"$(device)$(interlock):AUTORESET.INPA")
#! Field("$(device)$(interlock):AUTORESET.OUT",16777215,1,"$(device)$(interlock):AUTORESET.OUT")
#! Link("$(device)$(interlock):AUTORESET.OUT","$(device)$(interlock):RESET.PROC")
#! Record("$(device)$(interlock):NAME",40,42,0,1,"$(device)$(interlock):NAME")

#! TemplateInstance("valveIlk",100,220,0,"")
#! TemplateField("valveIlk","DIR",16777215,0,1)
#! TemplateField("valveIlk","TAGPREFIX",16777215,0,1)
#! TemplateField("valveIlk","TAGIDX",16777215,0,1)
#! TemplateField("valveIlk","device",16777215,0,1)
#! TemplateField("valveIlk","PORT",16777215,0,1)
#! TemplateField("valveIlk","TAG",16777215,0,1)
#! TemplateField("valveIlk","typeprefix",16777215,0,1)

#! TextBox(TB0,940,80,1240,200,1,"Dialog",12,1,13421568,"The INTERFACE refers to which interlock type on the PLC spreadsheet the interlock\nis resettable (like the usual vacuum interlocks) vs non-resettable (like MO PLC interlocks).\nIt is used by GUI to hide/present some widgets on the interlocks screen.\nIt does not currently impact any other records.",null)
#! TextBox(TB1,1040,500,1240,560,1,"Dialog",12,1,13421568,"The WR record actually writes to the PLC to achiever the reset.",null)
#! TextBox(TB2,700,500,900,560,1,"Dialog",12,1,13421568,"The RESET record is written to by the GUI when the user resets, but it actually triggers another record to write to the PLC",null)
#! TextBox(TB3,340,500,600,680,1,"Dialog",12,1,13421568,"The AUTORESET record monitors for the state of the Raw interlocks changing to non-zero and if active, it triggers a Reset i.e. it clears the latched interlocks when the raw interlocks are clear.\nWhether this is active is determined by the B field and that is intialised by the value of the auto_reset macro value.\n\nMost applications do not use this, to be applied with caution.",null)
#! TextBox(TB4,20,660,320,820,1,"Dialog",12,1,13421568,"The NX102_interlock.vdb file expands the lower level NX102_valveIlk.vdb using the VDCT template mechanism, substituting macros in the unexpanded lower level file for use in the the resulting template file.  \nWith this expansion some macros can be replaced with other macro definitions, some are hard coded to fixed strings and some can be left to pass through unchanged.\n",null)

# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.http_response import AsyncHttpResponse, HttpResponse
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import parse_obj_as
from .core.request_options import RequestOptions
from .types.account_favorite_movies_request_sort_by import AccountFavoriteMoviesRequestSortBy
from .types.account_favorite_movies_response import AccountFavoriteMoviesResponse
from .types.account_favorite_tv_request_sort_by import AccountFavoriteTvRequestSortBy
from .types.account_favorite_tv_response import AccountFavoriteTvResponse
from .types.account_lists_response import AccountListsResponse
from .types.account_movie_recommendations_response import AccountMovieRecommendationsResponse
from .types.account_movie_watchlist_request_sort_by import AccountMovieWatchlistRequestSortBy
from .types.account_movie_watchlist_response import AccountMovieWatchlistResponse
from .types.account_rated_movies_request_sort_by import AccountRatedMoviesRequestSortBy
from .types.account_rated_movies_response import AccountRatedMoviesResponse
from .types.account_rated_tv_request_sort_by import AccountRatedTvRequestSortBy
from .types.account_rated_tv_response import AccountRatedTvResponse
from .types.account_tv_recommendations_response import AccountTvRecommendationsResponse
from .types.account_tv_watchlist_request_sort_by import AccountTvWatchlistRequestSortBy
from .types.account_tv_watchlist_response import AccountTvWatchlistResponse
from .types.auth_create_access_token_response import AuthCreateAccessTokenResponse
from .types.auth_create_request_token_response import AuthCreateRequestTokenResponse
from .types.auth_logout_response import AuthLogoutResponse
from .types.list_add_items_response import ListAddItemsResponse
from .types.list_clear_response import ListClearResponse
from .types.list_create_response import ListCreateResponse
from .types.list_delete_response import ListDeleteResponse
from .types.list_details_response import ListDetailsResponse
from .types.list_item_status_request_media_type import ListItemStatusRequestMediaType
from .types.list_item_status_response import ListItemStatusResponse
from .types.list_remove_items_response import ListRemoveItemsResponse
from .types.list_update_items_response import ListUpdateItemsResponse
from .types.list_update_response import ListUpdateResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTmdbApi:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def auth_create_request_token(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AuthCreateRequestTokenResponse]:
        """


        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthCreateRequestTokenResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            "4/auth/request_token",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthCreateRequestTokenResponse,
                    parse_obj_as(
                        type_=AuthCreateRequestTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def auth_create_access_token(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AuthCreateAccessTokenResponse]:
        """


        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthCreateAccessTokenResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            "4/auth/access_token",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthCreateAccessTokenResponse,
                    parse_obj_as(
                        type_=AuthCreateAccessTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def auth_logout(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[AuthLogoutResponse]:
        """
        Log out of a session.

        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AuthLogoutResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            "4/auth/access_token",
            method="DELETE",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthLogoutResponse,
                    parse_obj_as(
                        type_=AuthLogoutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_details(
        self,
        list_id: int,
        *,
        language: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListDetailsResponse]:
        """
        Retrieve a list by id.

        Parameters
        ----------
        list_id : int

        language : typing.Optional[str]

        page : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDetailsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}",
            method="GET",
            params={
                "language": language,
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDetailsResponse,
                    parse_obj_as(
                        type_=ListDetailsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_update(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListUpdateResponse]:
        """
        Update the details of a list.

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListUpdateResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}",
            method="PUT",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUpdateResponse,
                    parse_obj_as(
                        type_=ListUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_create(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListCreateResponse]:
        """
        Create a new list.

        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListCreateResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            "4/list",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListCreateResponse,
                    parse_obj_as(
                        type_=ListCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_clear(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListClearResponse]:
        """
        Clear all of the items on a list.

        Parameters
        ----------
        list_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListClearResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/clear",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListClearResponse,
                    parse_obj_as(
                        type_=ListClearResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_delete(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListDeleteResponse]:
        """
        Delete a list.

        Parameters
        ----------
        list_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListDeleteResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/{jsonable_encoder(list_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDeleteResponse,
                    parse_obj_as(
                        type_=ListDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_add_items(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListAddItemsResponse]:
        """
        Add items to a list.

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListAddItemsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListAddItemsResponse,
                    parse_obj_as(
                        type_=ListAddItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_update_items(
        self, list_id: str, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListUpdateItemsResponse]:
        """
        Update an individual item on a list

        Parameters
        ----------
        list_id : str

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListUpdateItemsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="PUT",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUpdateItemsResponse,
                    parse_obj_as(
                        type_=ListUpdateItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_remove_items(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ListRemoveItemsResponse]:
        """
        Remove items from a list

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListRemoveItemsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="DELETE",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListRemoveItemsResponse,
                    parse_obj_as(
                        type_=ListRemoveItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_item_status(
        self,
        list_id: int,
        *,
        media_id: int,
        media_type: ListItemStatusRequestMediaType,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListItemStatusResponse]:
        """
        Check if an item is on a list.

        Parameters
        ----------
        list_id : int

        media_id : int

        media_type : ListItemStatusRequestMediaType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListItemStatusResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/item_status",
            method="GET",
            params={
                "media_id": media_id,
                "media_type": media_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListItemStatusResponse,
                    parse_obj_as(
                        type_=ListItemStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_lists(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountListsResponse]:
        """
        Get the custom lists that a user has created.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountListsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/lists",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountListsResponse,
                    parse_obj_as(
                        type_=AccountListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_favorite_movies(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountFavoriteMoviesRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountFavoriteMoviesResponse]:
        """
        Get a users list of favourite movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountFavoriteMoviesRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountFavoriteMoviesResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/favorites",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountFavoriteMoviesResponse,
                    parse_obj_as(
                        type_=AccountFavoriteMoviesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_favorite_tv(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountFavoriteTvRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountFavoriteTvResponse]:
        """
        Get a users list of favourite TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountFavoriteTvRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountFavoriteTvResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/favorites",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountFavoriteTvResponse,
                    parse_obj_as(
                        type_=AccountFavoriteTvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_tv_recommendations(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountTvRecommendationsResponse]:
        """
        Get a users list of recommended TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountTvRecommendationsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/recommendations",
            method="GET",
            params={
                "page": page,
                "language": language,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountTvRecommendationsResponse,
                    parse_obj_as(
                        type_=AccountTvRecommendationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_movie_recommendations(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountMovieRecommendationsResponse]:
        """
        Get a users list of recommended movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountMovieRecommendationsResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/recommendations",
            method="GET",
            params={
                "page": page,
                "language": language,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountMovieRecommendationsResponse,
                    parse_obj_as(
                        type_=AccountMovieRecommendationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_movie_watchlist(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountMovieWatchlistRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountMovieWatchlistResponse]:
        """
        Get a users movie watchlist.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountMovieWatchlistRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountMovieWatchlistResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/watchlist",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountMovieWatchlistResponse,
                    parse_obj_as(
                        type_=AccountMovieWatchlistResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_tv_watchlist(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountTvWatchlistRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountTvWatchlistResponse]:
        """
        Get a users TV watchlist.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountTvWatchlistRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountTvWatchlistResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/watchlist",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountTvWatchlistResponse,
                    parse_obj_as(
                        type_=AccountTvWatchlistResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_rated_movies(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountRatedMoviesRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountRatedMoviesResponse]:
        """
        Get a users rated movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountRatedMoviesRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountRatedMoviesResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/rated",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountRatedMoviesResponse,
                    parse_obj_as(
                        type_=AccountRatedMoviesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def account_rated_tv(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountRatedTvRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AccountRatedTvResponse]:
        """
        Get a users rated TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountRatedTvRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AccountRatedTvResponse]
            200
        """
        _response = self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/rated",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountRatedTvResponse,
                    parse_obj_as(
                        type_=AccountRatedTvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def getting_started(self, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """


        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTmdbApi:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def auth_create_request_token(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AuthCreateRequestTokenResponse]:
        """


        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthCreateRequestTokenResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            "4/auth/request_token",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthCreateRequestTokenResponse,
                    parse_obj_as(
                        type_=AuthCreateRequestTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def auth_create_access_token(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AuthCreateAccessTokenResponse]:
        """


        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthCreateAccessTokenResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            "4/auth/access_token",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthCreateAccessTokenResponse,
                    parse_obj_as(
                        type_=AuthCreateAccessTokenResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def auth_logout(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[AuthLogoutResponse]:
        """
        Log out of a session.

        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AuthLogoutResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            "4/auth/access_token",
            method="DELETE",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AuthLogoutResponse,
                    parse_obj_as(
                        type_=AuthLogoutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_details(
        self,
        list_id: int,
        *,
        language: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListDetailsResponse]:
        """
        Retrieve a list by id.

        Parameters
        ----------
        list_id : int

        language : typing.Optional[str]

        page : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDetailsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}",
            method="GET",
            params={
                "language": language,
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDetailsResponse,
                    parse_obj_as(
                        type_=ListDetailsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_update(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListUpdateResponse]:
        """
        Update the details of a list.

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListUpdateResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}",
            method="PUT",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUpdateResponse,
                    parse_obj_as(
                        type_=ListUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_create(
        self, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListCreateResponse]:
        """
        Create a new list.

        Parameters
        ----------
        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListCreateResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            "4/list",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListCreateResponse,
                    parse_obj_as(
                        type_=ListCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_clear(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListClearResponse]:
        """
        Clear all of the items on a list.

        Parameters
        ----------
        list_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListClearResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/clear",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListClearResponse,
                    parse_obj_as(
                        type_=ListClearResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_delete(
        self, list_id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListDeleteResponse]:
        """
        Delete a list.

        Parameters
        ----------
        list_id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListDeleteResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/{jsonable_encoder(list_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListDeleteResponse,
                    parse_obj_as(
                        type_=ListDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_add_items(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListAddItemsResponse]:
        """
        Add items to a list.

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListAddItemsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="POST",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListAddItemsResponse,
                    parse_obj_as(
                        type_=ListAddItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_update_items(
        self, list_id: str, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListUpdateItemsResponse]:
        """
        Update an individual item on a list

        Parameters
        ----------
        list_id : str

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListUpdateItemsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="PUT",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListUpdateItemsResponse,
                    parse_obj_as(
                        type_=ListUpdateItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_remove_items(
        self, list_id: int, *, raw_body: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ListRemoveItemsResponse]:
        """
        Remove items from a list

        Parameters
        ----------
        list_id : int

        raw_body : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListRemoveItemsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/items",
            method="DELETE",
            json={
                "RAW_BODY": raw_body,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListRemoveItemsResponse,
                    parse_obj_as(
                        type_=ListRemoveItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_item_status(
        self,
        list_id: int,
        *,
        media_id: int,
        media_type: ListItemStatusRequestMediaType,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListItemStatusResponse]:
        """
        Check if an item is on a list.

        Parameters
        ----------
        list_id : int

        media_id : int

        media_type : ListItemStatusRequestMediaType

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListItemStatusResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/list/{jsonable_encoder(list_id)}/item_status",
            method="GET",
            params={
                "media_id": media_id,
                "media_type": media_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListItemStatusResponse,
                    parse_obj_as(
                        type_=ListItemStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_lists(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountListsResponse]:
        """
        Get the custom lists that a user has created.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountListsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/lists",
            method="GET",
            params={
                "page": page,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountListsResponse,
                    parse_obj_as(
                        type_=AccountListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_favorite_movies(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountFavoriteMoviesRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountFavoriteMoviesResponse]:
        """
        Get a users list of favourite movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountFavoriteMoviesRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountFavoriteMoviesResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/favorites",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountFavoriteMoviesResponse,
                    parse_obj_as(
                        type_=AccountFavoriteMoviesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_favorite_tv(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountFavoriteTvRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountFavoriteTvResponse]:
        """
        Get a users list of favourite TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountFavoriteTvRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountFavoriteTvResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/favorites",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountFavoriteTvResponse,
                    parse_obj_as(
                        type_=AccountFavoriteTvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_tv_recommendations(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountTvRecommendationsResponse]:
        """
        Get a users list of recommended TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountTvRecommendationsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/recommendations",
            method="GET",
            params={
                "page": page,
                "language": language,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountTvRecommendationsResponse,
                    parse_obj_as(
                        type_=AccountTvRecommendationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_movie_recommendations(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountMovieRecommendationsResponse]:
        """
        Get a users list of recommended movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountMovieRecommendationsResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/recommendations",
            method="GET",
            params={
                "page": page,
                "language": language,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountMovieRecommendationsResponse,
                    parse_obj_as(
                        type_=AccountMovieRecommendationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_movie_watchlist(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountMovieWatchlistRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountMovieWatchlistResponse]:
        """
        Get a users movie watchlist.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountMovieWatchlistRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountMovieWatchlistResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/watchlist",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountMovieWatchlistResponse,
                    parse_obj_as(
                        type_=AccountMovieWatchlistResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_tv_watchlist(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountTvWatchlistRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountTvWatchlistResponse]:
        """
        Get a users TV watchlist.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountTvWatchlistRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountTvWatchlistResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/watchlist",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountTvWatchlistResponse,
                    parse_obj_as(
                        type_=AccountTvWatchlistResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_rated_movies(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountRatedMoviesRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountRatedMoviesResponse]:
        """
        Get a users rated movies.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountRatedMoviesRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountRatedMoviesResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/movie/rated",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountRatedMoviesResponse,
                    parse_obj_as(
                        type_=AccountRatedMoviesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def account_rated_tv(
        self,
        account_object_id: str,
        *,
        page: typing.Optional[int] = None,
        language: typing.Optional[str] = None,
        sort_by: typing.Optional[AccountRatedTvRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AccountRatedTvResponse]:
        """
        Get a users rated TV shows.

        Parameters
        ----------
        account_object_id : str

        page : typing.Optional[int]

        language : typing.Optional[str]

        sort_by : typing.Optional[AccountRatedTvRequestSortBy]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AccountRatedTvResponse]
            200
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"4/account/{jsonable_encoder(account_object_id)}/tv/rated",
            method="GET",
            params={
                "page": page,
                "language": language,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AccountRatedTvResponse,
                    parse_obj_as(
                        type_=AccountRatedTvResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def getting_started(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """


        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

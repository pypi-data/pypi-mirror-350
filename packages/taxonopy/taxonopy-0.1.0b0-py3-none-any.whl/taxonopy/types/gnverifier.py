# generated by datamodel-codegen:
#   filename:  gnverifier_openapi.json
#   timestamp: 2025-03-10T19:16:54+00:00

from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel


class Version(BaseModel):
    version: Optional[str] = Field(
        None, description='The version number.', examples=['v1.0.0']
    )
    build: Optional[str] = Field(
        None,
        description='The compilation timestamp.',
        examples=['2022-09-05_13:55:47UTC'],
    )


class DataSource(BaseModel):
    id: Optional[int] = Field(
        None,
        description='An identifier associated with the data-source in `gnames` database.\n\nThis ID is intended to be stable through the lifespan of the `GlobalNames` project.\n',
        examples=[1],
    )
    uuid: Optional[str] = Field(
        None,
        description='UUID v4 that is associated with the data-source.\n\nThis UUID is a global identifier of the data-source in the context of `GlobalNames`.\n',
        examples=['d4df2968-4257-4ad9-ab81-bedbbfb25e2a'],
    )
    title: Optional[str] = Field(
        None,
        description='The name of the data-source.',
        examples=['The Catalogue of Life'],
    )
    title_short: Optional[str] = Field(
        None,
        alias='titleShort',
        description='A simplified/abbreviated name of the data-source.\n\nIt can be used in outputs without worrying about excessively long names of data-sources.\n',
        examples=['Catalogue of Life'],
    )
    version: Optional[str] = Field(
        None,
        description='The version of a data-source according to data-provider.',
        examples=['August 2020 Edition'],
    )
    revision_date: Optional[str] = Field(
        None,
        alias='revisionDate',
        description='An information when the data-source was updated according to the data-provider. \n\nThe value would follow one of the following\nformats\n\n- year-month-day\n- year-month\n- year\n',
        examples=['2020-08'],
    )
    doi: Optional[str] = Field(
        None, description='Digital Object Identifier', examples=['10.15468/rffz4x']
    )
    citation: Optional[str] = Field(
        None,
        description='A citation representing the data-source.',
        examples=['Species 2000 & ITIS Catalogue of Life: 2019, Catalogue of Life'],
    )
    authors: Optional[str] = Field(
        None, description='Authors of the data-source.', examples=['F. Bisby et al']
    )
    description: Optional[str] = Field(
        None,
        description='A summary describing the resource.',
        examples=[
            'This release of the Catalogue of Life contains contributions from 172 databases with information on 1,867,817 species'
        ],
    )
    home_url: Optional[str] = Field(
        None,
        alias='homeURL',
        description='A website of the data-source.',
        examples=['http://www.catalogueoflife.org/'],
    )
    is_outlink_ready: Optional[bool] = Field(
        None,
        alias='isOutlinkReady',
        description='The flag is true if the data-source has enough data and metadata to be recommended for out-linking. \n\nIf the flag is false, it does not mean that the original data-source is not good, it means that its representation at `GNames` is not complete/recent enough.\n',
        examples=[True],
    )
    curation: Optional[str] = Field(
        None,
        description='This field indicates an approximate amount of effort spent on verification of the data aggregated in the data-source. There are 3 levels\n\n- `NotCurated`\n- `AutoCurated`\n- `Curated`\n\nIf this flag has a `NotCurated` value, it does not mean that\noriginal data-source is not curated, rather it means the curation\nlevel is not known to `GNames`.\n',
        examples=['Curated'],
    )
    record_count: Optional[int] = Field(
        None,
        alias='recordCount',
        description='The number of records harvested from the data-source.',
        examples=[3927925],
    )
    updated_at: Optional[str] = Field(
        None,
        alias='updatedAt',
        description='A timestamp of the last data-source harvest by `GNames`.',
        examples=['2020-06-15T00:58:02.000+0000'],
    )


class VerificationInput(BaseModel):
    name_strings: Optional[List[str]] = Field(
        None,
        alias='nameStrings',
        examples=[
            ['Pomatomus soltator', 'Bubo bubo (Linnaeus, 1758)', 'Isoetes longissimum']
        ],
    )
    data_sources: Optional[List[int]] = Field(
        None, alias='dataSources', examples=[[1, 12, 170]]
    )
    with_all_matches: Optional[bool] = Field(
        None,
        alias='withAllMatches',
        description='If "true", returns all found matches sorted by `sortScore`.',
        examples=[False],
    )
    with_capitalization: Optional[bool] = Field(
        None,
        alias='withCapitalization',
        description='If this flag is "true", name-strings that start with low-case letter will be capitalized.\n',
        examples=[False],
    )
    with_species_group: Optional[bool] = Field(
        None,
        alias='withSpeciesGroup',
        description='If this flag is "true", species names also get matched by their species group.\nIt means that the request will take in account botanical autonyms and zoological coordinated names.\nFor example, a search for `Aus bus` will also search for `Aus bus bus` and vice versa.\n',
        examples=[False],
    )
    with_uninomial_fuzzy_match: Optional[bool] = Field(
        None,
        alias='withUninomialFuzzyMatch',
        description='Allows fuzzy matching for uninomial names.',
        examples=[False],
    )
    with_stats: Optional[bool] = Field(
        None,
        alias='withStats',
        description='If true, calculates the most prevalent kingdom and finds the lowest taxon that contains the majority of names.\nUses the Catalogue of life management classification.\n',
        examples=[True],
    )
    main_taxon_threshold: Optional[float] = Field(
        None,
        alias='mainTaxonThreshold',
        description='Sets the minimal percentage of names to calculate the `mainTaxon`, the lowest taxon containing the majority of names.\nCan be set in the range of 0.5-1.0.\nIf not set, or is lower than 0.5, the value defaults to 0.5.\n',
        examples=[0.6],
    )


class Kingdom(BaseModel):
    name: Optional[str] = Field(
        None, description="Kingdom's name.", examples=['Animalia']
    )
    names_num: Optional[int] = Field(
        None,
        alias='namesNum',
        description='The number of names, that matched the `Catalogue of Life` for the kingdom.',
        examples=[2],
    )
    percentage: Optional[float] = Field(
        None, description='The percentage of names matched the kingdom.', examples=[1]
    )


class YearRange(BaseModel):
    year_start: Optional[int] = Field(
        None,
        alias='yearStart',
        description='The lower border of the range.',
        examples=[1750],
    )
    year_end: Optional[int] = Field(
        None,
        alias='yearEnd',
        description='The higher border of the range.',
        examples=[1850],
    )


class SearchQuery(RootModel[Optional[str]]):
    root: Optional[str] = Field(
        None,
        description='Query for advanced search. Query can include the following components.\n* name is a shortcut that allows to put together several elements `n:B. bubo Linn. 1750-1800`\n  \n* genus `g:B.`, `g:Bub.`, `g:Bubo`\n* species `sp:bubo`, `sp:gallop.`\n* infraspecies `isp:bubo`, `isp:interp.`\n* either species or infraspecies (all sp) `asp:bubo`\n* data-sources IDs `ds:1,2,3`\n* parent taxon `tx:Aves`. Uses classification of the first data-source from `d  s:`. If data-sources are not set, uses Catalogue of Life.\n* author `au:Linnaeus`, `au:Linn.`, `au:L.`\n* year `y:1888`, `y:1888-1900`, `y:1888-`, `y:-1888`\n    \nThe query must contain the species or infraspecies data\n',
        examples=['n:B. bubo ds:1,2 au:Linn. y:1700-'],
    )


class MatchType(RootModel[Optional[str]]):
    root: Optional[str] = Field(
        None,
        description='Indicates the quality and/or kind of found matches.\n- `NoMatch` (no matched name found)\n- `PartialFuzzy` (fuzzy partial match after removing some parts)\n- `PartialExact` (match after removing last or middle epithets)\n- `Fuzzy` (fuzzy match to a canonical form)\n- `Exact` (exact match to a canonical form or a verbatim string)\n- `Virus` (literal match of Viruses, plasmids, prions and other non-cellular entities)\n- `FacetedSearch` (match by a faceted search)\n',
        examples=['Fuzzy'],
    )


class ScoreDetails(BaseModel):
    cardinality_score: Optional[float] = Field(
        None,
        alias='cardinalityScore',
        description='Is 1 if cardinality matches (for example if both the input and a match are `trinomials`), is 0 otherwise.',
        examples=[1],
    )
    infra_specific_rank_score: Optional[float] = Field(
        None,
        alias='infraSpecificRankScore',
        description='Is at maximum if infraspecific ranks match.',
        examples=[0],
    )
    fuzzy_less_score: Optional[float] = Field(
        None,
        alias='fuzzyLessScore',
        description='It is at maximum for exact matches.',
        examples=[1],
    )
    curated_data_score: Optional[float] = Field(
        None,
        alias='curatedDataScore',
        description='It is at maximum for data-sources marked as `curated`.',
        examples=[1],
    )
    author_match_score: Optional[float] = Field(
        None,
        alias='authorMatchScore',
        description='It is at maximum if authors and year matched completely.',
        examples=[0.5],
    )
    accepted_name_score: Optional[float] = Field(
        None,
        alias='acceptedNameScore',
        description='It is at maximum if matched name marked as currently accepted.',
        examples=[1],
    )
    parsing_quality_score: Optional[float] = Field(
        None,
        alias='parsingQualityScore',
        description='It is at maximum if no name-parsing problems were detected.',
        examples=[1],
    )


class DataSources(RootModel[Optional[List[DataSource]]]):
    root: Optional[List[DataSource]] = Field(
        None, description='A list of biodiversity data-sources aggregated in `GNames`.'
    )


class VerificationMetadata(BaseModel):
    names_number: Optional[int] = Field(
        None,
        alias='namesNumber',
        description='The number of names in the input.',
        examples=[2],
    )
    with_all_sources: Optional[bool] = Field(
        None,
        alias='withAllSources',
        description='When `true`, all the data from all sources are used for matching.',
        examples=[False],
    )
    with_all_matches: Optional[bool] = Field(
        None,
        alias='withAllMatches',
        description='If a data-source matched several times, returns all matched results.',
        examples=[False],
    )
    with_stats: Optional[bool] = Field(
        None,
        alias='withStats',
        description="Uses the Catalogue of Life's classification to calculate the most prominent kingdom.\nAlso calculates the lowest taxon that contains the majority of input names.\n",
        examples=[True],
    )
    with_capitalization: Optional[bool] = Field(
        None,
        alias='withCapitalization',
        description='Capitalizes the first letter of the input.',
        examples=[False],
    )
    with_species_group: Optional[bool] = Field(
        None,
        alias='withSpeciesGroup',
        description='Expand search to species group.',
        examples=[False],
    )
    with_uninomial_fuzzy_match: Optional[bool] = Field(
        None,
        alias='withUninomialFuzzyMatch',
        description='Allows fuzzy matching for uninomial names.',
        examples=[False],
    )
    data_sources: Optional[List[int]] = Field(
        None,
        alias='dataSources',
        description='The list of selected data-sources. \n\nThis setting is ignored if `withAllSources` is true.\n',
        examples=[[1, 12, 170]],
    )
    main_taxon_threshold: Optional[float] = Field(
        None,
        alias='mainTaxonThreshold',
        description='Indicates the lowest percentage of all names that would make a taxon show as a `mainTaxon` of entered names.\nThe accepted range is 0.5-1.0, the default is 0.5.\n',
        examples=[0.6],
    )
    stats_names_num: Optional[int] = Field(
        None,
        alias='StatsNamesNum',
        description='The number of names used for calculation of the context.\nOnly names that can match to names in the `Catalogue of Life` are used.\n',
        examples=[2],
    )
    main_taxon: Optional[str] = Field(
        None,
        alias='mainTaxon',
        description='The name of the lowest taxon that still contains the majority of the input names.\nIt is calculated by matching input with the `Catalogue of Life` data and uses its managerial classification.\nNames that did not match the `Catalogue of Life` are not used for the calculation.\n',
        examples=['Chordata'],
    )
    main_taxon_percentage: Optional[float] = Field(
        None,
        alias='mainTaxonPercentage',
        description='The percentage of names in the `mainTaxon`.',
        examples=[1],
    )
    kingdom: Optional[str] = Field(
        None,
        description='The kingdom that contains the majority of names according to the `Catalogue of Life`.',
        examples=['Animalia'],
    )
    kingdom_percentage: Optional[float] = Field(
        None,
        alias='kingdomPercentage',
        description='The percentage of names in the main kingdom.',
        examples=[1],
    )
    kingdoms: Optional[List[Kingdom]] = Field(
        None,
        alias='Kingdoms',
        description='Distribution of names over matched kingdoms.',
    )


class SearchInput(BaseModel):
    query: Optional[SearchQuery] = None
    with_all_results: Optional[bool] = Field(
        None,
        alias='withAllResults',
        description='Provide all found results, not only `bestResult`',
        examples=[False],
    )
    warnings: Optional[List[str]] = Field(
        None, description='Warnings about discrepancies in the input.'
    )
    data_source_ids: Optional[List[int]] = Field(
        None,
        alias='dataSourceIds',
        description='Limits search data to results from the given data-sources.',
        examples=[[1, 12]],
    )
    parent_taxon: Optional[str] = Field(
        None,
        alias='parentTaxon',
        description='Limits search data to records containing the given clade in the classification field.\n',
        examples=['Chordata'],
    )
    name_string: Optional[str] = Field(
        None,
        alias='nameString',
        description='A convenience field that allows to enter several fields as a one string.\nInstead of providing genus, species in separate fields, they can be given in a `nameString`.\nData from `nameString` will overwrite corresponding data fields.\nFor example `B. bubo` name string will overwrite `genus` and `species` fields.\n',
        examples=['B. bubo'],
    )
    genus: Optional[str] = Field(
        None, description='Genus data, can be abbreviated.', examples=['Bubo']
    )
    species: Optional[str] = Field(
        None, description='Specific epithet, can be abbreviated.', examples=['bubo']
    )
    species_infra: Optional[str] = Field(
        None,
        alias='speciesInfra',
        description='An infraspecific epithet, can be abbreviated.',
        examples=[''],
    )
    species_any: Optional[str] = Field(
        None,
        alias='speciesAny',
        description='Either specific, or infraspecific epithet.',
        examples=[''],
    )
    author: Optional[str] = Field(
        None, description="Author's name, can be abbreviated.", examples=['Linn.']
    )
    year: Optional[int] = Field(
        None,
        description="Name's year. Ignored if there is a `yearRange`.",
        examples=[0],
    )
    year_range: Optional[YearRange] = Field(
        None,
        alias='yearRange',
        description='Limits search to names within the range.\nIf range does not have one of the values, range is open on that side.\nAt least one value has to be present. If range is given, `year` field is ignored.\n',
    )


class SearchMetadata(BaseModel):
    input: Optional[SearchInput] = None
    names_number: Optional[int] = Field(
        None,
        alias='namesNumber',
        description='The number of found names.',
        examples=[2],
    )
    error: Optional[str] = Field(
        None, description='Provides an error of a search, if it happens.'
    )


class ResultData(BaseModel):
    data_source_id: Optional[int] = Field(
        None,
        alias='dataSourceId',
        description='An Id of the data-source where the match was found.\n\nThis is a local Id at GlobalNames, and it has been stable for more than 10 years.\n',
        examples=[1],
    )
    data_source_title_short: Optional[str] = Field(
        None,
        alias='dataSourceTitleShort',
        description='A simplified/abbreviated title of the data-source.',
        examples=['Catalogue of Life'],
    )
    curation: Optional[str] = Field(
        None,
        description="A curation level for the record's data-source.\n\nIf data-source is known to be curated, there is less risk of misspelling of the matched name.\n",
        examples=['Curated'],
    )
    record_id: Optional[str] = Field(
        None,
        alias='recordId',
        description="The record ID of the `matchedName` from the data-source.\n\nIf the data-source does not provide record ID, the ID is generated by `gnames` and is prepended with a 'gn_' prefix.\n",
        examples=['TX123'],
    )
    global_id: Optional[str] = Field(
        None,
        alias='globalId',
        description='A globally unique record ID (UUID, LSID, DOI etc.).',
        examples=['2284b0d6-d965-5c39-ace5-3ef673da6691'],
    )
    local_id: Optional[str] = Field(
        None,
        alias='localId',
        description='An additional ID that is used internally by the data-source.\n\nQuite often such IDs are used by data-sources to generate URLs to their records.\n',
        examples=['33'],
    )
    outlink: Optional[str] = Field(
        None,
        description='An external URL provided by the data-source for the record.\n',
        examples=[
            'http://www.catalogueoflife.org/annual-checklist/2019/details/species/id/d9ac988f149a3d2822d71c673be09317'
        ],
    )
    entry_date: Optional[str] = Field(
        None,
        alias='entryDate',
        description="A date when a record was harvested to GNames.\n\nIt follows a pattern 'YYYY-MM-DD'.\n",
        examples=['2020-06-30T00:00:00.000Z'],
    )
    sort_score: Optional[float] = Field(
        None,
        alias='sortScore',
        description='SortScore is a numeric representation of the total score.\nIt can be used to find the `BestMatch` overall, as well as the best match for every data-source.\n\nSortScore takes data from all other scores, using the priority sequence from highest to lowest.\n- InfraSpecificRankScore\n- FuzzyLessScore\n- CuratedDataScore\n- AuthorMatchScore\n- AcceptedNameScor\n- ParsingQualityScore\n\nHigher priorities trump lower priorities.\nWhen the final score value is calculated, it is used to sort verification or search results.\n \nComparing this score between results of different verifications will not necessarily be accurate.\nThe score is used for comparison of names from the same result.\n',
    )
    matched_name: Optional[str] = Field(
        None,
        alias='matchedName',
        description='A verbatim scientific name matched to the input.',
        examples=['Pomatomus saltator (Linnaeus, 1766)'],
    )
    matched_cardinality: Optional[int] = Field(
        None,
        alias='matchedCardinality',
        description='A cardinality value of the matched name.\n\nBinomial names have cardinality 2, uninomials have cardinality 1 etc.\n\nCardinality 0 means we cannot determine cardinality of a string.\n',
        examples=[2],
    )
    matched_canonical_simple: Optional[str] = Field(
        None,
        alias='matchedCanonicalSimple',
        description='The most normalized canonical form of a scientific name.\nIt does not contain infraspecific ranks, hybrid signs for named hybrids, authors or years. \nThis canonical form is the best for matching names.\n',
        examples=['Pomatomus saltator'],
    )
    matched_canonical_full: Optional[str] = Field(
        None,
        alias='matchedCanonicalFull',
        description='A less normalized canonical form of the matched name with more details.\nIt does not have authors and years, but does have hybrid signes and ranks (if given).\nThis canonical form is better for presentation and creating matching scores.\n',
        examples=['Pomatomus saltator'],
    )
    current_record_id: Optional[str] = Field(
        None,
        alias='currentRecordId',
        description='If the data-source allows taxonomic resolution of a name, `currentRecordId` will contain the data-source record ID of the currently accepted name for the matched taxon. \n',
        examples=['TX543'],
    )
    current_name: Optional[str] = Field(
        None,
        alias='currentName',
        description='The currently accepted name for the taxon according to the data-source.\n',
        examples=['Pomatomus saltatrix (Linnaeus, 1766)'],
    )
    current_cardinality: Optional[int] = Field(
        None,
        alias='currentCardinality',
        description='Cardinality of the currently accepted name.\n',
        examples=[2],
    )
    current_canonical_simple: Optional[str] = Field(
        None,
        alias='currentCanonicalSimple',
        description='The most normalized canonical form of a scientific name.\nIt does not contain infraspecific ranks, hybrid signs for named hybrids, authors or years. \nThis canonical form is the best for matching names.\n',
        examples=['Pomatomus saltatrix'],
    )
    current_canonical_full: Optional[str] = Field(
        None,
        alias='currentCanonicalFull',
        description='A less normalized canonical form of the matched name with more details.\nIt does not have authors and years, but does have hybrid signes and ranks (if given).\nThis canonical form is better for presentation and creating matching scores.\n',
        examples=['Pomatomus saltatrix'],
    )
    taxonomic_status: Optional[str] = Field(
        None,
        alias='taxonomicStatus',
        description='Indicates if matched name is `accepted` or `synonym` according to the data-source. If data-source deos not provide such information, returns `N/A`.\n',
    )
    is_synonym: Optional[bool] = Field(
        None,
        alias='isSynonym',
        description='`DEPRECATED:` use `taxonomicStatus` instead.\n\nA flag, that is true if the data-source regards matched name as an any kind of synonym to the currently accepted name.\n',
        examples=[True],
    )
    classification_path: Optional[str] = Field(
        None,
        alias='classificationPath',
        description='A classification path for the matched taxon provided by the data-source.\n',
        examples=[
            'Animalia|Chordata|Actinopterygii|Perciformes|Pomatomidae|Pomatomus|Pomatomus saltatrix'
        ],
    )
    classification_ranks: Optional[str] = Field(
        None,
        alias='classificationRanks',
        description='The ranks of the `classificationPath` entries.',
        examples=['kingdom|phylum|class|order|family|genus|species'],
    )
    edit_distance: Optional[int] = Field(
        None,
        alias='editDistance',
        description='Edit distance according to Levenshtein algorithm in case of fuzzy matching.\nExact matches would have `editDistance` at 0.\n',
        examples=[1],
    )
    edit_distance_stem: Optional[int] = Field(
        None,
        alias='editDistanceStem',
        description='Edit distance according to Levenshtein algorithm between stemmed versions of canonical forms of input name and matched name.\n\nStemmed versions are the most normalized forms of scientific names with stripped suffixes and transformation of some characters (v->u, j->i).\nThey are not provided by the API, but can be obtained with `gnparser` app.\n',
        examples=[1],
    )
    match_type: Optional[MatchType] = Field(None, alias='matchType')
    score_details: Optional[ScoreDetails] = Field(None, alias='scoreDetails')


class Name(BaseModel):
    id: Optional[UUID] = Field(
        None,
        description='An UUID v5 generated from the input string using "globalnames.org" DNS domain name as a seed.\n\nThis UUID can be used as a distributed global unique identifier of the string and can be created independently in any popular programming language.\n',
        examples=['2284b0d6-d965-5c39-ace5-3ef673da6691'],
    )
    name: Optional[str] = Field(
        None,
        description='An input name-string entered for the verification, or found by search.',
        examples=['Pomatomus soltator'],
    )
    match_type: Optional[MatchType] = Field(None, alias='matchType')
    best_result: Optional[ResultData] = Field(None, alias='bestResult')
    results: Optional[List[ResultData]] = Field(
        None, description='Matched records found in selected data-sources.'
    )
    data_sources_num: Optional[int] = Field(
        None,
        alias='dataSourcesNum',
        description='The number of data-sources where the string had a match to a scientific name.\n',
        examples=[12],
    )
    curation: Optional[str] = Field(
        None,
        description='The best curation level from matched data-sources.\n\nPossible values are\n\n- `NotCurated`\n- `AutoCurated`\n- `Curated`\n\nIf this flag has a `NotCurated` value, it does not mean that original data-source is not curated, rather it means the curation level is not known to `gnames`.\n',
        examples=['Curated'],
    )
    overload_detected: Optional[str] = Field(
        None,
        alias='overloadDetected',
        description='Sometimes there are too many records in a database corresponding to a name.\nUsually it happens because of a large amount of surrogate names like `Lepidoptera BOLD:1234` or strains like `Escherichia coli EC1856`.\nIn such cases there is a truncation of results.\n',
        examples=['Too many variants (possibly strains), some results are truncated.'],
    )
    error: Optional[str] = Field(
        None,
        description='Normally an empty string.\n\nIn case of an unexpected error, it will be shown here. \n\nIf error is not empty, it means that matching failed because of a bug in the system.\n',
    )


class VerificationOutput(BaseModel):
    metadata: Optional[VerificationMetadata] = None
    names: Optional[List[Name]] = Field(
        None, description='An array of verification results.'
    )


class SearchOutput(BaseModel):
    metadata: Optional[SearchMetadata] = None
    names: Optional[List[Name]] = None

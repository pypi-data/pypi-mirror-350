from typing import Any, TYPE_CHECKING, Union, Optional
from collections.abc import Iterable, AsyncIterable
from collections.abc import Mapping

from pydantic import ValidationError
import httpx

from soar_sdk.input_spec import InputSpecification
from soar_sdk.shims.phantom.action_result import ActionResult as PhantomActionResult
from soar_sdk.shims.phantom.base_connector import BaseConnector
from soar_sdk.exceptions import ActionFailure, SoarAPIError

from .abstract import SOARClient

if TYPE_CHECKING:
    from .actions_provider import ActionsProvider
import json


_INGEST_STATE_KEY = "ingestion_state"
_AUTH_STATE_KEY = "auth_state"
_CACHE_STATE_KEY = "asset_cache"

JSONType = Union[dict[str, Any], list[Any], str, int, float, bool, None]


class AppConnector(BaseConnector, SOARClient):
    """
    The connector mainly generated by the App Wizard. It is extended to properly work
    with handlers provided by the app.

    Serves as the layer for exposing public BaseConnector API interface, so that App
    is no longer calling phantom library directly.

    In the future it should be replaced by another class accessing SOAR API.
    """

    def __init__(self, actions_provider: "ActionsProvider") -> None:
        # Call the BaseConnectors init first
        super().__init__()

        self.actions_provider = actions_provider
        self._client = httpx.Client(
            base_url=AppConnector.get_soar_base_url(),
            verify=False,  # noqa: S501
        )
        self.csrf_token: str = ""
        self.__artifacts: dict = {}
        self.__containers: dict = {}

        self.ingestion_state: dict = {}
        self.auth_state: dict = {}
        self.asset_cache: dict = {}

    @property
    def client(self) -> httpx.Client:
        return self._client

    def authenticate_soar_client(self, input_data: InputSpecification) -> None:
        session_id = input_data.user_session_token
        if session_id:
            self.__login()
        else:
            if input_data.soar_auth:
                self._client = httpx.Client(
                    base_url=input_data.soar_auth.phantom_url,
                    verify=False,  # noqa: S501
                )
                self.__login()
                session_id = self.get_session_id(
                    input_data.soar_auth.username,
                    input_data.soar_auth.password,
                )

        if session_id:
            current_cookies = self._client.headers.get("Cookie", "")
            update_cookies = f"sessionid={session_id};{current_cookies}"
            self._client.headers.update({"Cookie": update_cookies})

    def __login(self) -> None:
        response = self._client.get("/login")
        response.raise_for_status()
        self.csrf_token = response.cookies.get("csrftoken") or ""
        self._client.cookies.update(response.cookies)
        self._client.headers.update({"X-CSRFToken": self.csrf_token})
        cookies = f"csrftoken={self.csrf_token}"
        self._client.headers.update({"Cookie": cookies})

    def get_session_id(self, username: str, password: str) -> str:
        self._client.post(
            "/login",
            data={
                "username": username,
                "password": password,
                "csrfmiddlewaretoken": self.csrf_token,
            },
            headers={"Referer": f"{self._client.base_url}/login"},
        )
        session_id = self._client.cookies.get("sessionid")
        return session_id or ""

    def get(
        self,
        endpoint: str,
        *,
        params: Optional[Union[dict[str, Any], httpx.QueryParams]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        timeout: Optional[httpx.Timeout] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        follow_redirects: bool = False,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a GET request to the specfic endpoint using the soar client
        """
        response = self._client.get(
            endpoint,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            auth=auth,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def post(
        self,
        endpoint: str,
        *,
        content: Optional[
            Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]]
        ] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[dict[str, Any]] = None,
        json: Optional[JSONType] = None,
        params: Optional[dict[str, Any]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        timeout: Optional[Union[float, httpx.Timeout]] = None,
        follow_redirects: bool = True,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a POST request to the specfic endpoint using the soar client
        """
        headers = headers or {}
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})
        response = self._client.post(
            endpoint,
            headers=headers,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            cookies=cookies,
            auth=auth,  # type: ignore[arg-type]
            timeout=timeout,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def put(
        self,
        endpoint: str,
        *,
        content: Optional[
            Union[str, bytes, Iterable[bytes], AsyncIterable[bytes]]
        ] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[dict[str, Any]] = None,
        json: Optional[JSONType] = None,
        params: Optional[dict[str, Any]] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        auth: Optional[Union[httpx.Auth, tuple[str, str]]] = None,
        timeout: Optional[Union[float, httpx.Timeout]] = None,
        follow_redirects: bool = True,
        extensions: Optional[Mapping[str, Any]] = None,
    ) -> httpx.Response:
        """
        Perform a PUT request to the specfic endpoint using the soar client
        """
        headers = headers or {}
        headers.update({"Referer": f"{self._client.base_url}/{endpoint}"})
        response = self._client.put(
            endpoint,
            headers=headers,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            cookies=cookies,
            auth=auth,  # type: ignore[arg-type]
            timeout=timeout,
            follow_redirects=follow_redirects,
            extensions=extensions,
        )
        response.raise_for_status()
        return response

    def _save_artifact(self, artifact: dict) -> tuple[bool, str, Optional[int]]:
        artifact.update(
            {k: v for k, v in self._artifact_common.items() if (not artifact.get(k))}
        )
        try:
            json.dumps(artifact)
        except TypeError as e:
            error_msg = (
                f"Artifact could not be converted to a JSON string. Error: {e!s}"
            )
            raise ActionFailure(error_msg) from e

        if self.csrf_token:
            try:
                response = self.post("rest/artifact", json=artifact)
            except Exception as e:
                error_msg = f"Failed to add artifact: {e}"
                raise SoarAPIError(error_msg) from e

            resp_data = response.json()

            if "id" in resp_data:
                return (True, "Artifact added successfully", resp_data["id"])

            if "existing_artifact_id" in resp_data:
                return (
                    True,
                    "Artifact already exists",
                    resp_data["existing_artifact_id"],
                )

            msg_cause = resp_data.get("message", "NONE_GIVEN")
            message = f"artifact addition failed, reason from server: {msg_cause}"
            raise SoarAPIError(message)

        else:
            next_artifact_id = self.__add_artifact_locally(artifact)
            return (True, "Artifact added successfully", next_artifact_id)

    def __add_artifact_locally(self, artifact: dict) -> int:
        if "container_id" not in artifact:
            message = "Artifact addition failed, no container ID given"
            raise SoarAPIError(message)

        next_artifact_id = (max(self.__artifacts.keys()) if self.__artifacts else 0) + 1
        self.__artifacts[next_artifact_id] = artifact
        return next_artifact_id

    def _save_container(
        self, container: dict, fail_on_duplicate: bool = False
    ) -> tuple[bool, str, Optional[int]]:
        try:
            self._prepare_container(container)
        except Exception as e:
            error_msg = f"Failed to prepare container: {e}"
            raise ActionFailure(error_msg) from e

        try:
            json.dumps(container)
        except TypeError as e:
            error_msg = (
                f"Container could not be converted to a JSON string. Error: {e!s}"
            )
            raise ActionFailure(error_msg) from e

        if self.csrf_token:
            try:
                response = self.post("rest/container", json=container)
            except Exception as e:
                error_msg = f"Failed to add container: {e}"
                raise SoarAPIError(error_msg) from e

            resp_data = response.json()
            if "existing_container_id" in resp_data:
                return (
                    not fail_on_duplicate,
                    "Container already exists",
                    resp_data.get("existing_container_id"),
                )

            if resp_data.get("failed"):
                msg_cause = resp_data.get("message", "NONE_GIVEN")
                message = f"Container creation failed, reason from server: {msg_cause}"
                raise SoarAPIError(message)

            artifact_resp_data = resp_data.get("artifacts", [])
            self._process_container_artifacts_response(artifact_resp_data)
            return (True, "Container added successfully", resp_data.get("id"))
        else:
            artifacts = container.pop("artifacts", [])
            next_container_id = (
                max(self.__containers.keys()) if self.__containers else 0
            ) + 1
            for artifact in artifacts:
                artifact["container_id"] = next_container_id
                self._save_artifact(artifact)
            self.__containers[next_container_id] = container
            return (True, "Container added successfully", next_container_id)

    @classmethod
    def get_soar_base_url(cls) -> str:
        return cls._get_phantom_base_url()

    def set_csrf_info(self, token: str, referer: str) -> None:
        """Public method for setting the CSRF token in connector."""
        self._set_csrf_info(token, referer)

    def handle(
        self, input_data: InputSpecification, handle: Optional[int] = None
    ) -> str:
        """Public method for executing an action from a JSON string."""
        self.print_progress_message = True
        return self._handle_action(input_data.json(), handle or 0)

    def handle_action(self, param: dict[str, Any]) -> None:
        # Get the action that we are supposed to execute for this App Run
        action_id = self.get_action_identifier()
        self.debug_print("action_id", action_id)

        if handler := self.actions_provider.get_action(action_id):
            try:
                params = handler.meta.parameters.parse_obj(param)
            except (ValueError, ValidationError):
                # FIXME: Consider adding more details to this error, but be aware
                #  of possible PIIs.
                self.save_progress(
                    "Validation Error - the params data for action could not be parsed"
                )
                return

            handler(params)

        else:
            raise RuntimeError(f"Action {action_id} not found.")

    def initialize(self) -> bool:
        # Load the state in initialize, use it to store data
        # that needs to be accessed across actions
        state = self.load_state() or {}
        self.ingestion_state = state.get(_INGEST_STATE_KEY, {})
        self.auth_state = state.get(_AUTH_STATE_KEY, {})
        self.asset_cache = state.get(_CACHE_STATE_KEY, {})

        return True

    def finalize(self) -> bool:
        state = {
            _INGEST_STATE_KEY: self.ingestion_state,
            _AUTH_STATE_KEY: self.auth_state,
            _CACHE_STATE_KEY: self.asset_cache,
        }
        self.save_state(state)
        return True

    def add_result(self, action_result: PhantomActionResult) -> PhantomActionResult:
        return self.add_action_result(action_result)

    def get_results(self) -> list[PhantomActionResult]:
        return self.get_action_results()

    def debug(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.debug_print(tag, dump_object)

    def error(
        self,
        tag: str,
        dump_object: Union[str, list, dict, PhantomActionResult, Exception] = "",
    ) -> None:
        self.error_print(tag, dump_object)

    def add_exception(self, exception: Exception) -> None:
        self._BaseConnector__conn_result.add_exception(exception)

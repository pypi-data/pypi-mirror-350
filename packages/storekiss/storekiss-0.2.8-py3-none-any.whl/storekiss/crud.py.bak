"""
CRUD operations for SQLite storage.
"""

import json
import os
import re
import sqlite3
import uuid
import datetime
import base64
from pathlib import Path
from contextlib import contextmanager
from datetime import datetime
from typing import Dict, List, Any, Optional, Iterator, Tuple, Union, cast
from storekiss.exceptions import NotFoundError, ValidationError, DatabaseError
from storekiss.geopoint import GeoPoint
from storekiss.reference import Reference, is_reference
import logging

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from storekiss.export_import import LiteStoreExporter, LiteStoreImporter


# 型情報を保持するためのJSONエンコーダとデコーダを実装
class TypedJSONEncoder(json.JSONEncoder):
    """型情報を保持するJSONエンコーダー"""
    def default(self, obj):
        if isinstance(obj, datetime):
            return {
                "__type__": "datetime",
                "value": obj.isoformat()
            }
        elif isinstance(obj, bytes):
            return {
                "__type__": "bytes",
                "value": base64.b64encode(obj).decode('ascii')
            }
        elif isinstance(obj, GeoPoint):
            return {
                "__type__": "geopoint",
                "latitude": obj.latitude,
                "longitude": obj.longitude
            }
        elif is_reference(obj):
            return {
                "__type__": "reference",
                "collection_path": obj.collection_path,
                "document_id": obj.document_id
            }
        return super().default(obj)


def typed_json_decoder(obj):
    """型情報を元に戻すJSONデコーダー"""
    if isinstance(obj, dict) and "__type__" in obj:
        if obj["__type__"] == "datetime":
            return datetime.fromisoformat(obj["value"])
        elif obj["__type__"] == "bytes":
            return base64.b64decode(obj["value"])
        elif obj["__type__"] == "geopoint":
            return GeoPoint(obj["latitude"], obj["longitude"])
        elif obj["__type__"] == "reference":
            return Reference(obj["collection_path"], obj["document_id"])
    return obj

logger = logging.getLogger("crud.py")
logger.setLevel(logging.DEBUG)
logger.debug("ロガーのレベルをDEBUGに設定しました")

# 循環インポートを避けるために遅延インポート
_CollectionReference = None


class ServerTimestampSentinel:
    """
    LiteStoreの SERVER_TIMESTAMP に相当するセンチネル値。

    このオブジェクトをフィールド値として使用すると、ドキュメントの作成時または
    更新時に現在のサーバータイムスタンプに置き換えられます。
    """

    def __repr__(self):
        return "SERVER_TIMESTAMP"


SERVER_TIMESTAMP = ServerTimestampSentinel()


def quote_table_name(name: str) -> str:
    """
    テーブル名をSQLで使用するためにダブルクォートで囲みます。
    これにより、特殊文字や日本語などを含むテーブル名もそのまま使用できます。

    Args:
        name: 元のテーブル名

    Returns:
        SQLで使用するためのテーブル名（ダブルクォート付き）
    """
    # 空の場合はデフォルト名を使用
    if not name:
        return '"collection_default"'

    # ダブルクォートをエスケープ（""にする）
    escaped_name = name.replace('"', '""')

    # ダブルクォートで囲む
    return f'"{escaped_name}"'


class QueryOperator:
    """Base class for query operators."""

    def to_sql(self, field_path: str) -> Tuple[str, List[Any]]:
        """Convert this operator to SQL."""
        raise NotImplementedError


class DateTimeEncoder(json.JSONEncoder):
    """JSON encoder that can handle datetime objects, SERVER_TIMESTAMP, and other special types."""

    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        elif isinstance(obj, ServerTimestampSentinel):
            return datetime.now().isoformat()
        elif isinstance(obj, bytes):
            return base64.b64encode(obj).decode('ascii')
        elif isinstance(obj, GeoPoint):
            return {"latitude": obj.latitude, "longitude": obj.longitude}
        elif is_reference(obj):
            return {"collection_path": obj.collection_path, "document_id": obj.document_id}
        return super().default(obj)


class QueryBuilder:
    """
    A query builder for LiteStore.

    This class provides methods for building queries with a fluent interface
    similar to Google Cloud LiteStore.
    """

    def __init__(self, store, collection: str):
        self.store = store
        self.collection = collection
        self.filters = {}
        self._limit = None
        self._offset = 0
        self._order_by = None
        self._order_direction = "ASC"

    def where(self, field: str, op: str, value: Any) -> "QueryBuilder":
        """
        Add a filter to the query.

        Args:
            field: Field name to filter by.
            op: Operator to use for filtering ("==", "!=", ">", "<", ">=", "<=", "contains", "array-contains").
            value: Value to filter for.

        Returns:
            A QueryBuilder for chaining.
        """
        # _filters_listが存在しない場合は作成
        if not hasattr(self, "_filters_list"):
            self._filters_list = []

        # フィルタを追加
        self._filters_list.append((field, op, value))

        return self

    def order_by(self, field: str, direction: str = "ASC") -> "QueryBuilder":
        """Order results by a field."""
        self._order_by = field
        self._order_direction = direction
        return self

    def limit(self, limit: int) -> "QueryBuilder":
        """Limit the number of results."""
        self._limit = limit
        return self

    def offset(self, offset: int) -> "QueryBuilder":
        """Skip a number of results."""
        self._offset = offset
        return self

    def get(self) -> List[Dict[str, Any]]:
        """Execute the query and get results."""
        # Save the current collection
        original_collection = self.store.default_collection
        # Set the collection to this query's collection
        self.store.default_collection = self.collection

        # _filters_listが存在する場合は、それを使用
        filters_list = getattr(self, "_filters_list", [])

        try:
            return self.store.query(
                filters=filters_list,
                limit=self._limit,
                offset=self._offset,
                order_by=self._order_by,
                order_direction=self._order_direction,
            )
        finally:
            # Restore the original collection
            self.store.default_collection = original_collection

    def count(self) -> int:
        """Count the number of matching documents."""
        # Save the current collection
        original_collection = self.store.default_collection
        # Set the collection to this query's collection
        self.store.default_collection = self.collection

        try:
            return self.store.count(self.filters)
        finally:
            # Restore the original collection
            self.store.default_collection = original_collection


class Collection:
    """
    A collection in LiteStore.

    This class provides methods for working with a collection of documents.
    """

    def __init__(self, store, name: str):
        self.store = store
        self.name = name

    def doc(self, id: Optional[str] = None) -> "Document":
        """
        Get a document reference.

        Args:
            id: Optional document ID. If not provided, a random ID will be generated
                when the document is created.

        Returns:
            A Document reference.
        """
        if id is None:
            id = str(uuid.uuid4()).replace("-", "")[:20]
        return Document(self.store, self.name, id)

    def add(self, data: Dict[str, Any], id: Optional[str] = None) -> Dict[str, Any]:
        """Add a document to the collection."""
        # Save the current collection
        original_collection = self.store.default_collection
        # Set the collection to this collection
        self.store.default_collection = self.name

        try:
            result = self.store.create(data, id)
            return result
        finally:
            # Restore the original collection
            self.store.default_collection = original_collection

    def where(self, field: str, op: str, value: Any) -> QueryBuilder:
        """
        Create a query with a filter.

        Args:
            field: Field name to filter by.
            op: Operator to use for filtering ("==", "!=", ">", "<", ">=", "<=").
            value: Value to filter for.

        Returns:
            A QueryBuilder for chaining.
        """
        query = QueryBuilder(self.store, self.name)
        return query.where(field, op, value)

    def order_by(self, field: str, direction: str = "ASC") -> QueryBuilder:
        """Create a query with ordering."""
        query = QueryBuilder(self.store, self.name)
        return query.order_by(field, direction)

    def limit(self, limit: int) -> QueryBuilder:
        """Create a query with a limit."""
        query = QueryBuilder(self.store, self.name)
        return query.limit(limit)

    def get(self) -> List[Dict[str, Any]]:
        """Get all documents in the collection."""
        # Save the current collection
        original_collection = self.store.default_collection
        self.store.default_collection = self.name

        try:
            return self.store.list()
        finally:
            # Restore the original collection
            self.store.default_collection = original_collection


class Document:
    """
    A document in LiteStore.

    This class provides methods for working with a document.
    """

    def __init__(self, store, collection: str, id: str):
        self.store = store
        self.collection = collection
        self.id = id

    def exists(self) -> bool:
        """Check if the document exists."""
        # Save the current collection
        original_collection = self.store.default_collection
        # Set the collection to this document's collection
        self.store.default_collection = self.collection

        try:
            self.store.read(self.id)
            return True
        except NotFoundError:
            return False
        finally:
            # Restore the original collection
            self.store.default_collection = original_collection
            
    def get(self):
        """Get the document data as a DocumentSnapshot (Firestore互換)."""
        original_collection = self.store.default_collection
        self.store.default_collection = self.collection
        try:
            data = self.store.read(self.id)
            # DocumentSnapshotオブジェクトを作成するときに、collection名とstoreオブジェクトも渡す
            return DocumentSnapshot(data, id=self.id, collection=self.collection, store=self.store)
        except NotFoundError:
            return None
        except Exception as e:
            logger.error(f"Document.getメソッドで例外が発生: {str(e)}")
            raise
        finally:
            self.store.default_collection = original_collection



    def set(self, data: Dict[str, Any], merge: bool = True) -> Dict[str, Any]:
        """Set the document data."""
        original_collection = self.store.default_collection
        self.store.default_collection = self.collection
        try:
            try:
                return self.store.update(self.id, data, merge=merge)
            except NotFoundError:
                return self.store.create(data, id=self.id)
        finally:
            self.store.default_collection = original_collection

    def update(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Update the document data."""
        original_collection = self.store.default_collection
        self.store.default_collection = self.collection
        try:
            return self.store.update(self.id, data, merge=True)
        finally:
            self.store.default_collection = original_collection

    def delete(self) -> None:
        """Delete the document."""
        original_collection = self.store.default_collection
        self.store.default_collection = self.collection
        try:
            self.store.delete(self.id)
        finally:
            self.store.default_collection = original_collection


class DocumentSnapshot:
    """Firestore互換のドキュメントスナップショット"""
    def __init__(self, data, id=None, collection=None, store=None):
        self._data = data
        self._id = id
        self._collection = collection
        self._store = store
        self._reference = None
        
    def to_dict(self):
        return self._data
        
    @property
    def exists(self):
        return self._data is not None
        
    @property
    def id(self):
        return self._id
        
    @property
    def reference(self):
        """
        ドキュメント参照を返します。
        
        Returns:
            DocumentReference: ドキュメント参照
            
        Raises:
            ValueError: ドキュメント参照の作成に必要な情報が不足している場合
        """
        if self._reference is None:
            # 必要な情報があるか確認
            if self._id is None:
                raise ValueError("ドキュメントIDが設定されていません")
            
            if self._collection is None:
                raise ValueError(f"ドキュメントのコレクション名が設定されていません: id={self._id}")
            
            if self._store is None:
                raise ValueError(f"ドキュメントのストアオブジェクトが設定されていません: id={self._id}, collection={self._collection}")
            
            # Documentオブジェクトを作成
            from storekiss.litestore import DocumentReference
            doc = Document(self._store, self._collection, self._id)
            # DocumentReferenceオブジェクトを作成
            self._reference = DocumentReference(doc)
        
        return self._reference




class LiteStore:
    """
    A LiteStore-like interface for storing and retrieving data using SQLite.

    This class provides methods for creating, reading, updating, and deleting
    data in a SQLite database. The data is stored as JSON in a single table,
    with indexed fields extracted to separate columns for efficient querying.
    """

    def __init__(
        self,
        db_path: str = "storekiss.db",
        default_collection: str = "items",
        index_all_fields: bool = False,
    ):
        """
        Initialize a new CRUDStore.

        Args:
            db_path: Path to the SQLite database file. Use ":memory:" for an in-memory database.
            default_collection: Name of the default collection (table) to store data in.
            index_all_fields: If True, all fields will be indexed.
        """
        # db_pathがNoneの場合はデフォルト値を使用
        self.db_path = db_path if db_path is not None else ":memory:"
        self.default_collection = quote_table_name(
            default_collection
        )  # Default collection
        self.index_all_fields = index_all_fields

        self._initialize_db()

    @contextmanager
    def _get_connection(self) -> Iterator[sqlite3.Connection]:
        """Get a database connection with proper error handling."""
        conn = None
        try:
            logger.debug(f"データベース接続を開始: {self.db_path}")
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row
            logger.debug("データベース接続成功")
            yield conn
        except sqlite3.Error as e:
            logger.error(f"データベース接続エラー: {str(e)}")
            raise DatabaseError(f"Database error: {str(e)}")
        finally:
            if conn is not None:
                logger.debug("データベース接続をクローズ")
                conn.close()

    def _ensure_table_exists(self, collection_name: str) -> None:
        """テーブルが存在することを確認し、存在しない場合は作成します。

        Args:
            collection_name: 確認または作成するテーブル名
        """
        logger.debug(f"テーブル {collection_name} の存在を確認します")
        with self._get_connection() as conn:
            cursor = conn.cursor()

            # テーブルが存在するか確認
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (collection_name,)
            )
            table_exists = cursor.fetchone() is not None

            if not table_exists:
                logger.info(f"テーブル {collection_name} が存在しないため作成します")
                # テーブルが存在しない場合は作成
                cursor.execute(
                    f"""
                    CREATE TABLE IF NOT EXISTS {collection_name} (
                        id TEXT PRIMARY KEY,
                        data TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                    """
                )
                conn.commit()
                logger.debug(f"テーブル {collection_name} を作成しました")
            else:
                logger.debug(f"テーブル {collection_name} は既に存在します")

    def _initialize_db(self) -> None:
        """Initialize the database with the required tables and indexes."""
        with self._get_connection() as conn:
            cursor = conn.cursor()

            # デフォルトコレクションのテーブルを作成
            self._ensure_table_exists(self.default_collection)

            try:
                cursor.execute("SELECT json_extract('{\"test\":123}', '$.test')")
                result = cursor.fetchone()[0]
                if result != 123:
                    raise DatabaseError("SQLite JSON1 extension test failed")
            except sqlite3.OperationalError:
                raise DatabaseError(
                    "SQLite JSON1 extension is required but not available"
                )

            # インデックスの作成はスキーマなしで行うため、ここでは実装しない

            conn.commit()

    def _process_server_timestamp(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        SERVER_TIMESTAMPセンチネル値を現在のタイムスタンプに置き換えます。

        Args:
            data: 処理するデータ

        Returns:
            SERVER_TIMESTAMPが置き換えられたデータ
        """
        processed_data = {}
        for key, value in data.items():
            if isinstance(value, ServerTimestampSentinel):
                processed_data[key] = datetime.now()
            elif isinstance(value, dict):
                processed_data[key] = self._process_server_timestamp(value)
            elif isinstance(value, list):
                processed_data[key] = [
                    (
                        self._process_server_timestamp(item)
                        if isinstance(item, dict)
                        else (
                            datetime.now()
                            if isinstance(item, ServerTimestampSentinel)
                            else item
                        )
                    )
                    for item in value
                ]
            else:
                processed_data[key] = value
        return processed_data

    def _validate_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Process data before storing."""
        # SERVER_TIMESTAMPを処理
        processed_data = self._process_server_timestamp(data)
        return processed_data

    def create(self, data: Dict[str, Any], id: Optional[str] = None) -> Dict[str, Any]:
        """
        Create a new item in the store.

        Args:
            data: The data to store.
            id: Optional ID for the item. If not provided, a UUID will be generated.

        Returns:
            The created item with its ID.

        Raises:
            ValidationError: If the data fails validation.
            DatabaseError: If there's an error with the database.
        """
        validated_data = self._validate_data(data)

        item_id = id if id is not None else str(uuid.uuid4())

        item = {"id": item_id, **validated_data}

        with self._get_connection() as conn:
            cursor = conn.cursor()
            try:
                cursor.execute(
                    f"INSERT INTO {self.default_collection} (id, data) VALUES (?, ?)",
                    (item_id, json.dumps(validated_data, cls=TypedJSONEncoder)),
                )
                conn.commit()
            except sqlite3.IntegrityError:
                raise ValidationError(f"Item with ID '{item_id}' already exists")

        return item

    def read(self, id: str) -> Dict[str, Any]:
        """
        Read an item from the store by its ID.

        Args:
            id: The ID of the item to read.

        Returns:
            The item data.

        Raises:
            NotFoundError: If the item is not found.
            DatabaseError: If there's an error with the database.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT id, data FROM {self.default_collection} WHERE id = ?", (id,)
            )
            row = cursor.fetchone()

            if not row:
                raise NotFoundError(f"Item with ID '{id}' not found")

            # JSONデコード時に型情報を元にdatetimeオブジェクトに変換
            data = json.loads(row["data"], object_hook=typed_json_decoder)
            return {"id": row["id"], **data}

    def _set_nested_value(self, data: Dict[str, Any], path: str, value: Any) -> None:
        """ドット表記のパスを使用してネストされた値を設定

        Args:
            data: 更新するデータ辞書
            path: ドット表記のフィールドパス
            value: 設定する値
        """
        parts = path.split(".")
        current = data
        
        for i, part in enumerate(parts[:-1]):
            if part not in current:
                current[part] = {}
            elif not isinstance(current[part], dict):
                current[part] = {}
                
            current = current[part]
            
        current[parts[-1]] = value

    def update(
        self, id: str, data: Dict[str, Any], merge: bool = True
    ) -> Dict[str, Any]:
        """Update an item in the store.

        Args:
            id: The ID of the item to update.
            data: The new data for the item.
            merge: If True, merge the new data with the existing data.
                  If False, replace the existing data entirely.

        Returns:
            The updated item.

        Raises:
            NotFoundError: If the item is not found.
            ValidationError: If the data fails validation.
            DatabaseError: If there's an error with the database.
        """
        logger.debug(f"updateメソッドが呼び出されました: id={id}, merge={merge}, collection={self.default_collection}")
        try:
            # テーブルが存在するか確認し、存在しない場合は作成する
            self._ensure_table_exists(self.default_collection)

            with self._get_connection() as conn:
                cursor = conn.cursor()
                logger.debug(f"SQLクエリ実行: SELECT data FROM {self.default_collection} WHERE id = {id}")
                cursor.execute(
                    f"SELECT data FROM {self.default_collection} WHERE id = ?", (id,)
                )
                row = cursor.fetchone()
                logger.debug(f"クエリ結果: {row is not None}")
        except sqlite3.OperationalError as e:
            if "no such table" in str(e):
                logger.info(f"テーブル {self.default_collection} が存在しないため作成します")
                self._ensure_table_exists(self.default_collection)
                # テーブル作成後に再試行
                return self.update(id, data, merge)
            logger.error(f"SQLite操作エラー: {str(e)}")
            raise DatabaseError(f"Database error: {str(e)}")
        except Exception as e:
            logger.error(f"updateメソッドで例外が発生: {str(e)}")
            raise

        if not row:
            raise NotFoundError(f"Item with ID '{id}' not found")

        if merge:
            existing_data = json.loads(row["data"], object_hook=typed_json_decoder)

            # 特殊な値を処理する
            merged_data = {**existing_data}
            for key, value in data.items():
                # 文字列リテラルを使用して循環インポートを避ける
                if str(value) == "DELETE_FIELD":
                    if "." in key:
                        logger.warning(f"ネストされたフィールドの削除はサポートされていません: {key}")
                    elif key in merged_data:
                        del merged_data[key]
                else:
                    if "." in key:
                        self._set_nested_value(merged_data, key, value)
                    else:
                        merged_data[key] = value

            validated_data = self._validate_data(merged_data)
        else:
            validated_data = self._validate_data(data)

        try:
            with self._get_connection() as conn:
                cursor = conn.cursor()
                logger.debug(f"SQLクエリ実行: UPDATE {self.default_collection} SET data = ?, updated_at = CURRENT_TIMESTAMP WHERE id = {id}")
                cursor.execute(
                    f"UPDATE {self.default_collection} SET data = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                    (json.dumps(validated_data, cls=TypedJSONEncoder), id),
                )
                conn.commit()
                logger.debug(f"更新成功: id={id}")
        except Exception as e:
            logger.error(f"更新中に例外が発生: {str(e)}")
            raise

        return {"id": id, **validated_data}

    def delete(self, id: str) -> None:
        """
        Delete an item from the store.

        Args:
            id: The ID of the item to delete.

        Raises:
            NotFoundError: If the item is not found.
            DatabaseError: If there's an error with the database.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(f"DELETE FROM {self.default_collection} WHERE id = ?", (id,))

            if cursor.rowcount == 0:
                raise NotFoundError(f"Item with ID '{id}' not found")

            conn.commit()

    def list(
        self, limit: Optional[int] = None, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        List items in the store.

        Args:
            limit: Maximum number of items to return.
            offset: Number of items to skip.

        Returns:
            A list of items.

        Raises:
            DatabaseError: If there's an error with the database.
        """
        # テーブル名がすでにダブルクォートで囲まれている場合は、そのまま使用する
        table_name = self.default_collection
        query = f"SELECT id, data FROM {table_name}"
        params = []

        if limit is not None and offset > 0:
            query += " LIMIT ? OFFSET ?"
            params.extend([limit, offset])
        elif limit is not None:
            query += " LIMIT ?"
            params.append(limit)
        elif offset > 0:
            query += " LIMIT -1 OFFSET ?"
            params.append(offset)

        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows = cursor.fetchall()

            items = []
            for row in rows:
                data = json.loads(row["data"], object_hook=typed_json_decoder)
                items.append(DocumentSnapshot(data, id=row["id"]))

            return items

    def query(
        self,
        filters=None,
        limit: Optional[int] = None,
        offset: int = 0,
        order_by: Optional[str] = None,
        order_direction: str = "ASC",
    ) -> List[Dict[str, Any]]:
        """
        Query items in the store based on filters.

        Args:
            filters: Dictionary of field-value pairs to filter by or list of (field, op, value) tuples.
            limit: Maximum number of items to return.
            offset: Number of items to skip.
            order_by: Field to order by.
            order_direction: Direction to order (ASC or DESC).

        Returns:
            A list of matching items.

        Raises:
            DatabaseError: If there's an error with the database.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()

            # テーブル名がすでにダブルクォートで囲まれている場合は、そのまま使用する
            table_name = self.default_collection
            query = f"SELECT id, data FROM {table_name}"
            params = []

            if filters:
                where_clauses = []

                # filtersがリストの場合（(field, op, value)のタプルのリスト）
                if isinstance(filters, list):
                    for field, op, value in filters:
                        json_path = f"$.{field}"
                        
                        if "." in field:
                            parts = field.split(".")
                            json_path = "$"
                            for part in parts:
                                json_path += f".{part}"

                        # 演算子の変換（"=="から"="へ）
                        sql_op = "=" if op == "==" else op
                        
                        if op in ["contains", "array-contains"]:
                            where_clauses.append(
                                f"EXISTS (SELECT 1 FROM json_each(json_extract(data, '{json_path}')) "
                                f"WHERE value = ?)"
                            )
                            params.append(value)
                        elif value is None:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') IS NULL"
                            )
                        elif isinstance(value, bool):
                            bool_value = 1 if value else 0
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') {sql_op} ?"
                            )
                            params.append(bool_value)
                        else:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') {sql_op} ?"
                            )
                            params.append(value)

                # filtersが辞書の場合（従来の方法）
                elif isinstance(filters, dict):
                    for key, value in filters.items():
                        json_path = f"$.{key}"
                        
                        if "." in key:
                            parts = key.split(".")
                            json_path = "$"
                            for part in parts:
                                json_path += f".{part}"

                        if value is None:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') IS NULL"
                            )
                        elif isinstance(value, bool):
                            bool_value = 1 if value else 0
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') = ?"
                            )
                            params.append(bool_value)
                        elif isinstance(value, list) and len(value) > 0 and value[0] == "contains":
                            where_clauses.append(
                                f"EXISTS (SELECT 1 FROM json_each(json_extract(data, '{json_path}')) "
                                f"WHERE value = ?)"
                            )
                            params.append(value[1])
                        else:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') = ?"
                            )
                            params.append(value)

                if where_clauses:
                    query += " WHERE " + " AND ".join(where_clauses)

            # ORDER BY句の処理
            if order_by:
                json_path = f"$.{order_by}"
                query += (
                    f" ORDER BY json_extract(data, '{json_path}') {order_direction}"
                )

            # LIMITとOFFSET句の処理
            if limit is not None and offset > 0:
                query += " LIMIT ? OFFSET ?"
                params.extend([limit, offset])
            elif limit is not None:
                query += " LIMIT ?"
                params.append(limit)
            elif offset > 0:
                query += " LIMIT -1 OFFSET ?"
                params.append(offset)

            cursor.execute(query, params)
            rows = cursor.fetchall()

            items = []
            for row in rows:
                data = json.loads(row["data"], object_hook=typed_json_decoder)
                items.append(DocumentSnapshot(data, id=row["id"]))

            return items

    def query(
        self,
        filters=None,
        limit: Optional[int] = None,
        offset: int = 0,
        order_by: Optional[str] = None,
        order_direction: str = "ASC",
    ) -> List[Dict[str, Any]]:
        """
        Query items in the store based on filters.

        Args:
            filters: Dictionary of field-value pairs to filter by or list of (field, op, value) tuples.
            limit: Maximum number of items to return.
            offset: Number of items to skip.
            order_by: Field to order by.
            order_direction: Direction to order (ASC or DESC).

        Returns:
            A list of matching items.

        Raises:
            DatabaseError: If there's an error with the database.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()

            # テーブル名がすでにダブルクォートで囲まれている場合は、そのまま使用する
            table_name = self.default_collection
            query = f"SELECT id, data FROM {table_name}"
            params = []

            if filters:
                where_clauses = []

                # filtersがリストの場合（(field, op, value)のタプルのリスト）
                if isinstance(filters, list):
                    for field, op, value in filters:
                        json_path = f"$.{field}"
                        
                        if "." in field:
                            parts = field.split(".")
                            json_path = "$"
                            for part in parts:
                                json_path += f".{part}"

                        # 演算子の変換（"=="から"="へ）
                        sql_op = "=" if op == "==" else op
                        
                        if op in ["contains", "array-contains"]:
                            where_clauses.append(
                                f"EXISTS (SELECT 1 FROM json_each(json_extract(data, '{json_path}')) "
                                f"WHERE value = ?)"
                            )
                            params.append(value)
                        elif value is None:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') IS NULL"
                            )
                        elif isinstance(value, bool):
                            bool_value = 1 if value else 0
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') {sql_op} ?"
                            )
                            params.append(bool_value)
                        else:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') {sql_op} ?"
                            )
                            params.append(value)

                # filtersが辞書の場合（従来の方法）
                elif isinstance(filters, dict):
                    for key, value in filters.items():
                        json_path = f"$.{key}"
                        
                        if "." in key:
                            parts = key.split(".")
                            json_path = "$"
                            for part in parts:
                                json_path += f".{part}"

                        if value is None:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') IS NULL"
                            )
                        elif isinstance(value, bool):
                            bool_value = 1 if value else 0
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') = ?"
                            )
                            params.append(bool_value)
                        elif isinstance(value, list) and len(value) > 0 and value[0] == "contains":
                            where_clauses.append(
                                f"EXISTS (SELECT 1 FROM json_each(json_extract(data, '{json_path}')) "
                                f"WHERE value = ?)"
                            )
                            params.append(value[1])
                        else:
                            where_clauses.append(
                                f"json_extract(data, '{json_path}') = ?"
                            )
                            params.append(value)

                if where_clauses:
                    query += " WHERE " + " AND ".join(where_clauses)

            # ORDER BY句の処理
            if order_by:
                json_path = f"$.{order_by}"
                query += (
                    f" ORDER BY json_extract(data, '{json_path}') {order_direction}"
                )

            # LIMITとOFFSET句の処理
            if limit is not None and offset > 0:
                query += " LIMIT ? OFFSET ?"
                params.extend([limit, offset])
            elif limit is not None:
                query += " LIMIT ?"
                params.append(limit)
            elif offset > 0:
                query += " LIMIT -1 OFFSET ?"
                params.append(offset)

            cursor.execute(query, params)
            rows = cursor.fetchall()

            items = []
            for row in rows:
                data = json.loads(row["data"], object_hook=typed_json_decoder)
                items.append(DocumentSnapshot(data, id=row["id"], collection=self.default_collection, store=self))

            return items

    def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        Count items in the store, optionally filtered.

        Args:
            filters: Optional dictionary of field-value pairs to filter by.

        Returns:
            The number of matching items.

        Raises:
            DatabaseError: If there's an error with the database.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()

            # テーブル名がすでにダブルクォートで囲まれている場合は、そのまま使用する
            table_name = self.default_collection
            query = f"SELECT COUNT(*) FROM {table_name}"
            params = []

            if filters:
                where_clauses = []
                for key, value in filters.items():
                    json_path = f"$.{key}"
                    
                    if "." in key:
                        parts = key.split(".")
                        json_path = "$"
                        for part in parts:
                            json_path += f".{part}"

                    if value is None:
                        where_clauses.append(
                            f"json_extract(data, '{json_path}') IS NULL"
                        )
                    elif isinstance(value, bool):
                        bool_value = 1 if value else 0
                        where_clauses.append(
                            f"json_extract(data, '{json_path}') = ?"
                        )
                        params.append(bool_value)
                    else:
                        where_clauses.append(
                            f"json_extract(data, '{json_path}') = ?"
                        )
                        params.append(value)

                if where_clauses:
                    query += " WHERE " + " AND ".join(where_clauses)

            cursor.execute(query, params)
            result = cursor.fetchone()
            return result[0] if result else 0

    def collection(
        self, name: str
    ) -> Collection:
        """Get a collection reference.

        Args:
            name: Name of the collection

        Returns:
            A CollectionReference object for the specified collection.
        """
        global _CollectionReference
        if _CollectionReference is None:
            from storekiss.litestore import CollectionReference

            _CollectionReference = CollectionReference

        collection = self.get_collection(name)
        return _CollectionReference(collection)

    def get_collection(self, name: str) -> "Collection":
        """Get a collection reference.

        Args:
            name: Name of the collection

        Returns:
            A Collection object for the specified collection.
        """
        # テーブル名を安全な形式に変換
        safe_name = quote_table_name(name)

        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                (safe_name,),
            )
            if not cursor.fetchone():
                cursor.execute(
                    f"""
                    CREATE TABLE IF NOT EXISTS {safe_name} (
                        id TEXT PRIMARY KEY,
                        data TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """
                )
                conn.commit()

                # スキーマ機能を削除したため、インデックスの自動作成も削除

        return Collection(self, safe_name)
        
    def rebuild_indexes(self, collection_name: Optional[str] = None) -> Dict[str, List[str]]:
        """
        インデックスが破損した場合に全フィールドでインデックスを再構築します。
        
        特定のコレクションまたはすべてのコレクションのドキュメントをスキャンし、
        すべてのフィールドに対してSQLiteインデックスを作成します。
        既存のインデックスは削除され、新しいインデックスで置き換えられます。
        
        Args:
            collection_name: 再構築するコレクション名。Noneの場合はすべてのコレクションが対象。
            
        Returns:
            コレクション名とそのコレクションで作成されたインデックスのリストを含む辞書
            
        Raises:
            DatabaseError: データベース操作中にエラーが発生した場合
        """
        result = {}
        
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            if collection_name:
                collections = [quote_table_name(collection_name)]
            else:
                cursor.execute(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name != 'sqlite_sequence'"
                )
                collections = [row['name'] for row in cursor.fetchall()]
            
            for coll_name in collections:
                created_indexes = []
                
                try:
                    cursor.execute(
                        f"SELECT name FROM sqlite_master WHERE type='index' AND tbl_name=? AND name NOT LIKE '%autoindex%'",
                        (coll_name,)
                    )
                    indexes = [row['name'] for row in cursor.fetchall()]
                    
                    for idx_name in indexes:
                        try:
                            cursor.execute(f"DROP INDEX IF EXISTS {idx_name}")
                            logging.info(f"インデックス {idx_name} を削除しました")
                        except sqlite3.Error as e:
                            logging.warning(f"インデックス {idx_name} の削除中にエラーが発生しました: {e}")
                    
                    cursor.execute(f"SELECT data FROM {coll_name}")
                    rows = cursor.fetchall()
                    
                    if not rows:
                        logging.info(f"コレクション {coll_name} にドキュメントがありません")
                        result[coll_name] = []
                        continue
                    
                    all_fields = set()
                    for row in rows:
                        try:
                            data = json.loads(row['data'])
                            for field in data.keys():
                                all_fields.add(field)
                        except json.JSONDecodeError:
                            logging.warning(f"コレクション {coll_name} の無効なJSONデータをスキップします")
                    
                    for field in all_fields:
                        index_name = f"idx_{coll_name}_{field}".replace('"', '')
                        try:
                            cursor.execute(
                                f"CREATE INDEX IF NOT EXISTS {index_name} ON {coll_name} (json_extract(data, '$.{field}'))"
                            )
                            conn.commit()
                            created_indexes.append(field)
                            logging.info(f"フィールド {field} のインデックス {index_name} を作成しました")
                        except sqlite3.Error as e:
                            logging.error(f"フィールド {field} のインデックス作成中にエラーが発生しました: {e}")
                    
                    result[coll_name] = created_indexes
                    
                except sqlite3.Error as e:
                    logging.error(f"コレクション {coll_name} のインデックス再構築中にエラーが発生しました: {e}")
                    raise DatabaseError(f"Failed to rebuild indexes for collection {coll_name}: {str(e)}")
        
        return result


# 循環インポートを解決するための遅延インポート設定
def _setup_imports():
    global _CollectionReference
    if _CollectionReference is None:
        from storekiss.litestore import CollectionReference

        _CollectionReference = CollectionReference


# 初期化時に遅延インポートを設定
_setup_imports()


# LiteStoreクラスにエクスポート/インポート機能を追加
def _add_export_import_to_litestore():
    """
    LiteStoreクラスにエクスポート/インポート機能を追加します。
    """
    try:
        from storekiss.export_import import LiteStoreExporter, LiteStoreImporter
        
        def export_collection(self, collection_name: str, output_dir: str) -> str:
            """
            指定されたコレクションをLiteStore互換形式でエクスポートします。

            Args:
                collection_name: エクスポートするコレクション名
                output_dir: 出力ディレクトリのパス

            Returns:
                エクスポートされたメタデータファイルのパス
            """
            exporter = LiteStoreExporter(self)
            return exporter.export_collection(collection_name, output_dir)

        def export_all_collections(self, output_dir: str) -> str:
            """
            すべてのコレクションをLiteStore互換形式でエクスポートします。

            Args:
                output_dir: 出力ディレクトリのパス

            Returns:
                エクスポートされたメタデータファイルのパス
            """
            exporter = LiteStoreExporter(self)
            return exporter.export_all_collections(output_dir)

        def import_collection(self, collection_name: str, input_dir: str) -> int:
            """
            指定されたコレクションをインポートします。

            Args:
                collection_name: インポートするコレクション名
                input_dir: 入力ディレクトリのパス

            Returns:
                インポートされたドキュメント数
            """
            importer = LiteStoreImporter(self)
            return importer.import_collection(collection_name, input_dir)

        def import_all_collections(self, input_dir: str) -> Dict[str, int]:
            """
            すべてのコレクションをインポートします。

            Args:
                input_dir: 入力ディレクトリのパス

            Returns:
                コレクション名とインポートされたドキュメント数の辞書
            """
            importer = LiteStoreImporter(self)
            return importer.import_all_collections(input_dir)

        # LiteStoreクラスにメソッドを追加
        LiteStore = globals()['LiteStore']
        LiteStore.export_collection = export_collection
        LiteStore.export_all_collections = export_all_collections
        LiteStore.import_collection = import_collection
        LiteStore.import_all_collections = import_all_collections
    except (ImportError, KeyError) as e:
        logging.warning(f"Failed to add export/import functionality: {e}")


# エクスポート/インポート機能を追加
_add_export_import_to_litestore()
